
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000464a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001d2  00800060  0000464a  000046de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000617  00800232  00800232  000048b0  2**0
                  ALLOC
  3 .stab         000090fc  00000000  00000000  000048b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005b84  00000000  00000000  0000d9ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00013530  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000197  00000000  00000000  00013670  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001b11  00000000  00000000  00013807  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ebc  00000000  00000000  00015318  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000e5b  00000000  00000000  000161d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00017030  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002b1  00000000  00000000  00017190  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000836  00000000  00000000  00017441  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00017c77  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 97 16 	jmp	0x2d2e	; 0x2d2e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e4       	ldi	r30, 0x4A	; 74
      68:	f6 e4       	ldi	r31, 0x46	; 70
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 33       	cpi	r26, 0x32	; 50
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a2 e3       	ldi	r26, 0x32	; 50
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 34       	cpi	r26, 0x49	; 73
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 01 22 	call	0x4402	; 0x4402 <main>
      8a:	0c 94 23 23 	jmp	0x4646	; 0x4646 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 19 03 	call	0x632	; 0x632 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 49 03 	call	0x692	; 0x692 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 49 03 	call	0x692	; 0x692 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 e3 22 	jmp	0x45c6	; 0x45c6 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ad eb       	ldi	r26, 0xBD	; 189
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 ff 22 	jmp	0x45fe	; 0x45fe <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 ef 22 	jmp	0x45de	; 0x45de <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 0b 23 	jmp	0x4616	; 0x4616 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 ef 22 	jmp	0x45de	; 0x45de <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 0b 23 	jmp	0x4616	; 0x4616 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 e3 22 	jmp	0x45c6	; 0x45c6 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8d eb       	ldi	r24, 0xBD	; 189
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 ff 22 	jmp	0x45fe	; 0x45fe <__epilogue_restores__>

00000632 <__gesf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 ef 22 	jmp	0x45de	; 0x45de <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gesf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gesf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 b2 05 	call	0xb64	; 0xb64 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gesf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 0b 23 	jmp	0x4616	; 0x4616 <__epilogue_restores__+0x18>

00000692 <__fixsfsi>:
     692:	ac e0       	ldi	r26, 0x0C	; 12
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 f3 22 	jmp	0x45e6	; 0x45e6 <__prologue_saves__+0x20>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	ce 01       	movw	r24, r28
     6a8:	01 96       	adiw	r24, 0x01	; 1
     6aa:	be 01       	movw	r22, r28
     6ac:	6b 5f       	subi	r22, 0xFB	; 251
     6ae:	7f 4f       	sbci	r23, 0xFF	; 255
     6b0:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     6b4:	8d 81       	ldd	r24, Y+5	; 0x05
     6b6:	82 30       	cpi	r24, 0x02	; 2
     6b8:	61 f1       	breq	.+88     	; 0x712 <__fixsfsi+0x80>
     6ba:	82 30       	cpi	r24, 0x02	; 2
     6bc:	50 f1       	brcs	.+84     	; 0x712 <__fixsfsi+0x80>
     6be:	84 30       	cpi	r24, 0x04	; 4
     6c0:	21 f4       	brne	.+8      	; 0x6ca <__fixsfsi+0x38>
     6c2:	8e 81       	ldd	r24, Y+6	; 0x06
     6c4:	88 23       	and	r24, r24
     6c6:	51 f1       	breq	.+84     	; 0x71c <__fixsfsi+0x8a>
     6c8:	2e c0       	rjmp	.+92     	; 0x726 <__fixsfsi+0x94>
     6ca:	2f 81       	ldd	r18, Y+7	; 0x07
     6cc:	38 85       	ldd	r19, Y+8	; 0x08
     6ce:	37 fd       	sbrc	r19, 7
     6d0:	20 c0       	rjmp	.+64     	; 0x712 <__fixsfsi+0x80>
     6d2:	6e 81       	ldd	r22, Y+6	; 0x06
     6d4:	2f 31       	cpi	r18, 0x1F	; 31
     6d6:	31 05       	cpc	r19, r1
     6d8:	1c f0       	brlt	.+6      	; 0x6e0 <__fixsfsi+0x4e>
     6da:	66 23       	and	r22, r22
     6dc:	f9 f0       	breq	.+62     	; 0x71c <__fixsfsi+0x8a>
     6de:	23 c0       	rjmp	.+70     	; 0x726 <__fixsfsi+0x94>
     6e0:	8e e1       	ldi	r24, 0x1E	; 30
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	82 1b       	sub	r24, r18
     6e6:	93 0b       	sbc	r25, r19
     6e8:	29 85       	ldd	r18, Y+9	; 0x09
     6ea:	3a 85       	ldd	r19, Y+10	; 0x0a
     6ec:	4b 85       	ldd	r20, Y+11	; 0x0b
     6ee:	5c 85       	ldd	r21, Y+12	; 0x0c
     6f0:	04 c0       	rjmp	.+8      	; 0x6fa <__fixsfsi+0x68>
     6f2:	56 95       	lsr	r21
     6f4:	47 95       	ror	r20
     6f6:	37 95       	ror	r19
     6f8:	27 95       	ror	r18
     6fa:	8a 95       	dec	r24
     6fc:	d2 f7       	brpl	.-12     	; 0x6f2 <__fixsfsi+0x60>
     6fe:	66 23       	and	r22, r22
     700:	b1 f0       	breq	.+44     	; 0x72e <__fixsfsi+0x9c>
     702:	50 95       	com	r21
     704:	40 95       	com	r20
     706:	30 95       	com	r19
     708:	21 95       	neg	r18
     70a:	3f 4f       	sbci	r19, 0xFF	; 255
     70c:	4f 4f       	sbci	r20, 0xFF	; 255
     70e:	5f 4f       	sbci	r21, 0xFF	; 255
     710:	0e c0       	rjmp	.+28     	; 0x72e <__fixsfsi+0x9c>
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	40 e0       	ldi	r20, 0x00	; 0
     718:	50 e0       	ldi	r21, 0x00	; 0
     71a:	09 c0       	rjmp	.+18     	; 0x72e <__fixsfsi+0x9c>
     71c:	2f ef       	ldi	r18, 0xFF	; 255
     71e:	3f ef       	ldi	r19, 0xFF	; 255
     720:	4f ef       	ldi	r20, 0xFF	; 255
     722:	5f e7       	ldi	r21, 0x7F	; 127
     724:	04 c0       	rjmp	.+8      	; 0x72e <__fixsfsi+0x9c>
     726:	20 e0       	ldi	r18, 0x00	; 0
     728:	30 e0       	ldi	r19, 0x00	; 0
     72a:	40 e0       	ldi	r20, 0x00	; 0
     72c:	50 e8       	ldi	r21, 0x80	; 128
     72e:	b9 01       	movw	r22, r18
     730:	ca 01       	movw	r24, r20
     732:	2c 96       	adiw	r28, 0x0c	; 12
     734:	e2 e0       	ldi	r30, 0x02	; 2
     736:	0c 94 0f 23 	jmp	0x461e	; 0x461e <__epilogue_restores__+0x20>

0000073a <__floatunsisf>:
     73a:	a8 e0       	ldi	r26, 0x08	; 8
     73c:	b0 e0       	ldi	r27, 0x00	; 0
     73e:	e3 ea       	ldi	r30, 0xA3	; 163
     740:	f3 e0       	ldi	r31, 0x03	; 3
     742:	0c 94 eb 22 	jmp	0x45d6	; 0x45d6 <__prologue_saves__+0x10>
     746:	7b 01       	movw	r14, r22
     748:	8c 01       	movw	r16, r24
     74a:	61 15       	cp	r22, r1
     74c:	71 05       	cpc	r23, r1
     74e:	81 05       	cpc	r24, r1
     750:	91 05       	cpc	r25, r1
     752:	19 f4       	brne	.+6      	; 0x75a <__floatunsisf+0x20>
     754:	82 e0       	ldi	r24, 0x02	; 2
     756:	89 83       	std	Y+1, r24	; 0x01
     758:	60 c0       	rjmp	.+192    	; 0x81a <__floatunsisf+0xe0>
     75a:	83 e0       	ldi	r24, 0x03	; 3
     75c:	89 83       	std	Y+1, r24	; 0x01
     75e:	8e e1       	ldi	r24, 0x1E	; 30
     760:	c8 2e       	mov	r12, r24
     762:	d1 2c       	mov	r13, r1
     764:	dc 82       	std	Y+4, r13	; 0x04
     766:	cb 82       	std	Y+3, r12	; 0x03
     768:	ed 82       	std	Y+5, r14	; 0x05
     76a:	fe 82       	std	Y+6, r15	; 0x06
     76c:	0f 83       	std	Y+7, r16	; 0x07
     76e:	18 87       	std	Y+8, r17	; 0x08
     770:	c8 01       	movw	r24, r16
     772:	b7 01       	movw	r22, r14
     774:	0e 94 16 04 	call	0x82c	; 0x82c <__clzsi2>
     778:	fc 01       	movw	r30, r24
     77a:	31 97       	sbiw	r30, 0x01	; 1
     77c:	f7 ff       	sbrs	r31, 7
     77e:	3b c0       	rjmp	.+118    	; 0x7f6 <__floatunsisf+0xbc>
     780:	22 27       	eor	r18, r18
     782:	33 27       	eor	r19, r19
     784:	2e 1b       	sub	r18, r30
     786:	3f 0b       	sbc	r19, r31
     788:	57 01       	movw	r10, r14
     78a:	68 01       	movw	r12, r16
     78c:	02 2e       	mov	r0, r18
     78e:	04 c0       	rjmp	.+8      	; 0x798 <__floatunsisf+0x5e>
     790:	d6 94       	lsr	r13
     792:	c7 94       	ror	r12
     794:	b7 94       	ror	r11
     796:	a7 94       	ror	r10
     798:	0a 94       	dec	r0
     79a:	d2 f7       	brpl	.-12     	; 0x790 <__floatunsisf+0x56>
     79c:	40 e0       	ldi	r20, 0x00	; 0
     79e:	50 e0       	ldi	r21, 0x00	; 0
     7a0:	60 e0       	ldi	r22, 0x00	; 0
     7a2:	70 e0       	ldi	r23, 0x00	; 0
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	a0 e0       	ldi	r26, 0x00	; 0
     7aa:	b0 e0       	ldi	r27, 0x00	; 0
     7ac:	04 c0       	rjmp	.+8      	; 0x7b6 <__floatunsisf+0x7c>
     7ae:	88 0f       	add	r24, r24
     7b0:	99 1f       	adc	r25, r25
     7b2:	aa 1f       	adc	r26, r26
     7b4:	bb 1f       	adc	r27, r27
     7b6:	2a 95       	dec	r18
     7b8:	d2 f7       	brpl	.-12     	; 0x7ae <__floatunsisf+0x74>
     7ba:	01 97       	sbiw	r24, 0x01	; 1
     7bc:	a1 09       	sbc	r26, r1
     7be:	b1 09       	sbc	r27, r1
     7c0:	8e 21       	and	r24, r14
     7c2:	9f 21       	and	r25, r15
     7c4:	a0 23       	and	r26, r16
     7c6:	b1 23       	and	r27, r17
     7c8:	00 97       	sbiw	r24, 0x00	; 0
     7ca:	a1 05       	cpc	r26, r1
     7cc:	b1 05       	cpc	r27, r1
     7ce:	21 f0       	breq	.+8      	; 0x7d8 <__floatunsisf+0x9e>
     7d0:	41 e0       	ldi	r20, 0x01	; 1
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	70 e0       	ldi	r23, 0x00	; 0
     7d8:	4a 29       	or	r20, r10
     7da:	5b 29       	or	r21, r11
     7dc:	6c 29       	or	r22, r12
     7de:	7d 29       	or	r23, r13
     7e0:	4d 83       	std	Y+5, r20	; 0x05
     7e2:	5e 83       	std	Y+6, r21	; 0x06
     7e4:	6f 83       	std	Y+7, r22	; 0x07
     7e6:	78 87       	std	Y+8, r23	; 0x08
     7e8:	8e e1       	ldi	r24, 0x1E	; 30
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	8e 1b       	sub	r24, r30
     7ee:	9f 0b       	sbc	r25, r31
     7f0:	9c 83       	std	Y+4, r25	; 0x04
     7f2:	8b 83       	std	Y+3, r24	; 0x03
     7f4:	12 c0       	rjmp	.+36     	; 0x81a <__floatunsisf+0xe0>
     7f6:	30 97       	sbiw	r30, 0x00	; 0
     7f8:	81 f0       	breq	.+32     	; 0x81a <__floatunsisf+0xe0>
     7fa:	0e 2e       	mov	r0, r30
     7fc:	04 c0       	rjmp	.+8      	; 0x806 <__floatunsisf+0xcc>
     7fe:	ee 0c       	add	r14, r14
     800:	ff 1c       	adc	r15, r15
     802:	00 1f       	adc	r16, r16
     804:	11 1f       	adc	r17, r17
     806:	0a 94       	dec	r0
     808:	d2 f7       	brpl	.-12     	; 0x7fe <__floatunsisf+0xc4>
     80a:	ed 82       	std	Y+5, r14	; 0x05
     80c:	fe 82       	std	Y+6, r15	; 0x06
     80e:	0f 83       	std	Y+7, r16	; 0x07
     810:	18 87       	std	Y+8, r17	; 0x08
     812:	ce 1a       	sub	r12, r30
     814:	df 0a       	sbc	r13, r31
     816:	dc 82       	std	Y+4, r13	; 0x04
     818:	cb 82       	std	Y+3, r12	; 0x03
     81a:	1a 82       	std	Y+2, r1	; 0x02
     81c:	ce 01       	movw	r24, r28
     81e:	01 96       	adiw	r24, 0x01	; 1
     820:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     824:	28 96       	adiw	r28, 0x08	; 8
     826:	ea e0       	ldi	r30, 0x0A	; 10
     828:	0c 94 07 23 	jmp	0x460e	; 0x460e <__epilogue_restores__+0x10>

0000082c <__clzsi2>:
     82c:	ef 92       	push	r14
     82e:	ff 92       	push	r15
     830:	0f 93       	push	r16
     832:	1f 93       	push	r17
     834:	7b 01       	movw	r14, r22
     836:	8c 01       	movw	r16, r24
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	e8 16       	cp	r14, r24
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	f8 06       	cpc	r15, r24
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	08 07       	cpc	r16, r24
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	18 07       	cpc	r17, r24
     848:	88 f4       	brcc	.+34     	; 0x86c <__stack+0xd>
     84a:	8f ef       	ldi	r24, 0xFF	; 255
     84c:	e8 16       	cp	r14, r24
     84e:	f1 04       	cpc	r15, r1
     850:	01 05       	cpc	r16, r1
     852:	11 05       	cpc	r17, r1
     854:	31 f0       	breq	.+12     	; 0x862 <__stack+0x3>
     856:	28 f0       	brcs	.+10     	; 0x862 <__stack+0x3>
     858:	88 e0       	ldi	r24, 0x08	; 8
     85a:	90 e0       	ldi	r25, 0x00	; 0
     85c:	a0 e0       	ldi	r26, 0x00	; 0
     85e:	b0 e0       	ldi	r27, 0x00	; 0
     860:	17 c0       	rjmp	.+46     	; 0x890 <__stack+0x31>
     862:	80 e0       	ldi	r24, 0x00	; 0
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	a0 e0       	ldi	r26, 0x00	; 0
     868:	b0 e0       	ldi	r27, 0x00	; 0
     86a:	12 c0       	rjmp	.+36     	; 0x890 <__stack+0x31>
     86c:	80 e0       	ldi	r24, 0x00	; 0
     86e:	e8 16       	cp	r14, r24
     870:	80 e0       	ldi	r24, 0x00	; 0
     872:	f8 06       	cpc	r15, r24
     874:	80 e0       	ldi	r24, 0x00	; 0
     876:	08 07       	cpc	r16, r24
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	18 07       	cpc	r17, r24
     87c:	28 f0       	brcs	.+10     	; 0x888 <__stack+0x29>
     87e:	88 e1       	ldi	r24, 0x18	; 24
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	a0 e0       	ldi	r26, 0x00	; 0
     884:	b0 e0       	ldi	r27, 0x00	; 0
     886:	04 c0       	rjmp	.+8      	; 0x890 <__stack+0x31>
     888:	80 e1       	ldi	r24, 0x10	; 16
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	a0 e0       	ldi	r26, 0x00	; 0
     88e:	b0 e0       	ldi	r27, 0x00	; 0
     890:	20 e2       	ldi	r18, 0x20	; 32
     892:	30 e0       	ldi	r19, 0x00	; 0
     894:	40 e0       	ldi	r20, 0x00	; 0
     896:	50 e0       	ldi	r21, 0x00	; 0
     898:	28 1b       	sub	r18, r24
     89a:	39 0b       	sbc	r19, r25
     89c:	4a 0b       	sbc	r20, r26
     89e:	5b 0b       	sbc	r21, r27
     8a0:	04 c0       	rjmp	.+8      	; 0x8aa <__stack+0x4b>
     8a2:	16 95       	lsr	r17
     8a4:	07 95       	ror	r16
     8a6:	f7 94       	ror	r15
     8a8:	e7 94       	ror	r14
     8aa:	8a 95       	dec	r24
     8ac:	d2 f7       	brpl	.-12     	; 0x8a2 <__stack+0x43>
     8ae:	f7 01       	movw	r30, r14
     8b0:	eb 53       	subi	r30, 0x3B	; 59
     8b2:	ff 4f       	sbci	r31, 0xFF	; 255
     8b4:	80 81       	ld	r24, Z
     8b6:	28 1b       	sub	r18, r24
     8b8:	31 09       	sbc	r19, r1
     8ba:	41 09       	sbc	r20, r1
     8bc:	51 09       	sbc	r21, r1
     8be:	c9 01       	movw	r24, r18
     8c0:	1f 91       	pop	r17
     8c2:	0f 91       	pop	r16
     8c4:	ff 90       	pop	r15
     8c6:	ef 90       	pop	r14
     8c8:	08 95       	ret

000008ca <__pack_f>:
     8ca:	df 92       	push	r13
     8cc:	ef 92       	push	r14
     8ce:	ff 92       	push	r15
     8d0:	0f 93       	push	r16
     8d2:	1f 93       	push	r17
     8d4:	fc 01       	movw	r30, r24
     8d6:	e4 80       	ldd	r14, Z+4	; 0x04
     8d8:	f5 80       	ldd	r15, Z+5	; 0x05
     8da:	06 81       	ldd	r16, Z+6	; 0x06
     8dc:	17 81       	ldd	r17, Z+7	; 0x07
     8de:	d1 80       	ldd	r13, Z+1	; 0x01
     8e0:	80 81       	ld	r24, Z
     8e2:	82 30       	cpi	r24, 0x02	; 2
     8e4:	48 f4       	brcc	.+18     	; 0x8f8 <__pack_f+0x2e>
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	a0 e1       	ldi	r26, 0x10	; 16
     8ec:	b0 e0       	ldi	r27, 0x00	; 0
     8ee:	e8 2a       	or	r14, r24
     8f0:	f9 2a       	or	r15, r25
     8f2:	0a 2b       	or	r16, r26
     8f4:	1b 2b       	or	r17, r27
     8f6:	a5 c0       	rjmp	.+330    	; 0xa42 <__pack_f+0x178>
     8f8:	84 30       	cpi	r24, 0x04	; 4
     8fa:	09 f4       	brne	.+2      	; 0x8fe <__pack_f+0x34>
     8fc:	9f c0       	rjmp	.+318    	; 0xa3c <__pack_f+0x172>
     8fe:	82 30       	cpi	r24, 0x02	; 2
     900:	21 f4       	brne	.+8      	; 0x90a <__pack_f+0x40>
     902:	ee 24       	eor	r14, r14
     904:	ff 24       	eor	r15, r15
     906:	87 01       	movw	r16, r14
     908:	05 c0       	rjmp	.+10     	; 0x914 <__pack_f+0x4a>
     90a:	e1 14       	cp	r14, r1
     90c:	f1 04       	cpc	r15, r1
     90e:	01 05       	cpc	r16, r1
     910:	11 05       	cpc	r17, r1
     912:	19 f4       	brne	.+6      	; 0x91a <__pack_f+0x50>
     914:	e0 e0       	ldi	r30, 0x00	; 0
     916:	f0 e0       	ldi	r31, 0x00	; 0
     918:	96 c0       	rjmp	.+300    	; 0xa46 <__pack_f+0x17c>
     91a:	62 81       	ldd	r22, Z+2	; 0x02
     91c:	73 81       	ldd	r23, Z+3	; 0x03
     91e:	9f ef       	ldi	r25, 0xFF	; 255
     920:	62 38       	cpi	r22, 0x82	; 130
     922:	79 07       	cpc	r23, r25
     924:	0c f0       	brlt	.+2      	; 0x928 <__pack_f+0x5e>
     926:	5b c0       	rjmp	.+182    	; 0x9de <__pack_f+0x114>
     928:	22 e8       	ldi	r18, 0x82	; 130
     92a:	3f ef       	ldi	r19, 0xFF	; 255
     92c:	26 1b       	sub	r18, r22
     92e:	37 0b       	sbc	r19, r23
     930:	2a 31       	cpi	r18, 0x1A	; 26
     932:	31 05       	cpc	r19, r1
     934:	2c f0       	brlt	.+10     	; 0x940 <__pack_f+0x76>
     936:	20 e0       	ldi	r18, 0x00	; 0
     938:	30 e0       	ldi	r19, 0x00	; 0
     93a:	40 e0       	ldi	r20, 0x00	; 0
     93c:	50 e0       	ldi	r21, 0x00	; 0
     93e:	2a c0       	rjmp	.+84     	; 0x994 <__pack_f+0xca>
     940:	b8 01       	movw	r22, r16
     942:	a7 01       	movw	r20, r14
     944:	02 2e       	mov	r0, r18
     946:	04 c0       	rjmp	.+8      	; 0x950 <__pack_f+0x86>
     948:	76 95       	lsr	r23
     94a:	67 95       	ror	r22
     94c:	57 95       	ror	r21
     94e:	47 95       	ror	r20
     950:	0a 94       	dec	r0
     952:	d2 f7       	brpl	.-12     	; 0x948 <__pack_f+0x7e>
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	a0 e0       	ldi	r26, 0x00	; 0
     95a:	b0 e0       	ldi	r27, 0x00	; 0
     95c:	04 c0       	rjmp	.+8      	; 0x966 <__pack_f+0x9c>
     95e:	88 0f       	add	r24, r24
     960:	99 1f       	adc	r25, r25
     962:	aa 1f       	adc	r26, r26
     964:	bb 1f       	adc	r27, r27
     966:	2a 95       	dec	r18
     968:	d2 f7       	brpl	.-12     	; 0x95e <__pack_f+0x94>
     96a:	01 97       	sbiw	r24, 0x01	; 1
     96c:	a1 09       	sbc	r26, r1
     96e:	b1 09       	sbc	r27, r1
     970:	8e 21       	and	r24, r14
     972:	9f 21       	and	r25, r15
     974:	a0 23       	and	r26, r16
     976:	b1 23       	and	r27, r17
     978:	00 97       	sbiw	r24, 0x00	; 0
     97a:	a1 05       	cpc	r26, r1
     97c:	b1 05       	cpc	r27, r1
     97e:	21 f0       	breq	.+8      	; 0x988 <__pack_f+0xbe>
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	a0 e0       	ldi	r26, 0x00	; 0
     986:	b0 e0       	ldi	r27, 0x00	; 0
     988:	9a 01       	movw	r18, r20
     98a:	ab 01       	movw	r20, r22
     98c:	28 2b       	or	r18, r24
     98e:	39 2b       	or	r19, r25
     990:	4a 2b       	or	r20, r26
     992:	5b 2b       	or	r21, r27
     994:	da 01       	movw	r26, r20
     996:	c9 01       	movw	r24, r18
     998:	8f 77       	andi	r24, 0x7F	; 127
     99a:	90 70       	andi	r25, 0x00	; 0
     99c:	a0 70       	andi	r26, 0x00	; 0
     99e:	b0 70       	andi	r27, 0x00	; 0
     9a0:	80 34       	cpi	r24, 0x40	; 64
     9a2:	91 05       	cpc	r25, r1
     9a4:	a1 05       	cpc	r26, r1
     9a6:	b1 05       	cpc	r27, r1
     9a8:	39 f4       	brne	.+14     	; 0x9b8 <__pack_f+0xee>
     9aa:	27 ff       	sbrs	r18, 7
     9ac:	09 c0       	rjmp	.+18     	; 0x9c0 <__pack_f+0xf6>
     9ae:	20 5c       	subi	r18, 0xC0	; 192
     9b0:	3f 4f       	sbci	r19, 0xFF	; 255
     9b2:	4f 4f       	sbci	r20, 0xFF	; 255
     9b4:	5f 4f       	sbci	r21, 0xFF	; 255
     9b6:	04 c0       	rjmp	.+8      	; 0x9c0 <__pack_f+0xf6>
     9b8:	21 5c       	subi	r18, 0xC1	; 193
     9ba:	3f 4f       	sbci	r19, 0xFF	; 255
     9bc:	4f 4f       	sbci	r20, 0xFF	; 255
     9be:	5f 4f       	sbci	r21, 0xFF	; 255
     9c0:	e0 e0       	ldi	r30, 0x00	; 0
     9c2:	f0 e0       	ldi	r31, 0x00	; 0
     9c4:	20 30       	cpi	r18, 0x00	; 0
     9c6:	a0 e0       	ldi	r26, 0x00	; 0
     9c8:	3a 07       	cpc	r19, r26
     9ca:	a0 e0       	ldi	r26, 0x00	; 0
     9cc:	4a 07       	cpc	r20, r26
     9ce:	a0 e4       	ldi	r26, 0x40	; 64
     9d0:	5a 07       	cpc	r21, r26
     9d2:	10 f0       	brcs	.+4      	; 0x9d8 <__pack_f+0x10e>
     9d4:	e1 e0       	ldi	r30, 0x01	; 1
     9d6:	f0 e0       	ldi	r31, 0x00	; 0
     9d8:	79 01       	movw	r14, r18
     9da:	8a 01       	movw	r16, r20
     9dc:	27 c0       	rjmp	.+78     	; 0xa2c <__pack_f+0x162>
     9de:	60 38       	cpi	r22, 0x80	; 128
     9e0:	71 05       	cpc	r23, r1
     9e2:	64 f5       	brge	.+88     	; 0xa3c <__pack_f+0x172>
     9e4:	fb 01       	movw	r30, r22
     9e6:	e1 58       	subi	r30, 0x81	; 129
     9e8:	ff 4f       	sbci	r31, 0xFF	; 255
     9ea:	d8 01       	movw	r26, r16
     9ec:	c7 01       	movw	r24, r14
     9ee:	8f 77       	andi	r24, 0x7F	; 127
     9f0:	90 70       	andi	r25, 0x00	; 0
     9f2:	a0 70       	andi	r26, 0x00	; 0
     9f4:	b0 70       	andi	r27, 0x00	; 0
     9f6:	80 34       	cpi	r24, 0x40	; 64
     9f8:	91 05       	cpc	r25, r1
     9fa:	a1 05       	cpc	r26, r1
     9fc:	b1 05       	cpc	r27, r1
     9fe:	39 f4       	brne	.+14     	; 0xa0e <__pack_f+0x144>
     a00:	e7 fe       	sbrs	r14, 7
     a02:	0d c0       	rjmp	.+26     	; 0xa1e <__pack_f+0x154>
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	a0 e0       	ldi	r26, 0x00	; 0
     a0a:	b0 e0       	ldi	r27, 0x00	; 0
     a0c:	04 c0       	rjmp	.+8      	; 0xa16 <__pack_f+0x14c>
     a0e:	8f e3       	ldi	r24, 0x3F	; 63
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	a0 e0       	ldi	r26, 0x00	; 0
     a14:	b0 e0       	ldi	r27, 0x00	; 0
     a16:	e8 0e       	add	r14, r24
     a18:	f9 1e       	adc	r15, r25
     a1a:	0a 1f       	adc	r16, r26
     a1c:	1b 1f       	adc	r17, r27
     a1e:	17 ff       	sbrs	r17, 7
     a20:	05 c0       	rjmp	.+10     	; 0xa2c <__pack_f+0x162>
     a22:	16 95       	lsr	r17
     a24:	07 95       	ror	r16
     a26:	f7 94       	ror	r15
     a28:	e7 94       	ror	r14
     a2a:	31 96       	adiw	r30, 0x01	; 1
     a2c:	87 e0       	ldi	r24, 0x07	; 7
     a2e:	16 95       	lsr	r17
     a30:	07 95       	ror	r16
     a32:	f7 94       	ror	r15
     a34:	e7 94       	ror	r14
     a36:	8a 95       	dec	r24
     a38:	d1 f7       	brne	.-12     	; 0xa2e <__pack_f+0x164>
     a3a:	05 c0       	rjmp	.+10     	; 0xa46 <__pack_f+0x17c>
     a3c:	ee 24       	eor	r14, r14
     a3e:	ff 24       	eor	r15, r15
     a40:	87 01       	movw	r16, r14
     a42:	ef ef       	ldi	r30, 0xFF	; 255
     a44:	f0 e0       	ldi	r31, 0x00	; 0
     a46:	6e 2f       	mov	r22, r30
     a48:	67 95       	ror	r22
     a4a:	66 27       	eor	r22, r22
     a4c:	67 95       	ror	r22
     a4e:	90 2f       	mov	r25, r16
     a50:	9f 77       	andi	r25, 0x7F	; 127
     a52:	d7 94       	ror	r13
     a54:	dd 24       	eor	r13, r13
     a56:	d7 94       	ror	r13
     a58:	8e 2f       	mov	r24, r30
     a5a:	86 95       	lsr	r24
     a5c:	49 2f       	mov	r20, r25
     a5e:	46 2b       	or	r20, r22
     a60:	58 2f       	mov	r21, r24
     a62:	5d 29       	or	r21, r13
     a64:	b7 01       	movw	r22, r14
     a66:	ca 01       	movw	r24, r20
     a68:	1f 91       	pop	r17
     a6a:	0f 91       	pop	r16
     a6c:	ff 90       	pop	r15
     a6e:	ef 90       	pop	r14
     a70:	df 90       	pop	r13
     a72:	08 95       	ret

00000a74 <__unpack_f>:
     a74:	fc 01       	movw	r30, r24
     a76:	db 01       	movw	r26, r22
     a78:	40 81       	ld	r20, Z
     a7a:	51 81       	ldd	r21, Z+1	; 0x01
     a7c:	22 81       	ldd	r18, Z+2	; 0x02
     a7e:	62 2f       	mov	r22, r18
     a80:	6f 77       	andi	r22, 0x7F	; 127
     a82:	70 e0       	ldi	r23, 0x00	; 0
     a84:	22 1f       	adc	r18, r18
     a86:	22 27       	eor	r18, r18
     a88:	22 1f       	adc	r18, r18
     a8a:	93 81       	ldd	r25, Z+3	; 0x03
     a8c:	89 2f       	mov	r24, r25
     a8e:	88 0f       	add	r24, r24
     a90:	82 2b       	or	r24, r18
     a92:	28 2f       	mov	r18, r24
     a94:	30 e0       	ldi	r19, 0x00	; 0
     a96:	99 1f       	adc	r25, r25
     a98:	99 27       	eor	r25, r25
     a9a:	99 1f       	adc	r25, r25
     a9c:	11 96       	adiw	r26, 0x01	; 1
     a9e:	9c 93       	st	X, r25
     aa0:	11 97       	sbiw	r26, 0x01	; 1
     aa2:	21 15       	cp	r18, r1
     aa4:	31 05       	cpc	r19, r1
     aa6:	a9 f5       	brne	.+106    	; 0xb12 <__unpack_f+0x9e>
     aa8:	41 15       	cp	r20, r1
     aaa:	51 05       	cpc	r21, r1
     aac:	61 05       	cpc	r22, r1
     aae:	71 05       	cpc	r23, r1
     ab0:	11 f4       	brne	.+4      	; 0xab6 <__unpack_f+0x42>
     ab2:	82 e0       	ldi	r24, 0x02	; 2
     ab4:	37 c0       	rjmp	.+110    	; 0xb24 <__unpack_f+0xb0>
     ab6:	82 e8       	ldi	r24, 0x82	; 130
     ab8:	9f ef       	ldi	r25, 0xFF	; 255
     aba:	13 96       	adiw	r26, 0x03	; 3
     abc:	9c 93       	st	X, r25
     abe:	8e 93       	st	-X, r24
     ac0:	12 97       	sbiw	r26, 0x02	; 2
     ac2:	9a 01       	movw	r18, r20
     ac4:	ab 01       	movw	r20, r22
     ac6:	67 e0       	ldi	r22, 0x07	; 7
     ac8:	22 0f       	add	r18, r18
     aca:	33 1f       	adc	r19, r19
     acc:	44 1f       	adc	r20, r20
     ace:	55 1f       	adc	r21, r21
     ad0:	6a 95       	dec	r22
     ad2:	d1 f7       	brne	.-12     	; 0xac8 <__unpack_f+0x54>
     ad4:	83 e0       	ldi	r24, 0x03	; 3
     ad6:	8c 93       	st	X, r24
     ad8:	0d c0       	rjmp	.+26     	; 0xaf4 <__unpack_f+0x80>
     ada:	22 0f       	add	r18, r18
     adc:	33 1f       	adc	r19, r19
     ade:	44 1f       	adc	r20, r20
     ae0:	55 1f       	adc	r21, r21
     ae2:	12 96       	adiw	r26, 0x02	; 2
     ae4:	8d 91       	ld	r24, X+
     ae6:	9c 91       	ld	r25, X
     ae8:	13 97       	sbiw	r26, 0x03	; 3
     aea:	01 97       	sbiw	r24, 0x01	; 1
     aec:	13 96       	adiw	r26, 0x03	; 3
     aee:	9c 93       	st	X, r25
     af0:	8e 93       	st	-X, r24
     af2:	12 97       	sbiw	r26, 0x02	; 2
     af4:	20 30       	cpi	r18, 0x00	; 0
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	38 07       	cpc	r19, r24
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	48 07       	cpc	r20, r24
     afe:	80 e4       	ldi	r24, 0x40	; 64
     b00:	58 07       	cpc	r21, r24
     b02:	58 f3       	brcs	.-42     	; 0xada <__unpack_f+0x66>
     b04:	14 96       	adiw	r26, 0x04	; 4
     b06:	2d 93       	st	X+, r18
     b08:	3d 93       	st	X+, r19
     b0a:	4d 93       	st	X+, r20
     b0c:	5c 93       	st	X, r21
     b0e:	17 97       	sbiw	r26, 0x07	; 7
     b10:	08 95       	ret
     b12:	2f 3f       	cpi	r18, 0xFF	; 255
     b14:	31 05       	cpc	r19, r1
     b16:	79 f4       	brne	.+30     	; 0xb36 <__unpack_f+0xc2>
     b18:	41 15       	cp	r20, r1
     b1a:	51 05       	cpc	r21, r1
     b1c:	61 05       	cpc	r22, r1
     b1e:	71 05       	cpc	r23, r1
     b20:	19 f4       	brne	.+6      	; 0xb28 <__unpack_f+0xb4>
     b22:	84 e0       	ldi	r24, 0x04	; 4
     b24:	8c 93       	st	X, r24
     b26:	08 95       	ret
     b28:	64 ff       	sbrs	r22, 4
     b2a:	03 c0       	rjmp	.+6      	; 0xb32 <__unpack_f+0xbe>
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	8c 93       	st	X, r24
     b30:	12 c0       	rjmp	.+36     	; 0xb56 <__unpack_f+0xe2>
     b32:	1c 92       	st	X, r1
     b34:	10 c0       	rjmp	.+32     	; 0xb56 <__unpack_f+0xe2>
     b36:	2f 57       	subi	r18, 0x7F	; 127
     b38:	30 40       	sbci	r19, 0x00	; 0
     b3a:	13 96       	adiw	r26, 0x03	; 3
     b3c:	3c 93       	st	X, r19
     b3e:	2e 93       	st	-X, r18
     b40:	12 97       	sbiw	r26, 0x02	; 2
     b42:	83 e0       	ldi	r24, 0x03	; 3
     b44:	8c 93       	st	X, r24
     b46:	87 e0       	ldi	r24, 0x07	; 7
     b48:	44 0f       	add	r20, r20
     b4a:	55 1f       	adc	r21, r21
     b4c:	66 1f       	adc	r22, r22
     b4e:	77 1f       	adc	r23, r23
     b50:	8a 95       	dec	r24
     b52:	d1 f7       	brne	.-12     	; 0xb48 <__unpack_f+0xd4>
     b54:	70 64       	ori	r23, 0x40	; 64
     b56:	14 96       	adiw	r26, 0x04	; 4
     b58:	4d 93       	st	X+, r20
     b5a:	5d 93       	st	X+, r21
     b5c:	6d 93       	st	X+, r22
     b5e:	7c 93       	st	X, r23
     b60:	17 97       	sbiw	r26, 0x07	; 7
     b62:	08 95       	ret

00000b64 <__fpcmp_parts_f>:
     b64:	1f 93       	push	r17
     b66:	dc 01       	movw	r26, r24
     b68:	fb 01       	movw	r30, r22
     b6a:	9c 91       	ld	r25, X
     b6c:	92 30       	cpi	r25, 0x02	; 2
     b6e:	08 f4       	brcc	.+2      	; 0xb72 <__fpcmp_parts_f+0xe>
     b70:	47 c0       	rjmp	.+142    	; 0xc00 <__fpcmp_parts_f+0x9c>
     b72:	80 81       	ld	r24, Z
     b74:	82 30       	cpi	r24, 0x02	; 2
     b76:	08 f4       	brcc	.+2      	; 0xb7a <__fpcmp_parts_f+0x16>
     b78:	43 c0       	rjmp	.+134    	; 0xc00 <__fpcmp_parts_f+0x9c>
     b7a:	94 30       	cpi	r25, 0x04	; 4
     b7c:	51 f4       	brne	.+20     	; 0xb92 <__fpcmp_parts_f+0x2e>
     b7e:	11 96       	adiw	r26, 0x01	; 1
     b80:	1c 91       	ld	r17, X
     b82:	84 30       	cpi	r24, 0x04	; 4
     b84:	99 f5       	brne	.+102    	; 0xbec <__fpcmp_parts_f+0x88>
     b86:	81 81       	ldd	r24, Z+1	; 0x01
     b88:	68 2f       	mov	r22, r24
     b8a:	70 e0       	ldi	r23, 0x00	; 0
     b8c:	61 1b       	sub	r22, r17
     b8e:	71 09       	sbc	r23, r1
     b90:	3f c0       	rjmp	.+126    	; 0xc10 <__fpcmp_parts_f+0xac>
     b92:	84 30       	cpi	r24, 0x04	; 4
     b94:	21 f0       	breq	.+8      	; 0xb9e <__fpcmp_parts_f+0x3a>
     b96:	92 30       	cpi	r25, 0x02	; 2
     b98:	31 f4       	brne	.+12     	; 0xba6 <__fpcmp_parts_f+0x42>
     b9a:	82 30       	cpi	r24, 0x02	; 2
     b9c:	b9 f1       	breq	.+110    	; 0xc0c <__fpcmp_parts_f+0xa8>
     b9e:	81 81       	ldd	r24, Z+1	; 0x01
     ba0:	88 23       	and	r24, r24
     ba2:	89 f1       	breq	.+98     	; 0xc06 <__fpcmp_parts_f+0xa2>
     ba4:	2d c0       	rjmp	.+90     	; 0xc00 <__fpcmp_parts_f+0x9c>
     ba6:	11 96       	adiw	r26, 0x01	; 1
     ba8:	1c 91       	ld	r17, X
     baa:	11 97       	sbiw	r26, 0x01	; 1
     bac:	82 30       	cpi	r24, 0x02	; 2
     bae:	f1 f0       	breq	.+60     	; 0xbec <__fpcmp_parts_f+0x88>
     bb0:	81 81       	ldd	r24, Z+1	; 0x01
     bb2:	18 17       	cp	r17, r24
     bb4:	d9 f4       	brne	.+54     	; 0xbec <__fpcmp_parts_f+0x88>
     bb6:	12 96       	adiw	r26, 0x02	; 2
     bb8:	2d 91       	ld	r18, X+
     bba:	3c 91       	ld	r19, X
     bbc:	13 97       	sbiw	r26, 0x03	; 3
     bbe:	82 81       	ldd	r24, Z+2	; 0x02
     bc0:	93 81       	ldd	r25, Z+3	; 0x03
     bc2:	82 17       	cp	r24, r18
     bc4:	93 07       	cpc	r25, r19
     bc6:	94 f0       	brlt	.+36     	; 0xbec <__fpcmp_parts_f+0x88>
     bc8:	28 17       	cp	r18, r24
     bca:	39 07       	cpc	r19, r25
     bcc:	bc f0       	brlt	.+46     	; 0xbfc <__fpcmp_parts_f+0x98>
     bce:	14 96       	adiw	r26, 0x04	; 4
     bd0:	8d 91       	ld	r24, X+
     bd2:	9d 91       	ld	r25, X+
     bd4:	0d 90       	ld	r0, X+
     bd6:	bc 91       	ld	r27, X
     bd8:	a0 2d       	mov	r26, r0
     bda:	24 81       	ldd	r18, Z+4	; 0x04
     bdc:	35 81       	ldd	r19, Z+5	; 0x05
     bde:	46 81       	ldd	r20, Z+6	; 0x06
     be0:	57 81       	ldd	r21, Z+7	; 0x07
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	4a 07       	cpc	r20, r26
     be8:	5b 07       	cpc	r21, r27
     bea:	18 f4       	brcc	.+6      	; 0xbf2 <__fpcmp_parts_f+0x8e>
     bec:	11 23       	and	r17, r17
     bee:	41 f0       	breq	.+16     	; 0xc00 <__fpcmp_parts_f+0x9c>
     bf0:	0a c0       	rjmp	.+20     	; 0xc06 <__fpcmp_parts_f+0xa2>
     bf2:	82 17       	cp	r24, r18
     bf4:	93 07       	cpc	r25, r19
     bf6:	a4 07       	cpc	r26, r20
     bf8:	b5 07       	cpc	r27, r21
     bfa:	40 f4       	brcc	.+16     	; 0xc0c <__fpcmp_parts_f+0xa8>
     bfc:	11 23       	and	r17, r17
     bfe:	19 f0       	breq	.+6      	; 0xc06 <__fpcmp_parts_f+0xa2>
     c00:	61 e0       	ldi	r22, 0x01	; 1
     c02:	70 e0       	ldi	r23, 0x00	; 0
     c04:	05 c0       	rjmp	.+10     	; 0xc10 <__fpcmp_parts_f+0xac>
     c06:	6f ef       	ldi	r22, 0xFF	; 255
     c08:	7f ef       	ldi	r23, 0xFF	; 255
     c0a:	02 c0       	rjmp	.+4      	; 0xc10 <__fpcmp_parts_f+0xac>
     c0c:	60 e0       	ldi	r22, 0x00	; 0
     c0e:	70 e0       	ldi	r23, 0x00	; 0
     c10:	cb 01       	movw	r24, r22
     c12:	1f 91       	pop	r17
     c14:	08 95       	ret

00000c16 <SelectChannel>:
Gpt_ChannelType Channel;

Gpt_ValueType  SelectChannel(Gpt_ChannelType Channel)
{
	Gpt_ValueType Value=0;
	if(Channel==Timer0_)
     c16:	88 23       	and	r24, r24
     c18:	11 f4       	brne	.+4      	; 0xc1e <SelectChannel+0x8>
	{
		Value=TCNT0_REG;
     c1a:	82 b7       	in	r24, 0x32	; 50
     c1c:	0e c0       	rjmp	.+28     	; 0xc3a <SelectChannel+0x24>
	}
	if(Channel==Timer1_)
     c1e:	81 30       	cpi	r24, 0x01	; 1
     c20:	21 f4       	brne	.+8      	; 0xc2a <SelectChannel+0x14>
	{
		Value=TCNT1_REG;
     c22:	8c b5       	in	r24, 0x2c	; 44
     c24:	9d b5       	in	r25, 0x2d	; 45
     c26:	9c 01       	movw	r18, r24
     c28:	0a c0       	rjmp	.+20     	; 0xc3e <SelectChannel+0x28>

	}
	if(Channel==Timer2_)
     c2a:	82 30       	cpi	r24, 0x02	; 2
     c2c:	29 f0       	breq	.+10     	; 0xc38 <SelectChannel+0x22>
     c2e:	20 e0       	ldi	r18, 0x00	; 0
     c30:	30 e0       	ldi	r19, 0x00	; 0
     c32:	40 e0       	ldi	r20, 0x00	; 0
     c34:	50 e0       	ldi	r21, 0x00	; 0
     c36:	05 c0       	rjmp	.+10     	; 0xc42 <SelectChannel+0x2c>
	{
		Value=TCNT2_REG;
     c38:	84 b5       	in	r24, 0x24	; 36
     c3a:	28 2f       	mov	r18, r24
     c3c:	30 e0       	ldi	r19, 0x00	; 0
     c3e:	40 e0       	ldi	r20, 0x00	; 0
     c40:	50 e0       	ldi	r21, 0x00	; 0
	}
	return Value;

}
     c42:	b9 01       	movw	r22, r18
     c44:	ca 01       	movw	r24, r20
     c46:	08 95       	ret

00000c48 <Gpt_DeInit>:

#if(GptDeInitApi==E_OK)
void Gpt_DeInit(void)
{

}
     c48:	08 95       	ret

00000c4a <Gpt_EnableWakeup>:
#endif

void Gpt_EnableWakeup(Gpt_ChannelType Channel)
{

}
     c4a:	08 95       	ret

00000c4c <Gpt_DisableNotification>:
#endif

#if (GptEnableDisableNotificationApi==E_OK)
void  Gpt_DisableNotification(Gpt_ChannelType Channel)
{
	Mode=GPT_MODE_NORMAL;
     c4c:	10 92 3a 08 	sts	0x083A, r1
	if(GenratationMode==Normal)
     c50:	90 91 43 08 	lds	r25, 0x0843
     c54:	99 23       	and	r25, r25
     c56:	01 f5       	brne	.+64     	; 0xc98 <Gpt_DisableNotification+0x4c>
	{
		if(Channel==Timer0_)
     c58:	88 23       	and	r24, r24
     c5a:	29 f4       	brne	.+10     	; 0xc66 <Gpt_DisableNotification+0x1a>
		{
			InterruptEnableNormal0();
     c5c:	0e 94 07 0b 	call	0x160e	; 0x160e <InterruptEnableNormal0>
			if(!READ_BIT(TIFR_REG,OCF0))
     c60:	88 b7       	in	r24, 0x38	; 56
     c62:	86 95       	lsr	r24
     c64:	34 c0       	rjmp	.+104    	; 0xcce <Gpt_DisableNotification+0x82>
			{
				FlagEnableInterrupt=0;
			}
		}

		if(Channel==Timer1_)
     c66:	81 30       	cpi	r24, 0x01	; 1
     c68:	61 f4       	brne	.+24     	; 0xc82 <Gpt_DisableNotification+0x36>
		{
			InterruptEnableNormal1();
     c6a:	0e 94 17 0b 	call	0x162e	; 0x162e <InterruptEnableNormal1>
			if(!READ_BIT(TIFR_REG,OCF1A)&&!READ_BIT(TIFR_REG,OCF1B))
     c6e:	88 b7       	in	r24, 0x38	; 56
     c70:	82 95       	swap	r24
     c72:	8f 70       	andi	r24, 0x0F	; 15
     c74:	80 fd       	sbrc	r24, 0
     c76:	39 c0       	rjmp	.+114    	; 0xcea <Gpt_DisableNotification+0x9e>
     c78:	88 b7       	in	r24, 0x38	; 56
     c7a:	86 95       	lsr	r24
     c7c:	86 95       	lsr	r24
     c7e:	86 95       	lsr	r24
     c80:	26 c0       	rjmp	.+76     	; 0xcce <Gpt_DisableNotification+0x82>
			{
				FlagEnableInterrupt=0;
			}

		}
		if(Channel==Timer2_)
     c82:	82 30       	cpi	r24, 0x02	; 2
     c84:	49 f5       	brne	.+82     	; 0xcd8 <Gpt_DisableNotification+0x8c>
		{
			InterruptEnableNormal2();
     c86:	0e 94 2d 0b 	call	0x165a	; 0x165a <InterruptEnableNormal2>
			if(!READ_BIT(TIFR_REG,OCF2))
     c8a:	08 b6       	in	r0, 0x38	; 56
     c8c:	07 fc       	sbrc	r0, 7
     c8e:	2d c0       	rjmp	.+90     	; 0xcea <Gpt_DisableNotification+0x9e>
			{
				FlagEnableInterrupt=1;
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	80 93 46 02 	sts	0x0246, r24
     c96:	29 c0       	rjmp	.+82     	; 0xcea <Gpt_DisableNotification+0x9e>
			}
		}
	}

	else if(GenratationMode==CTC)
     c98:	91 30       	cpi	r25, 0x01	; 1
     c9a:	f1 f4       	brne	.+60     	; 0xcd8 <Gpt_DisableNotification+0x8c>
	{
		if(Channel==Timer0_)
     c9c:	88 23       	and	r24, r24
     c9e:	31 f4       	brne	.+12     	; 0xcac <Gpt_DisableNotification+0x60>
		{
			InterruptEnableCTC0();
     ca0:	0e 94 0f 0b 	call	0x161e	; 0x161e <InterruptEnableCTC0>
			if(!READ_BIT(TIFR_REG,TOV0))
     ca4:	08 b6       	in	r0, 0x38	; 56
     ca6:	00 fc       	sbrc	r0, 0
     ca8:	20 c0       	rjmp	.+64     	; 0xcea <Gpt_DisableNotification+0x9e>
     caa:	13 c0       	rjmp	.+38     	; 0xcd2 <Gpt_DisableNotification+0x86>
			{
				FlagEnableInterrupt=0;
			}
		}

		if(Channel==Timer1_)
     cac:	81 30       	cpi	r24, 0x01	; 1
     cae:	31 f4       	brne	.+12     	; 0xcbc <Gpt_DisableNotification+0x70>
		{
			InterruptEnableCTC1();
     cb0:	0e 94 1f 0b 	call	0x163e	; 0x163e <InterruptEnableCTC1>
			if(!READ_BIT(TIFR_REG,TOV1))
     cb4:	88 b7       	in	r24, 0x38	; 56
     cb6:	86 95       	lsr	r24
     cb8:	86 95       	lsr	r24
     cba:	09 c0       	rjmp	.+18     	; 0xcce <Gpt_DisableNotification+0x82>
			{
				FlagEnableInterrupt=0;
			}
		}
		if(Channel==Timer2_)
     cbc:	82 30       	cpi	r24, 0x02	; 2
     cbe:	61 f4       	brne	.+24     	; 0xcd8 <Gpt_DisableNotification+0x8c>
		{
			InterruptEnableCTC2();
     cc0:	0e 94 35 0b 	call	0x166a	; 0x166a <InterruptEnableCTC2>
			if(!READ_BIT(TIFR_REG,TOV2))
     cc4:	88 b7       	in	r24, 0x38	; 56
     cc6:	82 95       	swap	r24
     cc8:	86 95       	lsr	r24
     cca:	86 95       	lsr	r24
     ccc:	83 70       	andi	r24, 0x03	; 3
     cce:	80 fd       	sbrc	r24, 0
     cd0:	0c c0       	rjmp	.+24     	; 0xcea <Gpt_DisableNotification+0x9e>
			{
				FlagEnableInterrupt=0;
     cd2:	10 92 46 02 	sts	0x0246, r1
     cd6:	09 c0       	rjmp	.+18     	; 0xcea <Gpt_DisableNotification+0x9e>
			}
		}
	}
#if (GptDevErrorDetect==E_OK)
	if(Channel>Timer2_ )
     cd8:	83 30       	cpi	r24, 0x03	; 3
     cda:	38 f0       	brcs	.+14     	; 0xcea <Gpt_DisableNotification+0x9e>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_DisableNotification_API,GPT_E_PARAM_CHANNEL);
     cdc:	84 e6       	ldi	r24, 0x64	; 100
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	60 e0       	ldi	r22, 0x00	; 0
     ce2:	48 e0       	ldi	r20, 0x08	; 8
     ce4:	24 e1       	ldi	r18, 0x14	; 20
     ce6:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Uninitialized )
     cea:	80 91 44 08 	lds	r24, 0x0844
     cee:	88 23       	and	r24, r24
     cf0:	39 f4       	brne	.+14     	; 0xd00 <Gpt_DisableNotification+0xb4>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_DisableNotification_API,GPT_E_UNINIT);
     cf2:	84 e6       	ldi	r24, 0x64	; 100
     cf4:	90 e0       	ldi	r25, 0x00	; 0
     cf6:	60 e0       	ldi	r22, 0x00	; 0
     cf8:	48 e0       	ldi	r20, 0x08	; 8
     cfa:	2a e0       	ldi	r18, 0x0A	; 10
     cfc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
     d00:	08 95       	ret

00000d02 <Gpt_EnableNotification>:
#endif
}

#if (GptEnableDisableNotificationApi==E_OK)
void Gpt_EnableNotification(Gpt_ChannelType Channel)
{
     d02:	0f 93       	push	r16
     d04:	1f 93       	push	r17
     d06:	18 2f       	mov	r17, r24
	Mode=GPT_MODE_NORMAL;
     d08:	10 92 3a 08 	sts	0x083A, r1
	if(GenratationMode==Normal)
     d0c:	00 91 43 08 	lds	r16, 0x0843
     d10:	00 23       	and	r16, r16
     d12:	11 f5       	brne	.+68     	; 0xd58 <Gpt_EnableNotification+0x56>
	{
		if(Channel==Timer0_)
     d14:	88 23       	and	r24, r24
     d16:	39 f4       	brne	.+14     	; 0xd26 <Gpt_EnableNotification+0x24>
		{
			InterruptEnableNormal0();
     d18:	0e 94 07 0b 	call	0x160e	; 0x160e <InterruptEnableNormal0>
			if(!READ_BIT(TIFR_REG,OCF0))
     d1c:	88 b7       	in	r24, 0x38	; 56
     d1e:	86 95       	lsr	r24
     d20:	80 fd       	sbrc	r24, 0
     d22:	3e c0       	rjmp	.+124    	; 0xda0 <Gpt_EnableNotification+0x9e>
     d24:	15 c0       	rjmp	.+42     	; 0xd50 <Gpt_EnableNotification+0x4e>
			{
				FlagEnableInterrupt=0;
			}
		}

		if(Channel==Timer1_)
     d26:	81 30       	cpi	r24, 0x01	; 1
     d28:	61 f4       	brne	.+24     	; 0xd42 <Gpt_EnableNotification+0x40>
		{
			InterruptEnableNormal1();
     d2a:	0e 94 17 0b 	call	0x162e	; 0x162e <InterruptEnableNormal1>
			if(!READ_BIT(TIFR_REG,OCF1A)&&!READ_BIT(TIFR_REG,OCF1B))
     d2e:	88 b7       	in	r24, 0x38	; 56
     d30:	82 95       	swap	r24
     d32:	8f 70       	andi	r24, 0x0F	; 15
     d34:	80 fd       	sbrc	r24, 0
     d36:	34 c0       	rjmp	.+104    	; 0xda0 <Gpt_EnableNotification+0x9e>
     d38:	88 b7       	in	r24, 0x38	; 56
     d3a:	86 95       	lsr	r24
     d3c:	86 95       	lsr	r24
     d3e:	86 95       	lsr	r24
     d40:	1c c0       	rjmp	.+56     	; 0xd7a <Gpt_EnableNotification+0x78>
			else
			{
				FlagEnableInterrupt=0;
			}
		}
		if(Channel==Timer2_)
     d42:	82 30       	cpi	r24, 0x02	; 2
     d44:	81 f5       	brne	.+96     	; 0xda6 <Gpt_EnableNotification+0xa4>
		{
			InterruptEnableNormal2();
     d46:	0e 94 2d 0b 	call	0x165a	; 0x165a <InterruptEnableNormal2>
			if(!READ_BIT(TIFR_REG,OCF2))
     d4a:	08 b6       	in	r0, 0x38	; 56
     d4c:	07 fc       	sbrc	r0, 7
     d4e:	28 c0       	rjmp	.+80     	; 0xda0 <Gpt_EnableNotification+0x9e>
			{
				FlagEnableInterrupt=1;
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	80 93 46 02 	sts	0x0246, r24
     d56:	30 c0       	rjmp	.+96     	; 0xdb8 <Gpt_EnableNotification+0xb6>
				FlagEnableInterrupt=0;
			}
		}
	}

	else if(GenratationMode==CTC)
     d58:	01 30       	cpi	r16, 0x01	; 1
     d5a:	29 f5       	brne	.+74     	; 0xda6 <Gpt_EnableNotification+0xa4>
	{
		if(Channel==Timer0_)
     d5c:	88 23       	and	r24, r24
     d5e:	31 f4       	brne	.+12     	; 0xd6c <Gpt_EnableNotification+0x6a>
		{
			InterruptEnableCTC0();
     d60:	0e 94 0f 0b 	call	0x161e	; 0x161e <InterruptEnableCTC0>
			if(!READ_BIT(TIFR_REG,TOV0))
     d64:	08 b6       	in	r0, 0x38	; 56
     d66:	00 fc       	sbrc	r0, 0
     d68:	1b c0       	rjmp	.+54     	; 0xda0 <Gpt_EnableNotification+0x9e>
     d6a:	17 c0       	rjmp	.+46     	; 0xd9a <Gpt_EnableNotification+0x98>
			{
				FlagEnableInterrupt=0;
			}
		}

		if(Channel==Timer1_)
     d6c:	81 30       	cpi	r24, 0x01	; 1
     d6e:	51 f4       	brne	.+20     	; 0xd84 <Gpt_EnableNotification+0x82>
		{
			InterruptEnableCTC1();
     d70:	0e 94 1f 0b 	call	0x163e	; 0x163e <InterruptEnableCTC1>
			if(!READ_BIT(TIFR_REG,TOV1))
     d74:	88 b7       	in	r24, 0x38	; 56
     d76:	86 95       	lsr	r24
     d78:	86 95       	lsr	r24
     d7a:	80 fd       	sbrc	r24, 0
     d7c:	11 c0       	rjmp	.+34     	; 0xda0 <Gpt_EnableNotification+0x9e>
			{
				FlagEnableInterrupt=1;
     d7e:	10 93 46 02 	sts	0x0246, r17
     d82:	1a c0       	rjmp	.+52     	; 0xdb8 <Gpt_EnableNotification+0xb6>
			else
			{
				FlagEnableInterrupt=0;
			}
		}
		if(Channel==Timer2_)
     d84:	82 30       	cpi	r24, 0x02	; 2
     d86:	79 f4       	brne	.+30     	; 0xda6 <Gpt_EnableNotification+0xa4>
		{
			InterruptEnableCTC2();
     d88:	0e 94 35 0b 	call	0x166a	; 0x166a <InterruptEnableCTC2>
			if(!READ_BIT(TIFR_REG,TOV2))
     d8c:	88 b7       	in	r24, 0x38	; 56
     d8e:	82 95       	swap	r24
     d90:	86 95       	lsr	r24
     d92:	86 95       	lsr	r24
     d94:	83 70       	andi	r24, 0x03	; 3
     d96:	80 fd       	sbrc	r24, 0
     d98:	03 c0       	rjmp	.+6      	; 0xda0 <Gpt_EnableNotification+0x9e>
			{
				FlagEnableInterrupt=1;
     d9a:	00 93 46 02 	sts	0x0246, r16
     d9e:	0c c0       	rjmp	.+24     	; 0xdb8 <Gpt_EnableNotification+0xb6>
			}
			else
			{
				FlagEnableInterrupt=0;
     da0:	10 92 46 02 	sts	0x0246, r1
     da4:	09 c0       	rjmp	.+18     	; 0xdb8 <Gpt_EnableNotification+0xb6>
			}
		}
	}
#if (GptDevErrorDetect==E_OK)
	if(Channel>Timer2_ )
     da6:	13 30       	cpi	r17, 0x03	; 3
     da8:	38 f0       	brcs	.+14     	; 0xdb8 <Gpt_EnableNotification+0xb6>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_EnableNotification_API,GPT_E_PARAM_CHANNEL);
     daa:	84 e6       	ldi	r24, 0x64	; 100
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	60 e0       	ldi	r22, 0x00	; 0
     db0:	47 e0       	ldi	r20, 0x07	; 7
     db2:	24 e1       	ldi	r18, 0x14	; 20
     db4:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Uninitialized )
     db8:	80 91 44 08 	lds	r24, 0x0844
     dbc:	88 23       	and	r24, r24
     dbe:	39 f4       	brne	.+14     	; 0xdce <Gpt_EnableNotification+0xcc>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_EnableNotification_API,GPT_E_UNINIT);
     dc0:	84 e6       	ldi	r24, 0x64	; 100
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	60 e0       	ldi	r22, 0x00	; 0
     dc6:	47 e0       	ldi	r20, 0x07	; 7
     dc8:	2a e0       	ldi	r18, 0x0A	; 10
     dca:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
#endif
}
     dce:	1f 91       	pop	r17
     dd0:	0f 91       	pop	r16
     dd2:	08 95       	ret

00000dd4 <Gpt_SetMode>:

}
#if(GptReportWakeupSource==E_OK)
void Gpt_SetMode(Gpt_ModeType Mode)
{
	if(Mode==GPT_MODE_NORMAL)
     dd4:	88 23       	and	r24, r24
     dd6:	21 f4       	brne	.+8      	; 0xde0 <Gpt_SetMode+0xc>
	{
		Gpt_EnableNotification(Channel);
     dd8:	80 91 39 08 	lds	r24, 0x0839
     ddc:	0e 94 81 06 	call	0xd02	; 0xd02 <Gpt_EnableNotification>
     de0:	08 95       	ret

00000de2 <Gpt_StopTimer>:
	return Value;
}
#endif

void Gpt_StopTimer(Gpt_ChannelType Channel)
{
     de2:	98 2f       	mov	r25, r24
	Gpt_ValueType Value;
	if(Mode==GPT_CH_MODE_ONESHOT)
     de4:	80 91 3a 08 	lds	r24, 0x083A
     de8:	81 30       	cpi	r24, 0x01	; 1
     dea:	a9 f4       	brne	.+42     	; 0xe16 <Gpt_StopTimer+0x34>
Gpt_ChannelType Channel;

Gpt_ValueType  SelectChannel(Gpt_ChannelType Channel)
{
	Gpt_ValueType Value=0;
	if(Channel==Timer0_)
     dec:	99 23       	and	r25, r25
     dee:	11 f4       	brne	.+4      	; 0xdf4 <Gpt_StopTimer+0x12>
	{
		Value=TCNT0_REG;
     df0:	82 b7       	in	r24, 0x32	; 50
     df2:	08 c0       	rjmp	.+16     	; 0xe04 <Gpt_StopTimer+0x22>
	}
	if(Channel==Timer1_)
     df4:	91 30       	cpi	r25, 0x01	; 1
     df6:	19 f4       	brne	.+6      	; 0xdfe <Gpt_StopTimer+0x1c>
	{
		Value=TCNT1_REG;
     df8:	2c b5       	in	r18, 0x2c	; 44
     dfa:	3d b5       	in	r19, 0x2d	; 45
     dfc:	03 c0       	rjmp	.+6      	; 0xe04 <Gpt_StopTimer+0x22>

	}
	if(Channel==Timer2_)
     dfe:	92 30       	cpi	r25, 0x02	; 2
     e00:	09 f4       	brne	.+2      	; 0xe04 <Gpt_StopTimer+0x22>
	{
		Value=TCNT2_REG;
     e02:	84 b5       	in	r24, 0x24	; 36
	Gpt_ValueType Value;
	if(Mode==GPT_CH_MODE_ONESHOT)
	{

		Value=SelectChannel(Channel);
		prescaler=No_clock_source;
     e04:	10 92 32 02 	sts	0x0232, r1
     e08:	10 92 33 02 	sts	0x0233, r1
     e0c:	10 92 34 02 	sts	0x0234, r1
     e10:	10 92 35 02 	sts	0x0235, r1
     e14:	0d c0       	rjmp	.+26     	; 0xe30 <Gpt_StopTimer+0x4e>
Gpt_ChannelType Channel;

Gpt_ValueType  SelectChannel(Gpt_ChannelType Channel)
{
	Gpt_ValueType Value=0;
	if(Channel==Timer0_)
     e16:	99 23       	and	r25, r25
     e18:	11 f4       	brne	.+4      	; 0xe1e <Gpt_StopTimer+0x3c>
	{
		Value=TCNT0_REG;
     e1a:	82 b7       	in	r24, 0x32	; 50
     e1c:	12 c0       	rjmp	.+36     	; 0xe42 <Gpt_StopTimer+0x60>
	}
	if(Channel==Timer1_)
     e1e:	91 30       	cpi	r25, 0x01	; 1
     e20:	19 f4       	brne	.+6      	; 0xe28 <Gpt_StopTimer+0x46>
	{
		Value=TCNT1_REG;
     e22:	8c b5       	in	r24, 0x2c	; 44
     e24:	9d b5       	in	r25, 0x2d	; 45
     e26:	0d c0       	rjmp	.+26     	; 0xe42 <Gpt_StopTimer+0x60>

	}
	if(Channel==Timer2_)
     e28:	92 30       	cpi	r25, 0x02	; 2
     e2a:	11 f4       	brne	.+4      	; 0xe30 <Gpt_StopTimer+0x4e>
	{
		Value=TCNT2_REG;
     e2c:	84 b5       	in	r24, 0x24	; 36
     e2e:	09 c0       	rjmp	.+18     	; 0xe42 <Gpt_StopTimer+0x60>
	{
		Value=SelectChannel(Channel);
		Value=Total_Time*counter;
	}
#if (GptDevErrorDetect==E_OK)
	if(Channel>Timer2_ )
     e30:	93 30       	cpi	r25, 0x03	; 3
     e32:	38 f0       	brcs	.+14     	; 0xe42 <Gpt_StopTimer+0x60>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_StopTimer_API,GPT_E_PARAM_CHANNEL);
     e34:	84 e6       	ldi	r24, 0x64	; 100
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	60 e0       	ldi	r22, 0x00	; 0
     e3a:	46 e0       	ldi	r20, 0x06	; 6
     e3c:	24 e1       	ldi	r18, 0x14	; 20
     e3e:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Uninitialized )
     e42:	80 91 44 08 	lds	r24, 0x0844
     e46:	88 23       	and	r24, r24
     e48:	39 f4       	brne	.+14     	; 0xe58 <Gpt_StopTimer+0x76>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_StopTimer_API,GPT_E_UNINIT);
     e4a:	84 e6       	ldi	r24, 0x64	; 100
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	60 e0       	ldi	r22, 0x00	; 0
     e50:	46 e0       	ldi	r20, 0x06	; 6
     e52:	2a e0       	ldi	r18, 0x0A	; 10
     e54:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
     e58:	08 95       	ret

00000e5a <Gpt_GetTimeElapsed>:
#endif


#if(GptTimeElapsedApi==E_OK)
Gpt_ValueType Gpt_GetTimeElapsed(Gpt_ChannelType Channel)
{
     e5a:	ef 92       	push	r14
     e5c:	ff 92       	push	r15
     e5e:	0f 93       	push	r16
     e60:	1f 93       	push	r17
Gpt_ChannelType Channel;

Gpt_ValueType  SelectChannel(Gpt_ChannelType Channel)
{
	Gpt_ValueType Value=0;
	if(Channel==Timer0_)
     e62:	88 23       	and	r24, r24
     e64:	11 f4       	brne	.+4      	; 0xe6a <Gpt_GetTimeElapsed+0x10>
	{
		Value=TCNT0_REG;
     e66:	82 b7       	in	r24, 0x32	; 50
     e68:	09 c0       	rjmp	.+18     	; 0xe7c <Gpt_GetTimeElapsed+0x22>
	}
	if(Channel==Timer1_)
     e6a:	81 30       	cpi	r24, 0x01	; 1
     e6c:	21 f4       	brne	.+8      	; 0xe76 <Gpt_GetTimeElapsed+0x1c>
	{
		Value=TCNT1_REG;
     e6e:	8c b5       	in	r24, 0x2c	; 44
     e70:	9d b5       	in	r25, 0x2d	; 45
     e72:	7c 01       	movw	r14, r24
     e74:	05 c0       	rjmp	.+10     	; 0xe80 <Gpt_GetTimeElapsed+0x26>

	}
	if(Channel==Timer2_)
     e76:	82 30       	cpi	r24, 0x02	; 2
     e78:	31 f4       	brne	.+12     	; 0xe86 <Gpt_GetTimeElapsed+0x2c>
	{
		Value=TCNT2_REG;
     e7a:	84 b5       	in	r24, 0x24	; 36
     e7c:	e8 2e       	mov	r14, r24
     e7e:	ff 24       	eor	r15, r15
     e80:	00 e0       	ldi	r16, 0x00	; 0
     e82:	10 e0       	ldi	r17, 0x00	; 0
     e84:	0c c0       	rjmp	.+24     	; 0xe9e <Gpt_GetTimeElapsed+0x44>
Gpt_ValueType Gpt_GetTimeElapsed(Gpt_ChannelType Channel)
{
	Gpt_ValueType Value;
	Value=SelectChannel(Channel);
#if (GptDevErrorDetect==E_OK)
	if(Channel>Timer2_ )
     e86:	83 30       	cpi	r24, 0x03	; 3
     e88:	38 f0       	brcs	.+14     	; 0xe98 <Gpt_GetTimeElapsed+0x3e>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeElapsed_API,GPT_E_PARAM_CHANNEL);
     e8a:	84 e6       	ldi	r24, 0x64	; 100
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	60 e0       	ldi	r22, 0x00	; 0
     e90:	43 e0       	ldi	r20, 0x03	; 3
     e92:	24 e1       	ldi	r18, 0x14	; 20
     e94:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
     e98:	ee 24       	eor	r14, r14
     e9a:	ff 24       	eor	r15, r15
     e9c:	87 01       	movw	r16, r14
	}
	if(Value>OverFlowTick)
     e9e:	80 91 3e 02 	lds	r24, 0x023E
     ea2:	90 91 3f 02 	lds	r25, 0x023F
     ea6:	a0 91 40 02 	lds	r26, 0x0240
     eaa:	b0 91 41 02 	lds	r27, 0x0241
     eae:	8e 15       	cp	r24, r14
     eb0:	9f 05       	cpc	r25, r15
     eb2:	a0 07       	cpc	r26, r16
     eb4:	b1 07       	cpc	r27, r17
     eb6:	38 f4       	brcc	.+14     	; 0xec6 <Gpt_GetTimeElapsed+0x6c>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeElapsed_API,GPT_E_PARAM_VALUE);
     eb8:	84 e6       	ldi	r24, 0x64	; 100
     eba:	90 e0       	ldi	r25, 0x00	; 0
     ebc:	60 e0       	ldi	r22, 0x00	; 0
     ebe:	43 e0       	ldi	r20, 0x03	; 3
     ec0:	25 e1       	ldi	r18, 0x15	; 21
     ec2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Uninitialized )
     ec6:	80 91 44 08 	lds	r24, 0x0844
     eca:	88 23       	and	r24, r24
     ecc:	39 f4       	brne	.+14     	; 0xedc <Gpt_GetTimeElapsed+0x82>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeElapsed_API,GPT_E_UNINIT);
     ece:	84 e6       	ldi	r24, 0x64	; 100
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	60 e0       	ldi	r22, 0x00	; 0
     ed4:	43 e0       	ldi	r20, 0x03	; 3
     ed6:	2a e0       	ldi	r18, 0x0A	; 10
     ed8:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Busy )
     edc:	80 91 44 08 	lds	r24, 0x0844
     ee0:	82 30       	cpi	r24, 0x02	; 2
     ee2:	39 f4       	brne	.+14     	; 0xef2 <Gpt_GetTimeElapsed+0x98>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeElapsed_API,GPT_E_BUSY);
     ee4:	84 e6       	ldi	r24, 0x64	; 100
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	60 e0       	ldi	r22, 0x00	; 0
     eea:	43 e0       	ldi	r20, 0x03	; 3
     eec:	2f e2       	ldi	r18, 0x2F	; 47
     eee:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
#endif
	return Value;
}
     ef2:	b7 01       	movw	r22, r14
     ef4:	c8 01       	movw	r24, r16
     ef6:	1f 91       	pop	r17
     ef8:	0f 91       	pop	r16
     efa:	ff 90       	pop	r15
     efc:	ef 90       	pop	r14
     efe:	08 95       	ret

00000f00 <Gpt_GetTimeRemaining>:
#endif

#if (GptTimeRemainingApi==E_OK)
Gpt_ValueType Gpt_GetTimeRemaining(Gpt_ChannelType Channel)
{
     f00:	cf 92       	push	r12
     f02:	df 92       	push	r13
     f04:	ef 92       	push	r14
     f06:	ff 92       	push	r15
     f08:	1f 93       	push	r17
     f0a:	18 2f       	mov	r17, r24
	Gpt_ValueType Value;
	Value=Total_Time-Gpt_GetTimeElapsed(Channel);
     f0c:	c0 90 3b 08 	lds	r12, 0x083B
     f10:	d0 90 3c 08 	lds	r13, 0x083C
     f14:	e0 90 3d 08 	lds	r14, 0x083D
     f18:	f0 90 3e 08 	lds	r15, 0x083E
     f1c:	0e 94 2d 07 	call	0xe5a	; 0xe5a <Gpt_GetTimeElapsed>
     f20:	c6 1a       	sub	r12, r22
     f22:	d7 0a       	sbc	r13, r23
     f24:	e8 0a       	sbc	r14, r24
     f26:	f9 0a       	sbc	r15, r25
#if (GptDevErrorDetect==E_OK)
	if(Channel>Timer2_ )
     f28:	13 30       	cpi	r17, 0x03	; 3
     f2a:	38 f0       	brcs	.+14     	; 0xf3a <Gpt_GetTimeRemaining+0x3a>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeRemaining_API,GPT_E_PARAM_CHANNEL);
     f2c:	84 e6       	ldi	r24, 0x64	; 100
     f2e:	90 e0       	ldi	r25, 0x00	; 0
     f30:	60 e0       	ldi	r22, 0x00	; 0
     f32:	44 e0       	ldi	r20, 0x04	; 4
     f34:	24 e1       	ldi	r18, 0x14	; 20
     f36:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(Value>OverFlowTick)
     f3a:	80 91 3e 02 	lds	r24, 0x023E
     f3e:	90 91 3f 02 	lds	r25, 0x023F
     f42:	a0 91 40 02 	lds	r26, 0x0240
     f46:	b0 91 41 02 	lds	r27, 0x0241
     f4a:	8c 15       	cp	r24, r12
     f4c:	9d 05       	cpc	r25, r13
     f4e:	ae 05       	cpc	r26, r14
     f50:	bf 05       	cpc	r27, r15
     f52:	38 f4       	brcc	.+14     	; 0xf62 <Gpt_GetTimeRemaining+0x62>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeRemaining_API,GPT_E_PARAM_VALUE);
     f54:	84 e6       	ldi	r24, 0x64	; 100
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	60 e0       	ldi	r22, 0x00	; 0
     f5a:	44 e0       	ldi	r20, 0x04	; 4
     f5c:	25 e1       	ldi	r18, 0x15	; 21
     f5e:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Uninitialized )
     f62:	80 91 44 08 	lds	r24, 0x0844
     f66:	88 23       	and	r24, r24
     f68:	39 f4       	brne	.+14     	; 0xf78 <Gpt_GetTimeRemaining+0x78>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeRemaining_API,GPT_E_UNINIT);
     f6a:	84 e6       	ldi	r24, 0x64	; 100
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	60 e0       	ldi	r22, 0x00	; 0
     f70:	44 e0       	ldi	r20, 0x04	; 4
     f72:	2a e0       	ldi	r18, 0x0A	; 10
     f74:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>

	}
	if(GenrateError==Gpt_Busy )
     f78:	80 91 44 08 	lds	r24, 0x0844
     f7c:	82 30       	cpi	r24, 0x02	; 2
     f7e:	39 f4       	brne	.+14     	; 0xf8e <Gpt_GetTimeRemaining+0x8e>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_GetTimeRemaining_API,GPT_E_BUSY);
     f80:	84 e6       	ldi	r24, 0x64	; 100
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	60 e0       	ldi	r22, 0x00	; 0
     f86:	44 e0       	ldi	r20, 0x04	; 4
     f88:	2f e2       	ldi	r18, 0x2F	; 47
     f8a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
#endif
	return Value;
}
     f8e:	b6 01       	movw	r22, r12
     f90:	c7 01       	movw	r24, r14
     f92:	1f 91       	pop	r17
     f94:	ff 90       	pop	r15
     f96:	ef 90       	pop	r14
     f98:	df 90       	pop	r13
     f9a:	cf 90       	pop	r12
     f9c:	08 95       	ret

00000f9e <Gpt_StartTimer>:
	Preload=0;
	Channel=ConfigPtr->Channel;
}

void Gpt_StartTimer(Gpt_ChannelType Channel,Gpt_ValueType Value)
{
     f9e:	9f 92       	push	r9
     fa0:	af 92       	push	r10
     fa2:	bf 92       	push	r11
     fa4:	cf 92       	push	r12
     fa6:	df 92       	push	r13
     fa8:	ef 92       	push	r14
     faa:	ff 92       	push	r15
     fac:	0f 93       	push	r16
     fae:	1f 93       	push	r17
     fb0:	98 2e       	mov	r9, r24
     fb2:	5a 01       	movw	r10, r20
     fb4:	6b 01       	movw	r12, r22
	Total_Time=Value;
     fb6:	40 93 3b 08 	sts	0x083B, r20
     fba:	50 93 3c 08 	sts	0x083C, r21
     fbe:	60 93 3d 08 	sts	0x083D, r22
     fc2:	70 93 3e 08 	sts	0x083E, r23
	ChannelTickFrequency=F_CPU/prescaler;
     fc6:	20 91 32 02 	lds	r18, 0x0232
     fca:	30 91 33 02 	lds	r19, 0x0233
     fce:	40 91 34 02 	lds	r20, 0x0234
     fd2:	50 91 35 02 	lds	r21, 0x0235
     fd6:	60 e0       	ldi	r22, 0x00	; 0
     fd8:	72 e1       	ldi	r23, 0x12	; 18
     fda:	8a e7       	ldi	r24, 0x7A	; 122
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	0e 94 a6 22 	call	0x454c	; 0x454c <__udivmodsi4>
     fe2:	20 93 36 02 	sts	0x0236, r18
     fe6:	30 93 37 02 	sts	0x0237, r19
     fea:	40 93 38 02 	sts	0x0238, r20
     fee:	50 93 39 02 	sts	0x0239, r21
	ChannelTickValueMax=1/ChannelTickFrequency;
     ff2:	61 e0       	ldi	r22, 0x01	; 1
     ff4:	70 e0       	ldi	r23, 0x00	; 0
     ff6:	80 e0       	ldi	r24, 0x00	; 0
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	0e 94 a6 22 	call	0x454c	; 0x454c <__udivmodsi4>
     ffe:	20 93 3a 02 	sts	0x023A, r18
    1002:	30 93 3b 02 	sts	0x023B, r19
    1006:	40 93 3c 02 	sts	0x023C, r20
    100a:	50 93 3d 02 	sts	0x023D, r21

	switch(Channel)
    100e:	81 e0       	ldi	r24, 0x01	; 1
    1010:	98 16       	cp	r9, r24
    1012:	09 f4       	brne	.+2      	; 0x1016 <Gpt_StartTimer+0x78>
    1014:	47 c0       	rjmp	.+142    	; 0x10a4 <Gpt_StartTimer+0x106>
    1016:	98 16       	cp	r9, r24
    1018:	28 f0       	brcs	.+10     	; 0x1024 <Gpt_StartTimer+0x86>
    101a:	82 e0       	ldi	r24, 0x02	; 2
    101c:	98 16       	cp	r9, r24
    101e:	09 f0       	breq	.+2      	; 0x1022 <Gpt_StartTimer+0x84>
    1020:	c4 c0       	rjmp	.+392    	; 0x11aa <Gpt_StartTimer+0x20c>
    1022:	84 c0       	rjmp	.+264    	; 0x112c <Gpt_StartTimer+0x18e>
	{
	case Timer0_:
		OverFlowTick=256;
    1024:	80 e0       	ldi	r24, 0x00	; 0
    1026:	91 e0       	ldi	r25, 0x01	; 1
    1028:	a0 e0       	ldi	r26, 0x00	; 0
    102a:	b0 e0       	ldi	r27, 0x00	; 0
    102c:	80 93 3e 02 	sts	0x023E, r24
    1030:	90 93 3f 02 	sts	0x023F, r25
    1034:	a0 93 40 02 	sts	0x0240, r26
    1038:	b0 93 41 02 	sts	0x0241, r27
		NumOfOverflow=Value/OverFlowTick;
    103c:	99 27       	eor	r25, r25
    103e:	8d 2d       	mov	r24, r13
    1040:	7c 2d       	mov	r23, r12
    1042:	6b 2d       	mov	r22, r11
    1044:	0e 94 9d 03 	call	0x73a	; 0x73a <__floatunsisf>
    1048:	7b 01       	movw	r14, r22
    104a:	8c 01       	movw	r16, r24
    104c:	60 93 31 08 	sts	0x0831, r22
    1050:	70 93 32 08 	sts	0x0832, r23
    1054:	80 93 33 08 	sts	0x0833, r24
    1058:	90 93 34 08 	sts	0x0834, r25
		Preload=OverFlowTick-(OverFlowTick*(f32)(NumOfOverflow-(u32)NumOfOverflow));
    105c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1060:	0e 94 9d 03 	call	0x73a	; 0x73a <__floatunsisf>
    1064:	9b 01       	movw	r18, r22
    1066:	ac 01       	movw	r20, r24
    1068:	c8 01       	movw	r24, r16
    106a:	b7 01       	movw	r22, r14
    106c:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	40 e8       	ldi	r20, 0x80	; 128
    1076:	53 e4       	ldi	r21, 0x43	; 67
    1078:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    107c:	9b 01       	movw	r18, r22
    107e:	ac 01       	movw	r20, r24
    1080:	60 e0       	ldi	r22, 0x00	; 0
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	80 e8       	ldi	r24, 0x80	; 128
    1086:	93 e4       	ldi	r25, 0x43	; 67
    1088:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    108c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1090:	60 93 3f 08 	sts	0x083F, r22
    1094:	70 93 40 08 	sts	0x0840, r23
    1098:	80 93 41 08 	sts	0x0841, r24
    109c:	90 93 42 08 	sts	0x0842, r25
		TCNT0_REG=Preload;
    10a0:	62 bf       	out	0x32, r22	; 50
    10a2:	83 c0       	rjmp	.+262    	; 0x11aa <Gpt_StartTimer+0x20c>
	break;
	case Timer1_:
		OverFlowTick=65536;
    10a4:	80 e0       	ldi	r24, 0x00	; 0
    10a6:	90 e0       	ldi	r25, 0x00	; 0
    10a8:	a1 e0       	ldi	r26, 0x01	; 1
    10aa:	b0 e0       	ldi	r27, 0x00	; 0
    10ac:	80 93 3e 02 	sts	0x023E, r24
    10b0:	90 93 3f 02 	sts	0x023F, r25
    10b4:	a0 93 40 02 	sts	0x0240, r26
    10b8:	b0 93 41 02 	sts	0x0241, r27
		NumOfOverflow=Value/OverFlowTick;
    10bc:	b6 01       	movw	r22, r12
    10be:	88 27       	eor	r24, r24
    10c0:	99 27       	eor	r25, r25
    10c2:	0e 94 9d 03 	call	0x73a	; 0x73a <__floatunsisf>
    10c6:	7b 01       	movw	r14, r22
    10c8:	8c 01       	movw	r16, r24
    10ca:	60 93 31 08 	sts	0x0831, r22
    10ce:	70 93 32 08 	sts	0x0832, r23
    10d2:	80 93 33 08 	sts	0x0833, r24
    10d6:	90 93 34 08 	sts	0x0834, r25
		Preload=OverFlowTick-(OverFlowTick*(f32)(NumOfOverflow-(u32)NumOfOverflow));
    10da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    10de:	0e 94 9d 03 	call	0x73a	; 0x73a <__floatunsisf>
    10e2:	9b 01       	movw	r18, r22
    10e4:	ac 01       	movw	r20, r24
    10e6:	c8 01       	movw	r24, r16
    10e8:	b7 01       	movw	r22, r14
    10ea:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    10ee:	20 e0       	ldi	r18, 0x00	; 0
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	40 e8       	ldi	r20, 0x80	; 128
    10f4:	57 e4       	ldi	r21, 0x47	; 71
    10f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10fa:	9b 01       	movw	r18, r22
    10fc:	ac 01       	movw	r20, r24
    10fe:	60 e0       	ldi	r22, 0x00	; 0
    1100:	70 e0       	ldi	r23, 0x00	; 0
    1102:	80 e8       	ldi	r24, 0x80	; 128
    1104:	97 e4       	ldi	r25, 0x47	; 71
    1106:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    110a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    110e:	60 93 3f 08 	sts	0x083F, r22
    1112:	70 93 40 08 	sts	0x0840, r23
    1116:	80 93 41 08 	sts	0x0841, r24
    111a:	90 93 42 08 	sts	0x0842, r25
		TCNT1L_REG=Preload;
    111e:	6c bd       	out	0x2c, r22	; 44
		TCNT1H_REG=Preload>>8;
    1120:	67 2f       	mov	r22, r23
    1122:	78 2f       	mov	r23, r24
    1124:	89 2f       	mov	r24, r25
    1126:	99 27       	eor	r25, r25
    1128:	6d bd       	out	0x2d, r22	; 45
    112a:	3f c0       	rjmp	.+126    	; 0x11aa <Gpt_StartTimer+0x20c>
	break;
	case Timer2_:
		OverFlowTick=256;
    112c:	80 e0       	ldi	r24, 0x00	; 0
    112e:	91 e0       	ldi	r25, 0x01	; 1
    1130:	a0 e0       	ldi	r26, 0x00	; 0
    1132:	b0 e0       	ldi	r27, 0x00	; 0
    1134:	80 93 3e 02 	sts	0x023E, r24
    1138:	90 93 3f 02 	sts	0x023F, r25
    113c:	a0 93 40 02 	sts	0x0240, r26
    1140:	b0 93 41 02 	sts	0x0241, r27
		NumOfOverflow=Value/OverFlowTick;
    1144:	99 27       	eor	r25, r25
    1146:	8d 2d       	mov	r24, r13
    1148:	7c 2d       	mov	r23, r12
    114a:	6b 2d       	mov	r22, r11
    114c:	0e 94 9d 03 	call	0x73a	; 0x73a <__floatunsisf>
    1150:	7b 01       	movw	r14, r22
    1152:	8c 01       	movw	r16, r24
    1154:	60 93 31 08 	sts	0x0831, r22
    1158:	70 93 32 08 	sts	0x0832, r23
    115c:	80 93 33 08 	sts	0x0833, r24
    1160:	90 93 34 08 	sts	0x0834, r25
		Preload=OverFlowTick-(OverFlowTick*(f32)(NumOfOverflow-(u32)NumOfOverflow));
    1164:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1168:	0e 94 9d 03 	call	0x73a	; 0x73a <__floatunsisf>
    116c:	9b 01       	movw	r18, r22
    116e:	ac 01       	movw	r20, r24
    1170:	c8 01       	movw	r24, r16
    1172:	b7 01       	movw	r22, r14
    1174:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    1178:	20 e0       	ldi	r18, 0x00	; 0
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	40 e8       	ldi	r20, 0x80	; 128
    117e:	53 e4       	ldi	r21, 0x43	; 67
    1180:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1184:	9b 01       	movw	r18, r22
    1186:	ac 01       	movw	r20, r24
    1188:	60 e0       	ldi	r22, 0x00	; 0
    118a:	70 e0       	ldi	r23, 0x00	; 0
    118c:	80 e8       	ldi	r24, 0x80	; 128
    118e:	93 e4       	ldi	r25, 0x43	; 67
    1190:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    1194:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1198:	60 93 3f 08 	sts	0x083F, r22
    119c:	70 93 40 08 	sts	0x0840, r23
    11a0:	80 93 41 08 	sts	0x0841, r24
    11a4:	90 93 42 08 	sts	0x0842, r25
		TCNT2_REG=Preload;
    11a8:	64 bd       	out	0x24, r22	; 36
	break;

	}
	if(Mode==GPT_CH_MODE_CONTINUOUS)
    11aa:	80 91 3a 08 	lds	r24, 0x083A
    11ae:	88 23       	and	r24, r24
    11b0:	99 f4       	brne	.+38     	; 0x11d8 <Gpt_StartTimer+0x23a>
	{
		counter++;
    11b2:	80 91 42 02 	lds	r24, 0x0242
    11b6:	90 91 43 02 	lds	r25, 0x0243
    11ba:	a0 91 44 02 	lds	r26, 0x0244
    11be:	b0 91 45 02 	lds	r27, 0x0245
    11c2:	01 96       	adiw	r24, 0x01	; 1
    11c4:	a1 1d       	adc	r26, r1
    11c6:	b1 1d       	adc	r27, r1
    11c8:	80 93 42 02 	sts	0x0242, r24
    11cc:	90 93 43 02 	sts	0x0243, r25
    11d0:	a0 93 44 02 	sts	0x0244, r26
    11d4:	b0 93 45 02 	sts	0x0245, r27
	}
#if (GptDevErrorDetect==E_OK)
	if(Channel>Timer2_ )
    11d8:	82 e0       	ldi	r24, 0x02	; 2
    11da:	89 15       	cp	r24, r9
    11dc:	40 f4       	brcc	.+16     	; 0x11ee <Gpt_StartTimer+0x250>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_StartTimer,GPT_E_PARAM_CHANNEL);
    11de:	84 e6       	ldi	r24, 0x64	; 100
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	60 e0       	ldi	r22, 0x00	; 0
    11e4:	4f ec       	ldi	r20, 0xCF	; 207
    11e6:	57 e0       	ldi	r21, 0x07	; 7
    11e8:	24 e1       	ldi	r18, 0x14	; 20
    11ea:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(Value>OverFlowTick)
    11ee:	80 91 3e 02 	lds	r24, 0x023E
    11f2:	90 91 3f 02 	lds	r25, 0x023F
    11f6:	a0 91 40 02 	lds	r26, 0x0240
    11fa:	b0 91 41 02 	lds	r27, 0x0241
    11fe:	8a 15       	cp	r24, r10
    1200:	9b 05       	cpc	r25, r11
    1202:	ac 05       	cpc	r26, r12
    1204:	bd 05       	cpc	r27, r13
    1206:	40 f4       	brcc	.+16     	; 0x1218 <Gpt_StartTimer+0x27a>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_StartTimer,GPT_E_PARAM_VALUE);
    1208:	84 e6       	ldi	r24, 0x64	; 100
    120a:	90 e0       	ldi	r25, 0x00	; 0
    120c:	60 e0       	ldi	r22, 0x00	; 0
    120e:	4f ec       	ldi	r20, 0xCF	; 207
    1210:	57 e0       	ldi	r21, 0x07	; 7
    1212:	25 e1       	ldi	r18, 0x15	; 21
    1214:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Uninitialized )
    1218:	80 91 44 08 	lds	r24, 0x0844
    121c:	88 23       	and	r24, r24
    121e:	41 f4       	brne	.+16     	; 0x1230 <Gpt_StartTimer+0x292>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_StartTimer,GPT_E_UNINIT);
    1220:	84 e6       	ldi	r24, 0x64	; 100
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	60 e0       	ldi	r22, 0x00	; 0
    1226:	4f ec       	ldi	r20, 0xCF	; 207
    1228:	57 e0       	ldi	r21, 0x07	; 7
    122a:	2a e0       	ldi	r18, 0x0A	; 10
    122c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Busy )
    1230:	80 91 44 08 	lds	r24, 0x0844
    1234:	82 30       	cpi	r24, 0x02	; 2
    1236:	41 f4       	brne	.+16     	; 0x1248 <Gpt_StartTimer+0x2aa>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_StartTimer,GPT_E_BUSY);
    1238:	84 e6       	ldi	r24, 0x64	; 100
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	60 e0       	ldi	r22, 0x00	; 0
    123e:	4f ec       	ldi	r20, 0xCF	; 207
    1240:	57 e0       	ldi	r21, 0x07	; 7
    1242:	2f e2       	ldi	r18, 0x2F	; 47
    1244:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
#endif

}
    1248:	1f 91       	pop	r17
    124a:	0f 91       	pop	r16
    124c:	ff 90       	pop	r15
    124e:	ef 90       	pop	r14
    1250:	df 90       	pop	r13
    1252:	cf 90       	pop	r12
    1254:	bf 90       	pop	r11
    1256:	af 90       	pop	r10
    1258:	9f 90       	pop	r9
    125a:	08 95       	ret

0000125c <Gpt_Init>:
	return Value;

}

void Gpt_Init(const Gpt_ConfigType* ConfigPtr)
{
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	ec 01       	movw	r28, r24
	if(ConfigPtr->Channel==Timer0_)
    1262:	88 81       	ld	r24, Y
    1264:	88 23       	and	r24, r24
    1266:	09 f0       	breq	.+2      	; 0x126a <Gpt_Init+0xe>
    1268:	84 c0       	rjmp	.+264    	; 0x1372 <Gpt_Init+0x116>
	{
		switch(ConfigPtr->GenratationMode)
    126a:	89 81       	ldd	r24, Y+1	; 0x01
    126c:	88 23       	and	r24, r24
    126e:	19 f0       	breq	.+6      	; 0x1276 <Gpt_Init+0x1a>
    1270:	81 30       	cpi	r24, 0x01	; 1
    1272:	51 f4       	brne	.+20     	; 0x1288 <Gpt_Init+0x2c>
    1274:	03 c0       	rjmp	.+6      	; 0x127c <Gpt_Init+0x20>
		{
		case Normal:
			CLEAR_BIT(TCCR0_REG,WGM01);
    1276:	83 b7       	in	r24, 0x33	; 51
    1278:	87 7f       	andi	r24, 0xF7	; 247
    127a:	02 c0       	rjmp	.+4      	; 0x1280 <Gpt_Init+0x24>
			CLEAR_BIT(TCCR0_REG,WGM00);
			break;
		case CTC:
			SET_BIT(TCCR0_REG,WGM01);
    127c:	83 b7       	in	r24, 0x33	; 51
    127e:	88 60       	ori	r24, 0x08	; 8
    1280:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,WGM00);
    1282:	83 b7       	in	r24, 0x33	; 51
    1284:	8f 7b       	andi	r24, 0xBF	; 191
    1286:	83 bf       	out	0x33, r24	; 51
			break;
		}
		switch(ConfigPtr->Prescaler)
    1288:	8a 81       	ldd	r24, Y+2	; 0x02
    128a:	84 30       	cpi	r24, 0x04	; 4
    128c:	09 f4       	brne	.+2      	; 0x1290 <Gpt_Init+0x34>
    128e:	40 c0       	rjmp	.+128    	; 0x1310 <Gpt_Init+0xb4>
    1290:	85 30       	cpi	r24, 0x05	; 5
    1292:	40 f4       	brcc	.+16     	; 0x12a4 <Gpt_Init+0x48>
    1294:	81 30       	cpi	r24, 0x01	; 1
    1296:	41 f1       	breq	.+80     	; 0x12e8 <Gpt_Init+0x8c>
    1298:	81 30       	cpi	r24, 0x01	; 1
    129a:	a0 f0       	brcs	.+40     	; 0x12c4 <Gpt_Init+0x68>
    129c:	82 30       	cpi	r24, 0x02	; 2
    129e:	09 f0       	breq	.+2      	; 0x12a2 <Gpt_Init+0x46>
    12a0:	87 c1       	rjmp	.+782    	; 0x15b0 <Gpt_Init+0x354>
    12a2:	2c c0       	rjmp	.+88     	; 0x12fc <Gpt_Init+0xa0>
    12a4:	87 30       	cpi	r24, 0x07	; 7
    12a6:	09 f4       	brne	.+2      	; 0x12aa <Gpt_Init+0x4e>
    12a8:	47 c0       	rjmp	.+142    	; 0x1338 <Gpt_Init+0xdc>
    12aa:	88 30       	cpi	r24, 0x08	; 8
    12ac:	20 f4       	brcc	.+8      	; 0x12b6 <Gpt_Init+0x5a>
    12ae:	86 30       	cpi	r24, 0x06	; 6
    12b0:	09 f0       	breq	.+2      	; 0x12b4 <Gpt_Init+0x58>
    12b2:	7e c1       	rjmp	.+764    	; 0x15b0 <Gpt_Init+0x354>
    12b4:	37 c0       	rjmp	.+110    	; 0x1324 <Gpt_Init+0xc8>
    12b6:	88 30       	cpi	r24, 0x08	; 8
    12b8:	09 f4       	brne	.+2      	; 0x12bc <Gpt_Init+0x60>
    12ba:	48 c0       	rjmp	.+144    	; 0x134c <Gpt_Init+0xf0>
    12bc:	89 30       	cpi	r24, 0x09	; 9
    12be:	09 f0       	breq	.+2      	; 0x12c2 <Gpt_Init+0x66>
    12c0:	77 c1       	rjmp	.+750    	; 0x15b0 <Gpt_Init+0x354>
    12c2:	4d c0       	rjmp	.+154    	; 0x135e <Gpt_Init+0x102>
		{
		case No_clock_source:
			CLEAR_BIT(TCCR0_REG,CS02);
    12c4:	83 b7       	in	r24, 0x33	; 51
    12c6:	8b 7f       	andi	r24, 0xFB	; 251
    12c8:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS01);
    12ca:	83 b7       	in	r24, 0x33	; 51
    12cc:	8d 7f       	andi	r24, 0xFD	; 253
    12ce:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS00);
    12d0:	83 b7       	in	r24, 0x33	; 51
    12d2:	8e 7f       	andi	r24, 0xFE	; 254
    12d4:	83 bf       	out	0x33, r24	; 51
			prescaler=0;
    12d6:	10 92 32 02 	sts	0x0232, r1
    12da:	10 92 33 02 	sts	0x0233, r1
    12de:	10 92 34 02 	sts	0x0234, r1
    12e2:	10 92 35 02 	sts	0x0235, r1
    12e6:	64 c1       	rjmp	.+712    	; 0x15b0 <Gpt_Init+0x354>
			break;
		case No_prescaling:
			CLEAR_BIT(TCCR0_REG,CS02);
    12e8:	83 b7       	in	r24, 0x33	; 51
    12ea:	8b 7f       	andi	r24, 0xFB	; 251
    12ec:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS01);
    12ee:	83 b7       	in	r24, 0x33	; 51
    12f0:	8d 7f       	andi	r24, 0xFD	; 253
    12f2:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS00);
    12f4:	83 b7       	in	r24, 0x33	; 51
    12f6:	81 60       	ori	r24, 0x01	; 1
    12f8:	83 bf       	out	0x33, r24	; 51
    12fa:	fa c0       	rjmp	.+500    	; 0x14f0 <Gpt_Init+0x294>
			prescaler=F_CPU;
			break;
		case Prescaler8:
			CLEAR_BIT(TCCR0_REG,CS02);
    12fc:	83 b7       	in	r24, 0x33	; 51
    12fe:	8b 7f       	andi	r24, 0xFB	; 251
    1300:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS01);
    1302:	83 b7       	in	r24, 0x33	; 51
    1304:	82 60       	ori	r24, 0x02	; 2
    1306:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS00);
    1308:	83 b7       	in	r24, 0x33	; 51
    130a:	8e 7f       	andi	r24, 0xFE	; 254
    130c:	83 bf       	out	0x33, r24	; 51
    130e:	fe c0       	rjmp	.+508    	; 0x150c <Gpt_Init+0x2b0>
			prescaler=8;
			break;
		case Prescaler64:
			CLEAR_BIT(TCCR0_REG,CS02);
    1310:	83 b7       	in	r24, 0x33	; 51
    1312:	8b 7f       	andi	r24, 0xFB	; 251
    1314:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS01);
    1316:	83 b7       	in	r24, 0x33	; 51
    1318:	82 60       	ori	r24, 0x02	; 2
    131a:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS00);
    131c:	83 b7       	in	r24, 0x33	; 51
    131e:	81 60       	ori	r24, 0x01	; 1
    1320:	83 bf       	out	0x33, r24	; 51
    1322:	10 c1       	rjmp	.+544    	; 0x1544 <Gpt_Init+0x2e8>
			prescaler=64;
			break;
		case Prescaler256:
			SET_BIT(TCCR0_REG,CS02);
    1324:	83 b7       	in	r24, 0x33	; 51
    1326:	84 60       	ori	r24, 0x04	; 4
    1328:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS01);
    132a:	83 b7       	in	r24, 0x33	; 51
    132c:	8d 7f       	andi	r24, 0xFD	; 253
    132e:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS00);
    1330:	83 b7       	in	r24, 0x33	; 51
    1332:	8e 7f       	andi	r24, 0xFE	; 254
    1334:	83 bf       	out	0x33, r24	; 51
    1336:	22 c1       	rjmp	.+580    	; 0x157c <Gpt_Init+0x320>
			prescaler=256;
			break;
		case Prescaler1024:
			SET_BIT(TCCR0_REG,CS02);
    1338:	83 b7       	in	r24, 0x33	; 51
    133a:	84 60       	ori	r24, 0x04	; 4
    133c:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS01);
    133e:	83 b7       	in	r24, 0x33	; 51
    1340:	8d 7f       	andi	r24, 0xFD	; 253
    1342:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS00);
    1344:	83 b7       	in	r24, 0x33	; 51
    1346:	81 60       	ori	r24, 0x01	; 1
    1348:	83 bf       	out	0x33, r24	; 51
    134a:	26 c1       	rjmp	.+588    	; 0x1598 <Gpt_Init+0x33c>
			prescaler=1024;
			break;
		case ExternalRisingEdge:
			SET_BIT(TCCR0_REG,CS02);
    134c:	83 b7       	in	r24, 0x33	; 51
    134e:	84 60       	ori	r24, 0x04	; 4
    1350:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS01);
    1352:	83 b7       	in	r24, 0x33	; 51
    1354:	82 60       	ori	r24, 0x02	; 2
    1356:	83 bf       	out	0x33, r24	; 51
			CLEAR_BIT(TCCR0_REG,CS00);
    1358:	83 b7       	in	r24, 0x33	; 51
    135a:	8e 7f       	andi	r24, 0xFE	; 254
    135c:	08 c0       	rjmp	.+16     	; 0x136e <Gpt_Init+0x112>
			break;
		case ExternalFallingEdge:
			SET_BIT(TCCR0_REG,CS02);
    135e:	83 b7       	in	r24, 0x33	; 51
    1360:	84 60       	ori	r24, 0x04	; 4
    1362:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS01);
    1364:	83 b7       	in	r24, 0x33	; 51
    1366:	82 60       	ori	r24, 0x02	; 2
    1368:	83 bf       	out	0x33, r24	; 51
			SET_BIT(TCCR0_REG,CS00);
    136a:	83 b7       	in	r24, 0x33	; 51
    136c:	81 60       	ori	r24, 0x01	; 1
    136e:	83 bf       	out	0x33, r24	; 51
    1370:	1f c1       	rjmp	.+574    	; 0x15b0 <Gpt_Init+0x354>
			break;
		}
	}
	else if(ConfigPtr->Channel==Timer1_)
    1372:	81 30       	cpi	r24, 0x01	; 1
    1374:	09 f0       	breq	.+2      	; 0x1378 <Gpt_Init+0x11c>
    1376:	81 c0       	rjmp	.+258    	; 0x147a <Gpt_Init+0x21e>
	{
		switch(ConfigPtr->GenratationMode)
    1378:	89 81       	ldd	r24, Y+1	; 0x01
    137a:	88 23       	and	r24, r24
    137c:	19 f0       	breq	.+6      	; 0x1384 <Gpt_Init+0x128>
    137e:	81 30       	cpi	r24, 0x01	; 1
    1380:	b1 f4       	brne	.+44     	; 0x13ae <Gpt_Init+0x152>
    1382:	09 c0       	rjmp	.+18     	; 0x1396 <Gpt_Init+0x13a>
		{
		case Normal:
			CLEAR_BIT(TCCR1A_REG,WGM10);
    1384:	8f b5       	in	r24, 0x2f	; 47
    1386:	8e 7f       	andi	r24, 0xFE	; 254
    1388:	8f bd       	out	0x2f, r24	; 47
			CLEAR_BIT(TCCR1A_REG,WGM11);
    138a:	8f b5       	in	r24, 0x2f	; 47
    138c:	8d 7f       	andi	r24, 0xFD	; 253
    138e:	8f bd       	out	0x2f, r24	; 47
			CLEAR_BIT(TCCR1B_REG,WGM12);
    1390:	8e b5       	in	r24, 0x2e	; 46
    1392:	87 7f       	andi	r24, 0xF7	; 247
    1394:	08 c0       	rjmp	.+16     	; 0x13a6 <Gpt_Init+0x14a>
			CLEAR_BIT(TCCR1B_REG,WGM13);
			break;
		case CTC:
			CLEAR_BIT(TCCR1A_REG,WGM10);
    1396:	8f b5       	in	r24, 0x2f	; 47
    1398:	8e 7f       	andi	r24, 0xFE	; 254
    139a:	8f bd       	out	0x2f, r24	; 47
			CLEAR_BIT(TCCR1A_REG,WGM11);
    139c:	8f b5       	in	r24, 0x2f	; 47
    139e:	8d 7f       	andi	r24, 0xFD	; 253
    13a0:	8f bd       	out	0x2f, r24	; 47
			SET_BIT(TCCR1B_REG,WGM12);
    13a2:	8e b5       	in	r24, 0x2e	; 46
    13a4:	88 60       	ori	r24, 0x08	; 8
    13a6:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,WGM13);
    13a8:	8e b5       	in	r24, 0x2e	; 46
    13aa:	8f 7e       	andi	r24, 0xEF	; 239
    13ac:	8e bd       	out	0x2e, r24	; 46

			break;
		}

		switch(ConfigPtr->Prescaler)
    13ae:	8a 81       	ldd	r24, Y+2	; 0x02
    13b0:	84 30       	cpi	r24, 0x04	; 4
    13b2:	91 f1       	breq	.+100    	; 0x1418 <Gpt_Init+0x1bc>
    13b4:	85 30       	cpi	r24, 0x05	; 5
    13b6:	40 f4       	brcc	.+16     	; 0x13c8 <Gpt_Init+0x16c>
    13b8:	81 30       	cpi	r24, 0x01	; 1
    13ba:	d1 f0       	breq	.+52     	; 0x13f0 <Gpt_Init+0x194>
    13bc:	81 30       	cpi	r24, 0x01	; 1
    13be:	90 f0       	brcs	.+36     	; 0x13e4 <Gpt_Init+0x188>
    13c0:	82 30       	cpi	r24, 0x02	; 2
    13c2:	09 f0       	breq	.+2      	; 0x13c6 <Gpt_Init+0x16a>
    13c4:	f5 c0       	rjmp	.+490    	; 0x15b0 <Gpt_Init+0x354>
    13c6:	1e c0       	rjmp	.+60     	; 0x1404 <Gpt_Init+0x1a8>
    13c8:	87 30       	cpi	r24, 0x07	; 7
    13ca:	d1 f1       	breq	.+116    	; 0x1440 <Gpt_Init+0x1e4>
    13cc:	88 30       	cpi	r24, 0x08	; 8
    13ce:	20 f4       	brcc	.+8      	; 0x13d8 <Gpt_Init+0x17c>
    13d0:	86 30       	cpi	r24, 0x06	; 6
    13d2:	09 f0       	breq	.+2      	; 0x13d6 <Gpt_Init+0x17a>
    13d4:	ed c0       	rjmp	.+474    	; 0x15b0 <Gpt_Init+0x354>
    13d6:	2a c0       	rjmp	.+84     	; 0x142c <Gpt_Init+0x1d0>
    13d8:	88 30       	cpi	r24, 0x08	; 8
    13da:	e1 f1       	breq	.+120    	; 0x1454 <Gpt_Init+0x1f8>
    13dc:	89 30       	cpi	r24, 0x09	; 9
    13de:	09 f0       	breq	.+2      	; 0x13e2 <Gpt_Init+0x186>
    13e0:	e7 c0       	rjmp	.+462    	; 0x15b0 <Gpt_Init+0x354>
    13e2:	41 c0       	rjmp	.+130    	; 0x1466 <Gpt_Init+0x20a>
		{
		case No_clock_source:
			CLEAR_BIT(TCCR1B_REG,CS02);
    13e4:	8e b5       	in	r24, 0x2e	; 46
    13e6:	8b 7f       	andi	r24, 0xFB	; 251
    13e8:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,CS01);
    13ea:	8e b5       	in	r24, 0x2e	; 46
    13ec:	8d 7f       	andi	r24, 0xFD	; 253
    13ee:	37 c0       	rjmp	.+110    	; 0x145e <Gpt_Init+0x202>
			CLEAR_BIT(TCCR1B_REG,CS00);

			break;
		case No_prescaling:
			CLEAR_BIT(TCCR1B_REG,CS12);
    13f0:	8e b5       	in	r24, 0x2e	; 46
    13f2:	8b 7f       	andi	r24, 0xFB	; 251
    13f4:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,CS11);
    13f6:	8e b5       	in	r24, 0x2e	; 46
    13f8:	8d 7f       	andi	r24, 0xFD	; 253
    13fa:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS10);
    13fc:	8e b5       	in	r24, 0x2e	; 46
    13fe:	81 60       	ori	r24, 0x01	; 1
    1400:	8e bd       	out	0x2e, r24	; 46
    1402:	76 c0       	rjmp	.+236    	; 0x14f0 <Gpt_Init+0x294>
			prescaler=F_CPU;
			break;
		case Prescaler8:
			CLEAR_BIT(TCCR1B_REG,CS12);
    1404:	8e b5       	in	r24, 0x2e	; 46
    1406:	8b 7f       	andi	r24, 0xFB	; 251
    1408:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS11);
    140a:	8e b5       	in	r24, 0x2e	; 46
    140c:	82 60       	ori	r24, 0x02	; 2
    140e:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,CS10);
    1410:	8e b5       	in	r24, 0x2e	; 46
    1412:	8e 7f       	andi	r24, 0xFE	; 254
    1414:	8e bd       	out	0x2e, r24	; 46
    1416:	7a c0       	rjmp	.+244    	; 0x150c <Gpt_Init+0x2b0>
			prescaler=8;
			break;
		case Prescaler64:
			CLEAR_BIT(TCCR1B_REG,CS12);
    1418:	8e b5       	in	r24, 0x2e	; 46
    141a:	8b 7f       	andi	r24, 0xFB	; 251
    141c:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS11);
    141e:	8e b5       	in	r24, 0x2e	; 46
    1420:	82 60       	ori	r24, 0x02	; 2
    1422:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS10);
    1424:	8e b5       	in	r24, 0x2e	; 46
    1426:	81 60       	ori	r24, 0x01	; 1
    1428:	8e bd       	out	0x2e, r24	; 46
    142a:	8c c0       	rjmp	.+280    	; 0x1544 <Gpt_Init+0x2e8>
			prescaler=64;
			break;
		case Prescaler256:
			SET_BIT(TCCR1B_REG,CS12);
    142c:	8e b5       	in	r24, 0x2e	; 46
    142e:	84 60       	ori	r24, 0x04	; 4
    1430:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,CS11);
    1432:	8e b5       	in	r24, 0x2e	; 46
    1434:	8d 7f       	andi	r24, 0xFD	; 253
    1436:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,CS10);
    1438:	8e b5       	in	r24, 0x2e	; 46
    143a:	8e 7f       	andi	r24, 0xFE	; 254
    143c:	8e bd       	out	0x2e, r24	; 46
    143e:	9e c0       	rjmp	.+316    	; 0x157c <Gpt_Init+0x320>
			prescaler=256;
			break;
		case Prescaler1024:
			SET_BIT(TCCR1B_REG,CS12);
    1440:	8e b5       	in	r24, 0x2e	; 46
    1442:	84 60       	ori	r24, 0x04	; 4
    1444:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,CS11);
    1446:	8e b5       	in	r24, 0x2e	; 46
    1448:	8d 7f       	andi	r24, 0xFD	; 253
    144a:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS10);
    144c:	8e b5       	in	r24, 0x2e	; 46
    144e:	81 60       	ori	r24, 0x01	; 1
    1450:	8e bd       	out	0x2e, r24	; 46
    1452:	a2 c0       	rjmp	.+324    	; 0x1598 <Gpt_Init+0x33c>
			prescaler=1024;
			break;
		case ExternalRisingEdge:
			SET_BIT(TCCR1B_REG,CS12);
    1454:	8e b5       	in	r24, 0x2e	; 46
    1456:	84 60       	ori	r24, 0x04	; 4
    1458:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS11);
    145a:	8e b5       	in	r24, 0x2e	; 46
    145c:	82 60       	ori	r24, 0x02	; 2
    145e:	8e bd       	out	0x2e, r24	; 46
			CLEAR_BIT(TCCR1B_REG,CS10);
    1460:	8e b5       	in	r24, 0x2e	; 46
    1462:	8e 7f       	andi	r24, 0xFE	; 254
    1464:	08 c0       	rjmp	.+16     	; 0x1476 <Gpt_Init+0x21a>
			break;
		case ExternalFallingEdge:
			SET_BIT(TCCR1B_REG,CS12);
    1466:	8e b5       	in	r24, 0x2e	; 46
    1468:	84 60       	ori	r24, 0x04	; 4
    146a:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS11);
    146c:	8e b5       	in	r24, 0x2e	; 46
    146e:	82 60       	ori	r24, 0x02	; 2
    1470:	8e bd       	out	0x2e, r24	; 46
			SET_BIT(TCCR1B_REG,CS10);
    1472:	8e b5       	in	r24, 0x2e	; 46
    1474:	81 60       	ori	r24, 0x01	; 1
    1476:	8e bd       	out	0x2e, r24	; 46
    1478:	9b c0       	rjmp	.+310    	; 0x15b0 <Gpt_Init+0x354>
			break;
		}
	}

	else if(ConfigPtr->Channel==Timer2_)
    147a:	82 30       	cpi	r24, 0x02	; 2
    147c:	09 f0       	breq	.+2      	; 0x1480 <Gpt_Init+0x224>
    147e:	98 c0       	rjmp	.+304    	; 0x15b0 <Gpt_Init+0x354>
	{
		switch(ConfigPtr->GenratationMode)
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	88 23       	and	r24, r24
    1484:	19 f0       	breq	.+6      	; 0x148c <Gpt_Init+0x230>
    1486:	81 30       	cpi	r24, 0x01	; 1
    1488:	51 f4       	brne	.+20     	; 0x149e <Gpt_Init+0x242>
    148a:	03 c0       	rjmp	.+6      	; 0x1492 <Gpt_Init+0x236>
		{
		case Normal:
			CLEAR_BIT(TCCR2_REG,WGM21);
    148c:	85 b5       	in	r24, 0x25	; 37
    148e:	87 7f       	andi	r24, 0xF7	; 247
    1490:	02 c0       	rjmp	.+4      	; 0x1496 <Gpt_Init+0x23a>
			CLEAR_BIT(TCCR2_REG,WGM20);

			break;
		case CTC:
			SET_BIT(TCCR2_REG,WGM21);
    1492:	85 b5       	in	r24, 0x25	; 37
    1494:	88 60       	ori	r24, 0x08	; 8
    1496:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,WGM20);
    1498:	85 b5       	in	r24, 0x25	; 37
    149a:	8f 7b       	andi	r24, 0xBF	; 191
    149c:	85 bd       	out	0x25, r24	; 37

			break;
		}
		switch(ConfigPtr->Prescaler)
    149e:	8a 81       	ldd	r24, Y+2	; 0x02
    14a0:	83 30       	cpi	r24, 0x03	; 3
    14a2:	c9 f1       	breq	.+114    	; 0x1516 <Gpt_Init+0x2ba>
    14a4:	84 30       	cpi	r24, 0x04	; 4
    14a6:	28 f4       	brcc	.+10     	; 0x14b2 <Gpt_Init+0x256>
    14a8:	81 30       	cpi	r24, 0x01	; 1
    14aa:	c9 f0       	breq	.+50     	; 0x14de <Gpt_Init+0x282>
    14ac:	82 30       	cpi	r24, 0x02	; 2
    14ae:	28 f5       	brcc	.+74     	; 0x14fa <Gpt_Init+0x29e>
    14b0:	0c c0       	rjmp	.+24     	; 0x14ca <Gpt_Init+0x26e>
    14b2:	85 30       	cpi	r24, 0x05	; 5
    14b4:	09 f4       	brne	.+2      	; 0x14b8 <Gpt_Init+0x25c>
    14b6:	4b c0       	rjmp	.+150    	; 0x154e <Gpt_Init+0x2f2>
    14b8:	85 30       	cpi	r24, 0x05	; 5
    14ba:	d8 f1       	brcs	.+118    	; 0x1532 <Gpt_Init+0x2d6>
    14bc:	86 30       	cpi	r24, 0x06	; 6
    14be:	09 f4       	brne	.+2      	; 0x14c2 <Gpt_Init+0x266>
    14c0:	54 c0       	rjmp	.+168    	; 0x156a <Gpt_Init+0x30e>
    14c2:	87 30       	cpi	r24, 0x07	; 7
    14c4:	09 f0       	breq	.+2      	; 0x14c8 <Gpt_Init+0x26c>
    14c6:	74 c0       	rjmp	.+232    	; 0x15b0 <Gpt_Init+0x354>
    14c8:	5e c0       	rjmp	.+188    	; 0x1586 <Gpt_Init+0x32a>
		{
		case No_clock_source:
			CLEAR_BIT(TCCR2_REG,CS22);
    14ca:	85 b5       	in	r24, 0x25	; 37
    14cc:	8b 7f       	andi	r24, 0xFB	; 251
    14ce:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS21);
    14d0:	85 b5       	in	r24, 0x25	; 37
    14d2:	8d 7f       	andi	r24, 0xFD	; 253
    14d4:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS20);
    14d6:	85 b5       	in	r24, 0x25	; 37
    14d8:	8e 7f       	andi	r24, 0xFE	; 254
    14da:	85 bd       	out	0x25, r24	; 37
    14dc:	69 c0       	rjmp	.+210    	; 0x15b0 <Gpt_Init+0x354>

			break;
		case No_prescaling:
			CLEAR_BIT(TCCR2_REG,CS22);
    14de:	85 b5       	in	r24, 0x25	; 37
    14e0:	8b 7f       	andi	r24, 0xFB	; 251
    14e2:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS21);
    14e4:	85 b5       	in	r24, 0x25	; 37
    14e6:	8d 7f       	andi	r24, 0xFD	; 253
    14e8:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS20);
    14ea:	85 b5       	in	r24, 0x25	; 37
    14ec:	81 60       	ori	r24, 0x01	; 1
    14ee:	85 bd       	out	0x25, r24	; 37
			prescaler=F_CPU;
    14f0:	80 e0       	ldi	r24, 0x00	; 0
    14f2:	92 e1       	ldi	r25, 0x12	; 18
    14f4:	aa e7       	ldi	r26, 0x7A	; 122
    14f6:	b0 e0       	ldi	r27, 0x00	; 0
    14f8:	53 c0       	rjmp	.+166    	; 0x15a0 <Gpt_Init+0x344>
			break;
		case Prescaler8:
			CLEAR_BIT(TCCR2_REG,CS22);
    14fa:	85 b5       	in	r24, 0x25	; 37
    14fc:	8b 7f       	andi	r24, 0xFB	; 251
    14fe:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS21);
    1500:	85 b5       	in	r24, 0x25	; 37
    1502:	82 60       	ori	r24, 0x02	; 2
    1504:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS20);
    1506:	85 b5       	in	r24, 0x25	; 37
    1508:	8e 7f       	andi	r24, 0xFE	; 254
    150a:	85 bd       	out	0x25, r24	; 37
			prescaler=8;
    150c:	88 e0       	ldi	r24, 0x08	; 8
    150e:	90 e0       	ldi	r25, 0x00	; 0
    1510:	a0 e0       	ldi	r26, 0x00	; 0
    1512:	b0 e0       	ldi	r27, 0x00	; 0
    1514:	45 c0       	rjmp	.+138    	; 0x15a0 <Gpt_Init+0x344>
			break;
		case Prescaler32:
			CLEAR_BIT(TCCR2_REG,CS22);
    1516:	85 b5       	in	r24, 0x25	; 37
    1518:	8b 7f       	andi	r24, 0xFB	; 251
    151a:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS21);
    151c:	85 b5       	in	r24, 0x25	; 37
    151e:	82 60       	ori	r24, 0x02	; 2
    1520:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS10);
    1522:	85 b5       	in	r24, 0x25	; 37
    1524:	81 60       	ori	r24, 0x01	; 1
    1526:	85 bd       	out	0x25, r24	; 37
			prescaler=32;
    1528:	80 e2       	ldi	r24, 0x20	; 32
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	a0 e0       	ldi	r26, 0x00	; 0
    152e:	b0 e0       	ldi	r27, 0x00	; 0
    1530:	37 c0       	rjmp	.+110    	; 0x15a0 <Gpt_Init+0x344>
			break;
		case Prescaler64:
			SET_BIT(TCCR2_REG,CS22);
    1532:	85 b5       	in	r24, 0x25	; 37
    1534:	84 60       	ori	r24, 0x04	; 4
    1536:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS21);
    1538:	85 b5       	in	r24, 0x25	; 37
    153a:	8d 7f       	andi	r24, 0xFD	; 253
    153c:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS20);
    153e:	85 b5       	in	r24, 0x25	; 37
    1540:	8e 7f       	andi	r24, 0xFE	; 254
    1542:	85 bd       	out	0x25, r24	; 37
			prescaler=64;
    1544:	80 e4       	ldi	r24, 0x40	; 64
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	a0 e0       	ldi	r26, 0x00	; 0
    154a:	b0 e0       	ldi	r27, 0x00	; 0
    154c:	29 c0       	rjmp	.+82     	; 0x15a0 <Gpt_Init+0x344>
			break;
		case Prescaler128:
			SET_BIT(TCCR2_REG,CS22);
    154e:	85 b5       	in	r24, 0x25	; 37
    1550:	84 60       	ori	r24, 0x04	; 4
    1552:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS21);
    1554:	85 b5       	in	r24, 0x25	; 37
    1556:	8d 7f       	andi	r24, 0xFD	; 253
    1558:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS20);
    155a:	85 b5       	in	r24, 0x25	; 37
    155c:	81 60       	ori	r24, 0x01	; 1
    155e:	85 bd       	out	0x25, r24	; 37
			prescaler=128;
    1560:	80 e8       	ldi	r24, 0x80	; 128
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	a0 e0       	ldi	r26, 0x00	; 0
    1566:	b0 e0       	ldi	r27, 0x00	; 0
    1568:	1b c0       	rjmp	.+54     	; 0x15a0 <Gpt_Init+0x344>
			break;
		case Prescaler256:
			SET_BIT(TCCR2_REG,CS22);
    156a:	85 b5       	in	r24, 0x25	; 37
    156c:	84 60       	ori	r24, 0x04	; 4
    156e:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS21);
    1570:	85 b5       	in	r24, 0x25	; 37
    1572:	82 60       	ori	r24, 0x02	; 2
    1574:	85 bd       	out	0x25, r24	; 37
			CLEAR_BIT(TCCR2_REG,CS20);
    1576:	85 b5       	in	r24, 0x25	; 37
    1578:	8e 7f       	andi	r24, 0xFE	; 254
    157a:	85 bd       	out	0x25, r24	; 37
			prescaler=256;
    157c:	80 e0       	ldi	r24, 0x00	; 0
    157e:	91 e0       	ldi	r25, 0x01	; 1
    1580:	a0 e0       	ldi	r26, 0x00	; 0
    1582:	b0 e0       	ldi	r27, 0x00	; 0
    1584:	0d c0       	rjmp	.+26     	; 0x15a0 <Gpt_Init+0x344>
			break;
		case Prescaler1024:
			SET_BIT(TCCR2_REG,CS22);
    1586:	85 b5       	in	r24, 0x25	; 37
    1588:	84 60       	ori	r24, 0x04	; 4
    158a:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS21);
    158c:	85 b5       	in	r24, 0x25	; 37
    158e:	82 60       	ori	r24, 0x02	; 2
    1590:	85 bd       	out	0x25, r24	; 37
			SET_BIT(TCCR2_REG,CS20);
    1592:	85 b5       	in	r24, 0x25	; 37
    1594:	81 60       	ori	r24, 0x01	; 1
    1596:	85 bd       	out	0x25, r24	; 37
			prescaler=1024;
    1598:	80 e0       	ldi	r24, 0x00	; 0
    159a:	94 e0       	ldi	r25, 0x04	; 4
    159c:	a0 e0       	ldi	r26, 0x00	; 0
    159e:	b0 e0       	ldi	r27, 0x00	; 0
    15a0:	80 93 32 02 	sts	0x0232, r24
    15a4:	90 93 33 02 	sts	0x0233, r25
    15a8:	a0 93 34 02 	sts	0x0234, r26
    15ac:	b0 93 35 02 	sts	0x0235, r27
			break;
		}
	}

#if (GptDevErrorDetect==E_OK)
	if(GenrateError==Gpt_AlreadyInitillized)
    15b0:	80 91 44 08 	lds	r24, 0x0844
    15b4:	81 30       	cpi	r24, 0x01	; 1
    15b6:	39 f4       	brne	.+14     	; 0x15c6 <Gpt_Init+0x36a>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_Init_API,GPT_E_ALREADY_INITIALIZED);
    15b8:	84 e6       	ldi	r24, 0x64	; 100
    15ba:	90 e0       	ldi	r25, 0x00	; 0
    15bc:	60 e0       	ldi	r22, 0x00	; 0
    15be:	41 e0       	ldi	r20, 0x01	; 1
    15c0:	2d e0       	ldi	r18, 0x0D	; 13
    15c2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(GenrateError==Gpt_Uninitialized )
    15c6:	80 91 44 08 	lds	r24, 0x0844
    15ca:	88 23       	and	r24, r24
    15cc:	39 f4       	brne	.+14     	; 0x15dc <Gpt_Init+0x380>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_Init_API,GPT_E_UNINIT);
    15ce:	84 e6       	ldi	r24, 0x64	; 100
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	60 e0       	ldi	r22, 0x00	; 0
    15d4:	41 e0       	ldi	r20, 0x01	; 1
    15d6:	2a e0       	ldi	r18, 0x0A	; 10
    15d8:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
	if(ConfigPtr==NULL)
    15dc:	20 97       	sbiw	r28, 0x00	; 0
    15de:	39 f4       	brne	.+14     	; 0x15ee <Gpt_Init+0x392>
	{
		Det_ReportError(GPT_Driver,Instance,Gpt_Init_API,GPT_E_PARAM_POINTER);
    15e0:	84 e6       	ldi	r24, 0x64	; 100
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	60 e0       	ldi	r22, 0x00	; 0
    15e6:	41 e0       	ldi	r20, 0x01	; 1
    15e8:	26 e1       	ldi	r18, 0x16	; 22
    15ea:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <Det_ReportError>
	}
#endif
	Mode=GPT_MODE_NORMAL;
    15ee:	10 92 3a 08 	sts	0x083A, r1
	Preload=0;
    15f2:	10 92 3f 08 	sts	0x083F, r1
    15f6:	10 92 40 08 	sts	0x0840, r1
    15fa:	10 92 41 08 	sts	0x0841, r1
    15fe:	10 92 42 08 	sts	0x0842, r1
	Channel=ConfigPtr->Channel;
    1602:	88 81       	ld	r24, Y
    1604:	80 93 39 08 	sts	0x0839, r24
}
    1608:	df 91       	pop	r29
    160a:	cf 91       	pop	r28
    160c:	08 95       	ret

0000160e <InterruptEnableNormal0>:

static void (*Gpt_CTCCallBack[NumofGptCTC])(void)={NULL,NULL,NULL,NULL};

void InterruptEnableNormal0(void)
{
	SET_BIT(TIMSK_REG,TOIE0);
    160e:	89 b7       	in	r24, 0x39	; 57
    1610:	81 60       	ori	r24, 0x01	; 1
    1612:	89 bf       	out	0x39, r24	; 57
}
    1614:	08 95       	ret

00001616 <InterruptDisableNormal0>:

void InterruptDisableNormal0(void)
{
	CLEAR_BIT(TIMSK_REG,TOIE0);
    1616:	89 b7       	in	r24, 0x39	; 57
    1618:	8e 7f       	andi	r24, 0xFE	; 254
    161a:	89 bf       	out	0x39, r24	; 57

}
    161c:	08 95       	ret

0000161e <InterruptEnableCTC0>:
void InterruptEnableCTC0(void)
{
	SET_BIT(TIMSK_REG,OCIE0);
    161e:	89 b7       	in	r24, 0x39	; 57
    1620:	82 60       	ori	r24, 0x02	; 2
    1622:	89 bf       	out	0x39, r24	; 57
}
    1624:	08 95       	ret

00001626 <InterruptDisableCTC0>:

void InterruptDisableCTC0(void)
{
	CLEAR_BIT(TIMSK_REG,OCIE0);
    1626:	89 b7       	in	r24, 0x39	; 57
    1628:	8d 7f       	andi	r24, 0xFD	; 253
    162a:	89 bf       	out	0x39, r24	; 57
}
    162c:	08 95       	ret

0000162e <InterruptEnableNormal1>:



void InterruptEnableNormal1(void)
{
	SET_BIT(TIMSK_REG,TOIE1);
    162e:	89 b7       	in	r24, 0x39	; 57
    1630:	84 60       	ori	r24, 0x04	; 4
    1632:	89 bf       	out	0x39, r24	; 57
}
    1634:	08 95       	ret

00001636 <InterruptDisableNormal1>:

void InterruptDisableNormal1(void)
{
	CLEAR_BIT(TIMSK_REG,TOIE1);
    1636:	89 b7       	in	r24, 0x39	; 57
    1638:	8b 7f       	andi	r24, 0xFB	; 251
    163a:	89 bf       	out	0x39, r24	; 57

}
    163c:	08 95       	ret

0000163e <InterruptEnableCTC1>:
void InterruptEnableCTC1(void)
{
	SET_BIT(TIMSK_REG,OCIE1A);
    163e:	89 b7       	in	r24, 0x39	; 57
    1640:	80 61       	ori	r24, 0x10	; 16
    1642:	89 bf       	out	0x39, r24	; 57
	SET_BIT(TIMSK_REG,OCIE1B);
    1644:	89 b7       	in	r24, 0x39	; 57
    1646:	88 60       	ori	r24, 0x08	; 8
    1648:	89 bf       	out	0x39, r24	; 57
}
    164a:	08 95       	ret

0000164c <InterruptDisableCTC1>:

void InterruptDisableCTC1(void)
{
	CLEAR_BIT(TIMSK_REG,OCIE1A);
    164c:	89 b7       	in	r24, 0x39	; 57
    164e:	8f 7e       	andi	r24, 0xEF	; 239
    1650:	89 bf       	out	0x39, r24	; 57
	SET_BIT(TIMSK_REG,OCIE1B);
    1652:	89 b7       	in	r24, 0x39	; 57
    1654:	88 60       	ori	r24, 0x08	; 8
    1656:	89 bf       	out	0x39, r24	; 57
}
    1658:	08 95       	ret

0000165a <InterruptEnableNormal2>:



void InterruptEnableNormal2(void)
{
	SET_BIT(TIMSK_REG,TOIE2);
    165a:	89 b7       	in	r24, 0x39	; 57
    165c:	80 64       	ori	r24, 0x40	; 64
    165e:	89 bf       	out	0x39, r24	; 57
}
    1660:	08 95       	ret

00001662 <InterruptDisableNormal2>:

void InterruptDisableNormal2(void)
{
	CLEAR_BIT(TIMSK_REG,TOIE2);
    1662:	89 b7       	in	r24, 0x39	; 57
    1664:	8f 7b       	andi	r24, 0xBF	; 191
    1666:	89 bf       	out	0x39, r24	; 57

}
    1668:	08 95       	ret

0000166a <InterruptEnableCTC2>:
void InterruptEnableCTC2(void)
{
	SET_BIT(TIMSK_REG,OCIE2);
    166a:	89 b7       	in	r24, 0x39	; 57
    166c:	80 68       	ori	r24, 0x80	; 128
    166e:	89 bf       	out	0x39, r24	; 57
}
    1670:	08 95       	ret

00001672 <InterruptDisableCTC2>:

void InterruptDisableCTC2(void)
{
	CLEAR_BIT(TIMSK_REG,OCIE2);
    1672:	89 b7       	in	r24, 0x39	; 57
    1674:	8f 77       	andi	r24, 0x7F	; 127
    1676:	89 bf       	out	0x39, r24	; 57
}
    1678:	08 95       	ret

0000167a <Gpt_SetCallBackNormal>:

void Gpt_SetCallBackNormal(void(*CallBack)(void),Gpt_ChannelType Channel)
{
	if(CallBack!=NULL)
    167a:	00 97       	sbiw	r24, 0x00	; 0
    167c:	41 f0       	breq	.+16     	; 0x168e <Gpt_SetCallBackNormal+0x14>
	{
		Gpt_NormalCallBack[Channel]=CallBack;
    167e:	e6 2f       	mov	r30, r22
    1680:	f0 e0       	ldi	r31, 0x00	; 0
    1682:	ee 0f       	add	r30, r30
    1684:	ff 1f       	adc	r31, r31
    1686:	e1 5b       	subi	r30, 0xB1	; 177
    1688:	fd 4f       	sbci	r31, 0xFD	; 253
    168a:	91 83       	std	Z+1, r25	; 0x01
    168c:	80 83       	st	Z, r24
    168e:	08 95       	ret

00001690 <Gpt_SetCallBackCTC>:
	}
}

void Gpt_SetCallBackCTC(void(*CallBack)(void),Gpt_ChannelType Channel)
{
	if(CallBack!=NULL)
    1690:	00 97       	sbiw	r24, 0x00	; 0
    1692:	41 f0       	breq	.+16     	; 0x16a4 <Gpt_SetCallBackCTC+0x14>
	{
		Gpt_CTCCallBack[Channel]=CallBack;
    1694:	e6 2f       	mov	r30, r22
    1696:	f0 e0       	ldi	r31, 0x00	; 0
    1698:	ee 0f       	add	r30, r30
    169a:	ff 1f       	adc	r31, r31
    169c:	e9 5b       	subi	r30, 0xB9	; 185
    169e:	fd 4f       	sbci	r31, 0xFD	; 253
    16a0:	91 83       	std	Z+1, r25	; 0x01
    16a2:	80 83       	st	Z, r24
    16a4:	08 95       	ret

000016a6 <Det_ReportError>:
extern const Dio_LevelType  ChannelLevel [TOTAL_PINS];

Std_ReturnType Det_ReportError(u16 moduleId,u8 instanceId,u8 ApiId,u8 ErrorId)
{
	return E_OK ;
}
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	08 95       	ret

000016aa <Dio_ReadChannel>:
Dio_LevelType Dio_ReadChannel(Dio_ChannelType ChannelId)
{
	Dio_LevelType Level;
	Dio_PortType PortId;
	PortId = ChannelId/NumOfPort;
	u8 Pin_num = ChannelId % NumOfPort ;
    16aa:	28 2f       	mov	r18, r24
    16ac:	27 70       	andi	r18, 0x07	; 7
	if(ChannelId>=TOTAL_PINS)
	{
		Det_ReportError(DIO_Driver,Instance,Dio_ReadChannel_API,DIO_E_PARAM_INVALID_CHANNEL_ID);
	}
#endif
	switch(PortId)
    16ae:	86 95       	lsr	r24
    16b0:	86 95       	lsr	r24
    16b2:	86 95       	lsr	r24
    16b4:	81 30       	cpi	r24, 0x01	; 1
    16b6:	49 f0       	breq	.+18     	; 0x16ca <Dio_ReadChannel+0x20>
    16b8:	81 30       	cpi	r24, 0x01	; 1
    16ba:	28 f0       	brcs	.+10     	; 0x16c6 <Dio_ReadChannel+0x1c>
    16bc:	82 30       	cpi	r24, 0x02	; 2
    16be:	39 f0       	breq	.+14     	; 0x16ce <Dio_ReadChannel+0x24>
    16c0:	83 30       	cpi	r24, 0x03	; 3
    16c2:	b1 f4       	brne	.+44     	; 0x16f0 <Dio_ReadChannel+0x46>
    16c4:	0d c0       	rjmp	.+26     	; 0x16e0 <Dio_ReadChannel+0x36>
	{
	case PA :
		if(READ_PIN(PINA_REG ,Pin_num)==STD_LOW )
    16c6:	89 b3       	in	r24, 0x19	; 25
    16c8:	03 c0       	rjmp	.+6      	; 0x16d0 <Dio_ReadChannel+0x26>
		{
			Level=STD_HIGH;
		}
		break;
	case PB :
		if(READ_PIN(PINB_REG ,Pin_num)==STD_LOW )
    16ca:	86 b3       	in	r24, 0x16	; 22
    16cc:	01 c0       	rjmp	.+2      	; 0x16d0 <Dio_ReadChannel+0x26>
		{
			Level=STD_HIGH;
		}
		break;
	case PC :
		if(READ_PIN(PINC_REG ,Pin_num)==STD_LOW )
    16ce:	83 b3       	in	r24, 0x13	; 19
    16d0:	90 e0       	ldi	r25, 0x00	; 0
    16d2:	02 c0       	rjmp	.+4      	; 0x16d8 <Dio_ReadChannel+0x2e>
    16d4:	95 95       	asr	r25
    16d6:	87 95       	ror	r24
    16d8:	2a 95       	dec	r18
    16da:	e2 f7       	brpl	.-8      	; 0x16d4 <Dio_ReadChannel+0x2a>
    16dc:	81 70       	andi	r24, 0x01	; 1
    16de:	08 95       	ret
			Level=STD_HIGH;
		}
		break;

	case PD :
		if(READ_PIN(PIND_REG ,Pin_num)==STD_LOW )
    16e0:	80 b3       	in	r24, 0x10	; 16
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	02 c0       	rjmp	.+4      	; 0x16ea <Dio_ReadChannel+0x40>
    16e6:	95 95       	asr	r25
    16e8:	87 95       	ror	r24
    16ea:	2a 95       	dec	r18
    16ec:	e2 f7       	brpl	.-8      	; 0x16e6 <Dio_ReadChannel+0x3c>
    16ee:	81 70       	andi	r24, 0x01	; 1
	}


	return Level;

}
    16f0:	08 95       	ret

000016f2 <Dio_WriteChannel>:

void Dio_WriteChannel(Dio_ChannelType ChannelId,Dio_LevelType Level)
{
	Dio_PortType PortId;
	PortId = ChannelId/NumOfPort;
	u8 Pin_num = ChannelId %NumOfPort ;
    16f2:	38 2f       	mov	r19, r24
    16f4:	37 70       	andi	r19, 0x07	; 7
	if(ChannelId>=TOTAL_PINS)
	{
		Det_ReportError(DIO_Driver,Instance,Dio_WriteChannel_API,DIO_E_PARAM_INVALID_CHANNEL_ID);
	}
#endif
	switch (PortId)
    16f6:	86 95       	lsr	r24
    16f8:	86 95       	lsr	r24
    16fa:	86 95       	lsr	r24
    16fc:	81 30       	cpi	r24, 0x01	; 1
    16fe:	29 f1       	breq	.+74     	; 0x174a <Dio_WriteChannel+0x58>
    1700:	81 30       	cpi	r24, 0x01	; 1
    1702:	38 f0       	brcs	.+14     	; 0x1712 <Dio_WriteChannel+0x20>
    1704:	82 30       	cpi	r24, 0x02	; 2
    1706:	09 f4       	brne	.+2      	; 0x170a <Dio_WriteChannel+0x18>
    1708:	3c c0       	rjmp	.+120    	; 0x1782 <Dio_WriteChannel+0x90>
    170a:	83 30       	cpi	r24, 0x03	; 3
    170c:	09 f0       	breq	.+2      	; 0x1710 <Dio_WriteChannel+0x1e>
    170e:	6e c0       	rjmp	.+220    	; 0x17ec <Dio_WriteChannel+0xfa>
    1710:	53 c0       	rjmp	.+166    	; 0x17b8 <Dio_WriteChannel+0xc6>
	{
	case PA:
		if(Level==STD_HIGH)
    1712:	61 30       	cpi	r22, 0x01	; 1
    1714:	59 f4       	brne	.+22     	; 0x172c <Dio_WriteChannel+0x3a>
		{
			SET_PIN(PORTA_REG,Pin_num);
    1716:	2b b3       	in	r18, 0x1b	; 27
    1718:	81 e0       	ldi	r24, 0x01	; 1
    171a:	90 e0       	ldi	r25, 0x00	; 0
    171c:	02 c0       	rjmp	.+4      	; 0x1722 <Dio_WriteChannel+0x30>
    171e:	88 0f       	add	r24, r24
    1720:	99 1f       	adc	r25, r25
    1722:	3a 95       	dec	r19
    1724:	e2 f7       	brpl	.-8      	; 0x171e <Dio_WriteChannel+0x2c>
    1726:	28 2b       	or	r18, r24
    1728:	2b bb       	out	0x1b, r18	; 27
    172a:	08 95       	ret
		}
		else if(Level==STD_LOW)
    172c:	66 23       	and	r22, r22
    172e:	09 f0       	breq	.+2      	; 0x1732 <Dio_WriteChannel+0x40>
    1730:	5d c0       	rjmp	.+186    	; 0x17ec <Dio_WriteChannel+0xfa>
		{
			CLEAR_PIN(PORTA_REG,Pin_num);
    1732:	2b b3       	in	r18, 0x1b	; 27
    1734:	81 e0       	ldi	r24, 0x01	; 1
    1736:	90 e0       	ldi	r25, 0x00	; 0
    1738:	02 c0       	rjmp	.+4      	; 0x173e <Dio_WriteChannel+0x4c>
    173a:	88 0f       	add	r24, r24
    173c:	99 1f       	adc	r25, r25
    173e:	3a 95       	dec	r19
    1740:	e2 f7       	brpl	.-8      	; 0x173a <Dio_WriteChannel+0x48>
    1742:	80 95       	com	r24
    1744:	82 23       	and	r24, r18
    1746:	8b bb       	out	0x1b, r24	; 27
    1748:	08 95       	ret
		}
		break;

	case PB:
		if(Level==STD_HIGH)
    174a:	61 30       	cpi	r22, 0x01	; 1
    174c:	59 f4       	brne	.+22     	; 0x1764 <Dio_WriteChannel+0x72>
		{
			SET_PIN(PORTB_REG,Pin_num);
    174e:	28 b3       	in	r18, 0x18	; 24
    1750:	81 e0       	ldi	r24, 0x01	; 1
    1752:	90 e0       	ldi	r25, 0x00	; 0
    1754:	02 c0       	rjmp	.+4      	; 0x175a <Dio_WriteChannel+0x68>
    1756:	88 0f       	add	r24, r24
    1758:	99 1f       	adc	r25, r25
    175a:	3a 95       	dec	r19
    175c:	e2 f7       	brpl	.-8      	; 0x1756 <Dio_WriteChannel+0x64>
    175e:	28 2b       	or	r18, r24
    1760:	28 bb       	out	0x18, r18	; 24
    1762:	08 95       	ret
		}
		else if(Level==STD_LOW)
    1764:	66 23       	and	r22, r22
    1766:	09 f0       	breq	.+2      	; 0x176a <Dio_WriteChannel+0x78>
    1768:	41 c0       	rjmp	.+130    	; 0x17ec <Dio_WriteChannel+0xfa>
		{
			CLEAR_PIN(PORTB_REG,Pin_num);
    176a:	28 b3       	in	r18, 0x18	; 24
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	02 c0       	rjmp	.+4      	; 0x1776 <Dio_WriteChannel+0x84>
    1772:	88 0f       	add	r24, r24
    1774:	99 1f       	adc	r25, r25
    1776:	3a 95       	dec	r19
    1778:	e2 f7       	brpl	.-8      	; 0x1772 <Dio_WriteChannel+0x80>
    177a:	80 95       	com	r24
    177c:	82 23       	and	r24, r18
    177e:	88 bb       	out	0x18, r24	; 24
    1780:	08 95       	ret
		}
		break;
	case PC:
		if(Level==STD_HIGH)
    1782:	61 30       	cpi	r22, 0x01	; 1
    1784:	59 f4       	brne	.+22     	; 0x179c <Dio_WriteChannel+0xaa>
		{
			SET_PIN(PORTC_REG,Pin_num);
    1786:	25 b3       	in	r18, 0x15	; 21
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	90 e0       	ldi	r25, 0x00	; 0
    178c:	02 c0       	rjmp	.+4      	; 0x1792 <Dio_WriteChannel+0xa0>
    178e:	88 0f       	add	r24, r24
    1790:	99 1f       	adc	r25, r25
    1792:	3a 95       	dec	r19
    1794:	e2 f7       	brpl	.-8      	; 0x178e <Dio_WriteChannel+0x9c>
    1796:	28 2b       	or	r18, r24
    1798:	25 bb       	out	0x15, r18	; 21
    179a:	08 95       	ret
		}
		else if(Level==STD_LOW)
    179c:	66 23       	and	r22, r22
    179e:	31 f5       	brne	.+76     	; 0x17ec <Dio_WriteChannel+0xfa>
		{
			CLEAR_PIN(PORTC_REG,Pin_num);
    17a0:	25 b3       	in	r18, 0x15	; 21
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	02 c0       	rjmp	.+4      	; 0x17ac <Dio_WriteChannel+0xba>
    17a8:	88 0f       	add	r24, r24
    17aa:	99 1f       	adc	r25, r25
    17ac:	3a 95       	dec	r19
    17ae:	e2 f7       	brpl	.-8      	; 0x17a8 <Dio_WriteChannel+0xb6>
    17b0:	80 95       	com	r24
    17b2:	82 23       	and	r24, r18
    17b4:	85 bb       	out	0x15, r24	; 21
    17b6:	08 95       	ret
		}
		break;
	case PD:
		if(Level==STD_HIGH)
    17b8:	61 30       	cpi	r22, 0x01	; 1
    17ba:	59 f4       	brne	.+22     	; 0x17d2 <Dio_WriteChannel+0xe0>
		{
			SET_PIN(PORTD_REG,Pin_num);
    17bc:	22 b3       	in	r18, 0x12	; 18
    17be:	81 e0       	ldi	r24, 0x01	; 1
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	02 c0       	rjmp	.+4      	; 0x17c8 <Dio_WriteChannel+0xd6>
    17c4:	88 0f       	add	r24, r24
    17c6:	99 1f       	adc	r25, r25
    17c8:	3a 95       	dec	r19
    17ca:	e2 f7       	brpl	.-8      	; 0x17c4 <Dio_WriteChannel+0xd2>
    17cc:	28 2b       	or	r18, r24
    17ce:	22 bb       	out	0x12, r18	; 18
    17d0:	08 95       	ret
		}
		else if(Level==STD_LOW)
    17d2:	66 23       	and	r22, r22
    17d4:	59 f4       	brne	.+22     	; 0x17ec <Dio_WriteChannel+0xfa>
		{
			CLEAR_PIN(PORTD_REG,Pin_num);
    17d6:	22 b3       	in	r18, 0x12	; 18
    17d8:	81 e0       	ldi	r24, 0x01	; 1
    17da:	90 e0       	ldi	r25, 0x00	; 0
    17dc:	02 c0       	rjmp	.+4      	; 0x17e2 <Dio_WriteChannel+0xf0>
    17de:	88 0f       	add	r24, r24
    17e0:	99 1f       	adc	r25, r25
    17e2:	3a 95       	dec	r19
    17e4:	e2 f7       	brpl	.-8      	; 0x17de <Dio_WriteChannel+0xec>
    17e6:	80 95       	com	r24
    17e8:	82 23       	and	r24, r18
    17ea:	82 bb       	out	0x12, r24	; 18
    17ec:	08 95       	ret

000017ee <Dio_WriteDirectionChannel>:

void Dio_WriteDirectionChannel(Dio_ChannelType ChannelId,Dio_ChannelStatus Status)
{
	Dio_PortType PortId;
	PortId = ChannelId/NumOfPort;
	u8 Pin_num = ChannelId % NumOfPort ;
    17ee:	38 2f       	mov	r19, r24
    17f0:	37 70       	andi	r19, 0x07	; 7
	if(ChannelId>=TOTAL_PINS)
	{
		Det_ReportError(DIO_Driver,Instance,Dio_WriteDirctionChannel_API,DIO_E_PARAM_INVALID_CHANNEL_ID);
	}
#endif
	switch (PortId)
    17f2:	86 95       	lsr	r24
    17f4:	86 95       	lsr	r24
    17f6:	86 95       	lsr	r24
    17f8:	81 30       	cpi	r24, 0x01	; 1
    17fa:	29 f1       	breq	.+74     	; 0x1846 <Dio_WriteDirectionChannel+0x58>
    17fc:	81 30       	cpi	r24, 0x01	; 1
    17fe:	38 f0       	brcs	.+14     	; 0x180e <Dio_WriteDirectionChannel+0x20>
    1800:	82 30       	cpi	r24, 0x02	; 2
    1802:	09 f4       	brne	.+2      	; 0x1806 <Dio_WriteDirectionChannel+0x18>
    1804:	3c c0       	rjmp	.+120    	; 0x187e <Dio_WriteDirectionChannel+0x90>
    1806:	83 30       	cpi	r24, 0x03	; 3
    1808:	09 f0       	breq	.+2      	; 0x180c <Dio_WriteDirectionChannel+0x1e>
    180a:	6e c0       	rjmp	.+220    	; 0x18e8 <Dio_WriteDirectionChannel+0xfa>
    180c:	53 c0       	rjmp	.+166    	; 0x18b4 <Dio_WriteDirectionChannel+0xc6>
	{
	case PA:
		if(Status==OUTPUT)
    180e:	61 30       	cpi	r22, 0x01	; 1
    1810:	59 f4       	brne	.+22     	; 0x1828 <Dio_WriteDirectionChannel+0x3a>
		{
			SET_PIN(DDRA_REG,Pin_num);
    1812:	2a b3       	in	r18, 0x1a	; 26
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	90 e0       	ldi	r25, 0x00	; 0
    1818:	02 c0       	rjmp	.+4      	; 0x181e <Dio_WriteDirectionChannel+0x30>
    181a:	88 0f       	add	r24, r24
    181c:	99 1f       	adc	r25, r25
    181e:	3a 95       	dec	r19
    1820:	e2 f7       	brpl	.-8      	; 0x181a <Dio_WriteDirectionChannel+0x2c>
    1822:	28 2b       	or	r18, r24
    1824:	2a bb       	out	0x1a, r18	; 26
    1826:	08 95       	ret
		}
		else if(Status==INPUT)
    1828:	66 23       	and	r22, r22
    182a:	09 f0       	breq	.+2      	; 0x182e <Dio_WriteDirectionChannel+0x40>
    182c:	5d c0       	rjmp	.+186    	; 0x18e8 <Dio_WriteDirectionChannel+0xfa>
		{
			CLEAR_PIN(DDRA_REG,Pin_num);
    182e:	2a b3       	in	r18, 0x1a	; 26
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	90 e0       	ldi	r25, 0x00	; 0
    1834:	02 c0       	rjmp	.+4      	; 0x183a <Dio_WriteDirectionChannel+0x4c>
    1836:	88 0f       	add	r24, r24
    1838:	99 1f       	adc	r25, r25
    183a:	3a 95       	dec	r19
    183c:	e2 f7       	brpl	.-8      	; 0x1836 <Dio_WriteDirectionChannel+0x48>
    183e:	80 95       	com	r24
    1840:	82 23       	and	r24, r18
    1842:	8a bb       	out	0x1a, r24	; 26
    1844:	08 95       	ret
		}
		break;

	case PB:
		if(Status==OUTPUT)
    1846:	61 30       	cpi	r22, 0x01	; 1
    1848:	59 f4       	brne	.+22     	; 0x1860 <Dio_WriteDirectionChannel+0x72>
		{
			SET_PIN(DDRB_REG,Pin_num);
    184a:	27 b3       	in	r18, 0x17	; 23
    184c:	81 e0       	ldi	r24, 0x01	; 1
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	02 c0       	rjmp	.+4      	; 0x1856 <Dio_WriteDirectionChannel+0x68>
    1852:	88 0f       	add	r24, r24
    1854:	99 1f       	adc	r25, r25
    1856:	3a 95       	dec	r19
    1858:	e2 f7       	brpl	.-8      	; 0x1852 <Dio_WriteDirectionChannel+0x64>
    185a:	28 2b       	or	r18, r24
    185c:	27 bb       	out	0x17, r18	; 23
    185e:	08 95       	ret
		}
		else if(Status==INPUT)
    1860:	66 23       	and	r22, r22
    1862:	09 f0       	breq	.+2      	; 0x1866 <Dio_WriteDirectionChannel+0x78>
    1864:	41 c0       	rjmp	.+130    	; 0x18e8 <Dio_WriteDirectionChannel+0xfa>
		{
			CLEAR_PIN(DDRB_REG,Pin_num);
    1866:	27 b3       	in	r18, 0x17	; 23
    1868:	81 e0       	ldi	r24, 0x01	; 1
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	02 c0       	rjmp	.+4      	; 0x1872 <Dio_WriteDirectionChannel+0x84>
    186e:	88 0f       	add	r24, r24
    1870:	99 1f       	adc	r25, r25
    1872:	3a 95       	dec	r19
    1874:	e2 f7       	brpl	.-8      	; 0x186e <Dio_WriteDirectionChannel+0x80>
    1876:	80 95       	com	r24
    1878:	82 23       	and	r24, r18
    187a:	87 bb       	out	0x17, r24	; 23
    187c:	08 95       	ret
		}
		break;
	case PC:
		if(Status==OUTPUT)
    187e:	61 30       	cpi	r22, 0x01	; 1
    1880:	59 f4       	brne	.+22     	; 0x1898 <Dio_WriteDirectionChannel+0xaa>
		{
			SET_PIN(DDRC_REG,Pin_num);
    1882:	24 b3       	in	r18, 0x14	; 20
    1884:	81 e0       	ldi	r24, 0x01	; 1
    1886:	90 e0       	ldi	r25, 0x00	; 0
    1888:	02 c0       	rjmp	.+4      	; 0x188e <Dio_WriteDirectionChannel+0xa0>
    188a:	88 0f       	add	r24, r24
    188c:	99 1f       	adc	r25, r25
    188e:	3a 95       	dec	r19
    1890:	e2 f7       	brpl	.-8      	; 0x188a <Dio_WriteDirectionChannel+0x9c>
    1892:	28 2b       	or	r18, r24
    1894:	24 bb       	out	0x14, r18	; 20
    1896:	08 95       	ret
		}
		else if(Status==INPUT)
    1898:	66 23       	and	r22, r22
    189a:	31 f5       	brne	.+76     	; 0x18e8 <Dio_WriteDirectionChannel+0xfa>
		{
			CLEAR_PIN(DDRC_REG,Pin_num);
    189c:	24 b3       	in	r18, 0x14	; 20
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	90 e0       	ldi	r25, 0x00	; 0
    18a2:	02 c0       	rjmp	.+4      	; 0x18a8 <Dio_WriteDirectionChannel+0xba>
    18a4:	88 0f       	add	r24, r24
    18a6:	99 1f       	adc	r25, r25
    18a8:	3a 95       	dec	r19
    18aa:	e2 f7       	brpl	.-8      	; 0x18a4 <Dio_WriteDirectionChannel+0xb6>
    18ac:	80 95       	com	r24
    18ae:	82 23       	and	r24, r18
    18b0:	84 bb       	out	0x14, r24	; 20
    18b2:	08 95       	ret
		}
		break;
	case PD:
		if(Status==OUTPUT)
    18b4:	61 30       	cpi	r22, 0x01	; 1
    18b6:	59 f4       	brne	.+22     	; 0x18ce <Dio_WriteDirectionChannel+0xe0>
		{
			SET_PIN(DDRD_REG,Pin_num);
    18b8:	21 b3       	in	r18, 0x11	; 17
    18ba:	81 e0       	ldi	r24, 0x01	; 1
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	02 c0       	rjmp	.+4      	; 0x18c4 <Dio_WriteDirectionChannel+0xd6>
    18c0:	88 0f       	add	r24, r24
    18c2:	99 1f       	adc	r25, r25
    18c4:	3a 95       	dec	r19
    18c6:	e2 f7       	brpl	.-8      	; 0x18c0 <Dio_WriteDirectionChannel+0xd2>
    18c8:	28 2b       	or	r18, r24
    18ca:	21 bb       	out	0x11, r18	; 17
    18cc:	08 95       	ret
		}
		else if(Status==INPUT)
    18ce:	66 23       	and	r22, r22
    18d0:	59 f4       	brne	.+22     	; 0x18e8 <Dio_WriteDirectionChannel+0xfa>
		{
			CLEAR_PIN(DDRD_REG,Pin_num);
    18d2:	21 b3       	in	r18, 0x11	; 17
    18d4:	81 e0       	ldi	r24, 0x01	; 1
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	02 c0       	rjmp	.+4      	; 0x18de <Dio_WriteDirectionChannel+0xf0>
    18da:	88 0f       	add	r24, r24
    18dc:	99 1f       	adc	r25, r25
    18de:	3a 95       	dec	r19
    18e0:	e2 f7       	brpl	.-8      	; 0x18da <Dio_WriteDirectionChannel+0xec>
    18e2:	80 95       	com	r24
    18e4:	82 23       	and	r24, r18
    18e6:	81 bb       	out	0x11, r24	; 17
    18e8:	08 95       	ret

000018ea <Dio_ReadPort>:
	if(PortId>PD)
	{
		Det_ReportError(DIO_Driver,Instance,Dio_ReadPort_API,DIO_E_PARAM_INVALID_PORT_ID);
	}
#endif
	switch(PortId)
    18ea:	81 30       	cpi	r24, 0x01	; 1
    18ec:	49 f0       	breq	.+18     	; 0x1900 <Dio_ReadPort+0x16>
    18ee:	81 30       	cpi	r24, 0x01	; 1
    18f0:	28 f0       	brcs	.+10     	; 0x18fc <Dio_ReadPort+0x12>
    18f2:	82 30       	cpi	r24, 0x02	; 2
    18f4:	39 f0       	breq	.+14     	; 0x1904 <Dio_ReadPort+0x1a>
    18f6:	83 30       	cpi	r24, 0x03	; 3
    18f8:	41 f4       	brne	.+16     	; 0x190a <Dio_ReadPort+0x20>
    18fa:	06 c0       	rjmp	.+12     	; 0x1908 <Dio_ReadPort+0x1e>
	{
	case PA:
		Level = PORTA_REG;
    18fc:	8b b3       	in	r24, 0x1b	; 27
    18fe:	08 95       	ret
		break;
	case PB:
		Level = PORTB_REG;
    1900:	88 b3       	in	r24, 0x18	; 24
    1902:	08 95       	ret
		break;
	case PC:
		Level = PORTC_REG;
    1904:	85 b3       	in	r24, 0x15	; 21
    1906:	08 95       	ret
		break;
	case PD:
		Level = PORTD_REG;
    1908:	82 b3       	in	r24, 0x12	; 18
		break;
	}
	return Level;
}
    190a:	08 95       	ret

0000190c <Dio_WritePort>:
	if(PortId>PD)
	{
		Det_ReportError(DIO_Driver,Instance,Dio_WritePort_API,DIO_E_PARAM_INVALID_PORT_ID);
	}
#endif
	switch(PortId)
    190c:	81 30       	cpi	r24, 0x01	; 1
    190e:	49 f0       	breq	.+18     	; 0x1922 <Dio_WritePort+0x16>
    1910:	81 30       	cpi	r24, 0x01	; 1
    1912:	28 f0       	brcs	.+10     	; 0x191e <Dio_WritePort+0x12>
    1914:	82 30       	cpi	r24, 0x02	; 2
    1916:	39 f0       	breq	.+14     	; 0x1926 <Dio_WritePort+0x1a>
    1918:	83 30       	cpi	r24, 0x03	; 3
    191a:	41 f4       	brne	.+16     	; 0x192c <Dio_WritePort+0x20>
    191c:	06 c0       	rjmp	.+12     	; 0x192a <Dio_WritePort+0x1e>
	{
	case PA:
		PORTA_REG=Level;
    191e:	6b bb       	out	0x1b, r22	; 27
    1920:	08 95       	ret
		break;
	case PB:
		PORTB_REG=Level;
    1922:	68 bb       	out	0x18, r22	; 24
    1924:	08 95       	ret
		break;
	case PC:
		PORTC_REG=Level;
    1926:	65 bb       	out	0x15, r22	; 21
    1928:	08 95       	ret
		break;
	case PD:
		PORTD_REG=Level;
    192a:	62 bb       	out	0x12, r22	; 18
    192c:	08 95       	ret

0000192e <Dio_WriteDirectionPort>:
	if(PortId>PD)
	{
		Det_ReportError(DIO_Driver,Instance,Dio_WriteDirectionPort_API,DIO_E_PARAM_INVALID_PORT_ID);
	}
#endif
	switch(PortId)
    192e:	81 30       	cpi	r24, 0x01	; 1
    1930:	49 f0       	breq	.+18     	; 0x1944 <Dio_WriteDirectionPort+0x16>
    1932:	81 30       	cpi	r24, 0x01	; 1
    1934:	28 f0       	brcs	.+10     	; 0x1940 <Dio_WriteDirectionPort+0x12>
    1936:	82 30       	cpi	r24, 0x02	; 2
    1938:	39 f0       	breq	.+14     	; 0x1948 <Dio_WriteDirectionPort+0x1a>
    193a:	83 30       	cpi	r24, 0x03	; 3
    193c:	41 f4       	brne	.+16     	; 0x194e <Dio_WriteDirectionPort+0x20>
    193e:	06 c0       	rjmp	.+12     	; 0x194c <Dio_WriteDirectionPort+0x1e>
	{
	case PA:
		DDRA_REG=Status;
    1940:	6a bb       	out	0x1a, r22	; 26
    1942:	08 95       	ret
		break;
	case PB:
		DDRB_REG=Status;
    1944:	67 bb       	out	0x17, r22	; 23
    1946:	08 95       	ret
		break;
	case PC:
		DDRC_REG=Status;
    1948:	64 bb       	out	0x14, r22	; 20
    194a:	08 95       	ret
		break;
	case PD:
		DDRD_REG=Status;
    194c:	61 bb       	out	0x11, r22	; 17
    194e:	08 95       	ret

00001950 <Dio_ReadChannelGroup>:
		break;
	}
}

Dio_PortLevelType Dio_ReadChannelGroup(const Dio_ChannelGroupType* ChannelGroupIdPtr)
{
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	8c 01       	movw	r16, r24
	if(ChannelGroupIdPtr==NULL)
	{
		Det_ReportError(DIO_Driver,Instance,Dio_ReadChannelGroup_API,DIO_E_PARAM_POINTER);
	}
#endif
   Level = (Dio_ReadChannel(ChannelGroupIdPtr->port)& (ChannelGroupIdPtr->mask))
    1956:	fc 01       	movw	r30, r24
    1958:	85 81       	ldd	r24, Z+5	; 0x05
    195a:	0e 94 55 0b 	call	0x16aa	; 0x16aa <Dio_ReadChannel>
    195e:	90 e0       	ldi	r25, 0x00	; 0
    1960:	a0 e0       	ldi	r26, 0x00	; 0
    1962:	b0 e0       	ldi	r27, 0x00	; 0
    1964:	f8 01       	movw	r30, r16
    1966:	20 81       	ld	r18, Z
    1968:	31 81       	ldd	r19, Z+1	; 0x01
    196a:	42 81       	ldd	r20, Z+2	; 0x02
    196c:	53 81       	ldd	r21, Z+3	; 0x03
    196e:	82 23       	and	r24, r18
    1970:	93 23       	and	r25, r19
    1972:	a4 23       	and	r26, r20
    1974:	b5 23       	and	r27, r21
    1976:	04 80       	ldd	r0, Z+4	; 0x04
    1978:	04 c0       	rjmp	.+8      	; 0x1982 <Dio_ReadChannelGroup+0x32>
    197a:	b6 95       	lsr	r27
    197c:	a7 95       	ror	r26
    197e:	97 95       	ror	r25
    1980:	87 95       	ror	r24
    1982:	0a 94       	dec	r0
    1984:	d2 f7       	brpl	.-12     	; 0x197a <Dio_ReadChannelGroup+0x2a>
		   >>(ChannelGroupIdPtr->offset);

	return Level;
}
    1986:	1f 91       	pop	r17
    1988:	0f 91       	pop	r16
    198a:	08 95       	ret

0000198c <Dio_WriteChannelGroup>:

void Dio_WriteChannelGroup(const Dio_ChannelGroupType* ChannelGroupIdPtr,Dio_PortLevelType Level)
{
    198c:	fc 01       	movw	r30, r24
	Dio_WriteChannel(((ChannelGroupIdPtr->port) &(ChannelGroupIdPtr->mask))
    198e:	85 81       	ldd	r24, Z+5	; 0x05
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	a0 e0       	ldi	r26, 0x00	; 0
    1994:	b0 e0       	ldi	r27, 0x00	; 0
    1996:	20 81       	ld	r18, Z
    1998:	31 81       	ldd	r19, Z+1	; 0x01
    199a:	42 81       	ldd	r20, Z+2	; 0x02
    199c:	53 81       	ldd	r21, Z+3	; 0x03
    199e:	82 23       	and	r24, r18
    19a0:	93 23       	and	r25, r19
    19a2:	a4 23       	and	r26, r20
    19a4:	b5 23       	and	r27, r21
    19a6:	04 80       	ldd	r0, Z+4	; 0x04
    19a8:	04 c0       	rjmp	.+8      	; 0x19b2 <Dio_WriteChannelGroup+0x26>
    19aa:	b6 95       	lsr	r27
    19ac:	a7 95       	ror	r26
    19ae:	97 95       	ror	r25
    19b0:	87 95       	ror	r24
    19b2:	0a 94       	dec	r0
    19b4:	d2 f7       	brpl	.-12     	; 0x19aa <Dio_WriteChannelGroup+0x1e>
    19b6:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	{
		Det_ReportError(DIO_Driver,Instance,Dio_WriteChannelGroup_API,DIO_E_PARAM_POINTER);
	}
#endif

}
    19ba:	08 95       	ret

000019bc <Dio_FlipChannel>:
Dio_LevelType Dio_FlipChannel(Dio_ChannelType ChannelId)
{
	Dio_LevelType Level;
	Dio_PortType PortId;
	PortId = ChannelId/NumOfPort;
	u8 Pin_num = ChannelId % NumOfPort ;
    19bc:	38 2f       	mov	r19, r24
    19be:	37 70       	andi	r19, 0x07	; 7
	{
		Det_ReportError(DIO_Driver,Instance,Dio_FlipChannel_API,DIO_E_PARAM_INVALID_CHANNEL_ID);
	}
#endif

	switch(PortId)
    19c0:	86 95       	lsr	r24
    19c2:	86 95       	lsr	r24
    19c4:	86 95       	lsr	r24
    19c6:	81 30       	cpi	r24, 0x01	; 1
    19c8:	99 f0       	breq	.+38     	; 0x19f0 <Dio_FlipChannel+0x34>
    19ca:	81 30       	cpi	r24, 0x01	; 1
    19cc:	28 f0       	brcs	.+10     	; 0x19d8 <Dio_FlipChannel+0x1c>
    19ce:	82 30       	cpi	r24, 0x02	; 2
    19d0:	d9 f0       	breq	.+54     	; 0x1a08 <Dio_FlipChannel+0x4c>
    19d2:	83 30       	cpi	r24, 0x03	; 3
    19d4:	81 f5       	brne	.+96     	; 0x1a36 <Dio_FlipChannel+0x7a>
    19d6:	24 c0       	rjmp	.+72     	; 0x1a20 <Dio_FlipChannel+0x64>
	{
	case PA:
		Level = TOGGLE_PIN(PORTA_REG,Pin_num);
    19d8:	2b b3       	in	r18, 0x1b	; 27
    19da:	81 e0       	ldi	r24, 0x01	; 1
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	02 c0       	rjmp	.+4      	; 0x19e4 <Dio_FlipChannel+0x28>
    19e0:	88 0f       	add	r24, r24
    19e2:	99 1f       	adc	r25, r25
    19e4:	3a 95       	dec	r19
    19e6:	e2 f7       	brpl	.-8      	; 0x19e0 <Dio_FlipChannel+0x24>
    19e8:	28 27       	eor	r18, r24
    19ea:	2b bb       	out	0x1b, r18	; 27
    19ec:	8b b3       	in	r24, 0x1b	; 27
    19ee:	08 95       	ret
		break;
	case PB:
		Level = TOGGLE_PIN(PORTB_REG,Pin_num);
    19f0:	28 b3       	in	r18, 0x18	; 24
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	90 e0       	ldi	r25, 0x00	; 0
    19f6:	02 c0       	rjmp	.+4      	; 0x19fc <Dio_FlipChannel+0x40>
    19f8:	88 0f       	add	r24, r24
    19fa:	99 1f       	adc	r25, r25
    19fc:	3a 95       	dec	r19
    19fe:	e2 f7       	brpl	.-8      	; 0x19f8 <Dio_FlipChannel+0x3c>
    1a00:	28 27       	eor	r18, r24
    1a02:	28 bb       	out	0x18, r18	; 24
    1a04:	88 b3       	in	r24, 0x18	; 24
    1a06:	08 95       	ret
		break;
	case PC:
		Level = TOGGLE_PIN(PORTC_REG,Pin_num);
    1a08:	25 b3       	in	r18, 0x15	; 21
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	90 e0       	ldi	r25, 0x00	; 0
    1a0e:	02 c0       	rjmp	.+4      	; 0x1a14 <Dio_FlipChannel+0x58>
    1a10:	88 0f       	add	r24, r24
    1a12:	99 1f       	adc	r25, r25
    1a14:	3a 95       	dec	r19
    1a16:	e2 f7       	brpl	.-8      	; 0x1a10 <Dio_FlipChannel+0x54>
    1a18:	28 27       	eor	r18, r24
    1a1a:	25 bb       	out	0x15, r18	; 21
    1a1c:	85 b3       	in	r24, 0x15	; 21
    1a1e:	08 95       	ret
		break;
	case PD:
		Level = TOGGLE_PIN(PORTD_REG,Pin_num);
    1a20:	22 b3       	in	r18, 0x12	; 18
    1a22:	81 e0       	ldi	r24, 0x01	; 1
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	02 c0       	rjmp	.+4      	; 0x1a2c <Dio_FlipChannel+0x70>
    1a28:	88 0f       	add	r24, r24
    1a2a:	99 1f       	adc	r25, r25
    1a2c:	3a 95       	dec	r19
    1a2e:	e2 f7       	brpl	.-8      	; 0x1a28 <Dio_FlipChannel+0x6c>
    1a30:	28 27       	eor	r18, r24
    1a32:	22 bb       	out	0x12, r18	; 18
    1a34:	82 b3       	in	r24, 0x12	; 18
		break;
	}
	return Level;
}
    1a36:	08 95       	ret

00001a38 <Dio_Init>:
#endif

//Dio_WriteDirectionChannel(PINA0,ChannelType[PINA0]);

void Dio_Init(void)
{
    1a38:	ff 92       	push	r15
    1a3a:	0f 93       	push	r16
    1a3c:	1f 93       	push	r17
    1a3e:	cf 93       	push	r28
    1a40:	df 93       	push	r29
    1a42:	ff 24       	eor	r15, r15
    1a44:	c0 e0       	ldi	r28, 0x00	; 0
    1a46:	d0 e0       	ldi	r29, 0x00	; 0
	Dio_ChannelType ChannelId;
	for(ChannelId=PINA0_;ChannelId<TOTAL_PINS;ChannelId++)
	{
		Dio_WriteDirectionChannel(ChannelId,ChannelStatus[ChannelId]);
    1a48:	0f 2d       	mov	r16, r15
    1a4a:	10 e0       	ldi	r17, 0x00	; 0
    1a4c:	f8 01       	movw	r30, r16
    1a4e:	ee 50       	subi	r30, 0x0E	; 14
    1a50:	fe 4f       	sbci	r31, 0xFE	; 254
    1a52:	8f 2d       	mov	r24, r15
    1a54:	60 81       	ld	r22, Z
    1a56:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <Dio_WriteDirectionChannel>
		Dio_WriteChannel(ChannelId,ChannelLevel[ChannelId]);
    1a5a:	0e 5e       	subi	r16, 0xEE	; 238
    1a5c:	1d 4f       	sbci	r17, 0xFD	; 253
    1a5e:	8f 2d       	mov	r24, r15
    1a60:	f8 01       	movw	r30, r16
    1a62:	60 81       	ld	r22, Z
    1a64:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
//Dio_WriteDirectionChannel(PINA0,ChannelType[PINA0]);

void Dio_Init(void)
{
	Dio_ChannelType ChannelId;
	for(ChannelId=PINA0_;ChannelId<TOTAL_PINS;ChannelId++)
    1a68:	f3 94       	inc	r15
    1a6a:	21 96       	adiw	r28, 0x01	; 1
    1a6c:	c0 32       	cpi	r28, 0x20	; 32
    1a6e:	d1 05       	cpc	r29, r1
    1a70:	59 f7       	brne	.-42     	; 0x1a48 <Dio_Init+0x10>
	{
		Dio_WriteDirectionChannel(ChannelId,ChannelStatus[ChannelId]);
		Dio_WriteChannel(ChannelId,ChannelLevel[ChannelId]);
	}

}
    1a72:	df 91       	pop	r29
    1a74:	cf 91       	pop	r28
    1a76:	1f 91       	pop	r17
    1a78:	0f 91       	pop	r16
    1a7a:	ff 90       	pop	r15
    1a7c:	08 95       	ret

00001a7e <MotorOff>:
	Dio_WriteChannel(MotorPtrConfig->Channel1,!(MotorPtrConfig->Level));
	Dio_WriteChannel(MotorPtrConfig->Channel2,MotorPtrConfig->Level);
}

void MotorOff(Motor_t *MotorPtrConfig)
{
    1a7e:	cf 93       	push	r28
    1a80:	df 93       	push	r29
    1a82:	ec 01       	movw	r28, r24
	Dio_WriteChannel(MotorPtrConfig->Channel1,!(MotorPtrConfig->Level));
    1a84:	60 e0       	ldi	r22, 0x00	; 0
    1a86:	8a 81       	ldd	r24, Y+2	; 0x02
    1a88:	88 23       	and	r24, r24
    1a8a:	09 f4       	brne	.+2      	; 0x1a8e <MotorOff+0x10>
    1a8c:	61 e0       	ldi	r22, 0x01	; 1
    1a8e:	88 81       	ld	r24, Y
    1a90:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(MotorPtrConfig->Channel2,!(MotorPtrConfig->Level));
    1a94:	60 e0       	ldi	r22, 0x00	; 0
    1a96:	8a 81       	ldd	r24, Y+2	; 0x02
    1a98:	88 23       	and	r24, r24
    1a9a:	09 f4       	brne	.+2      	; 0x1a9e <MotorOff+0x20>
    1a9c:	61 e0       	ldi	r22, 0x01	; 1
    1a9e:	89 81       	ldd	r24, Y+1	; 0x01
    1aa0:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
}
    1aa4:	df 91       	pop	r29
    1aa6:	cf 91       	pop	r28
    1aa8:	08 95       	ret

00001aaa <MotorDirectionAntiClockWise>:
	Dio_WriteChannel(MotorPtrConfig->Channel2,!(MotorPtrConfig->Level));
	Dio_WriteChannel(MotorPtrConfig->Channel1,MotorPtrConfig->Level);

}
void MotorDirectionAntiClockWise(Motor_t *MotorPtrConfig)
{
    1aaa:	cf 93       	push	r28
    1aac:	df 93       	push	r29
    1aae:	ec 01       	movw	r28, r24
	Dio_WriteChannel(MotorPtrConfig->Channel1,!(MotorPtrConfig->Level));
    1ab0:	60 e0       	ldi	r22, 0x00	; 0
    1ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab4:	88 23       	and	r24, r24
    1ab6:	09 f4       	brne	.+2      	; 0x1aba <MotorDirectionAntiClockWise+0x10>
    1ab8:	61 e0       	ldi	r22, 0x01	; 1
    1aba:	88 81       	ld	r24, Y
    1abc:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(MotorPtrConfig->Channel2,MotorPtrConfig->Level);
    1ac0:	89 81       	ldd	r24, Y+1	; 0x01
    1ac2:	6a 81       	ldd	r22, Y+2	; 0x02
    1ac4:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
}
    1ac8:	df 91       	pop	r29
    1aca:	cf 91       	pop	r28
    1acc:	08 95       	ret

00001ace <MotorDirectionClockWise>:

#include "motor.h"
#include "E:\1\NTI\AVR\AVR\RTOS\MCAL\GPIO\Dio.h"

void MotorDirectionClockWise(Motor_t *MotorPtrConfig)
{
    1ace:	cf 93       	push	r28
    1ad0:	df 93       	push	r29
    1ad2:	ec 01       	movw	r28, r24

	Dio_WriteChannel(MotorPtrConfig->Channel2,!(MotorPtrConfig->Level));
    1ad4:	60 e0       	ldi	r22, 0x00	; 0
    1ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad8:	88 23       	and	r24, r24
    1ada:	09 f4       	brne	.+2      	; 0x1ade <MotorDirectionClockWise+0x10>
    1adc:	61 e0       	ldi	r22, 0x01	; 1
    1ade:	89 81       	ldd	r24, Y+1	; 0x01
    1ae0:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(MotorPtrConfig->Channel1,MotorPtrConfig->Level);
    1ae4:	88 81       	ld	r24, Y
    1ae6:	6a 81       	ldd	r22, Y+2	; 0x02
    1ae8:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>

}
    1aec:	df 91       	pop	r29
    1aee:	cf 91       	pop	r28
    1af0:	08 95       	ret

00001af2 <SwitchStatus>:
#include "Switch_Cfg.h"
#include "Std_Types.h"

#if(Mode==Pullup)
Std_ReturnType SwitchStatus(Switch_t *SwtichPtrConfig)
{
    1af2:	0f 93       	push	r16
    1af4:	1f 93       	push	r17
    1af6:	8c 01       	movw	r16, r24
	Std_ReturnType Return;
	SwtichPtrConfig->Level=Dio_ReadChannel(SwtichPtrConfig->Channel);
    1af8:	fc 01       	movw	r30, r24
    1afa:	80 81       	ld	r24, Z
    1afc:	0e 94 55 0b 	call	0x16aa	; 0x16aa <Dio_ReadChannel>
    1b00:	f8 01       	movw	r30, r16
    1b02:	81 83       	std	Z+1, r24	; 0x01
    1b04:	90 e0       	ldi	r25, 0x00	; 0
    1b06:	88 23       	and	r24, r24
    1b08:	09 f4       	brne	.+2      	; 0x1b0c <SwitchStatus+0x1a>
    1b0a:	91 e0       	ldi	r25, 0x01	; 1
	{
		Return = E_OK;
	}

	return Return;
}
    1b0c:	89 2f       	mov	r24, r25
    1b0e:	1f 91       	pop	r17
    1b10:	0f 91       	pop	r16
    1b12:	08 95       	ret

00001b14 <LedToggle>:

}
#endif

void LedToggle(LED_t *LedPtrConfig)
{
    1b14:	0f 93       	push	r16
    1b16:	1f 93       	push	r17
    1b18:	8c 01       	movw	r16, r24
	//LedPtrConfig->Level=STD_HIGH;
	LedPtrConfig->Level=Dio_FlipChannel(LedPtrConfig->Channel);
    1b1a:	fc 01       	movw	r30, r24
    1b1c:	80 81       	ld	r24, Z
    1b1e:	0e 94 de 0c 	call	0x19bc	; 0x19bc <Dio_FlipChannel>
    1b22:	f8 01       	movw	r30, r16
    1b24:	81 83       	std	Z+1, r24	; 0x01
}
    1b26:	1f 91       	pop	r17
    1b28:	0f 91       	pop	r16
    1b2a:	08 95       	ret

00001b2c <LedOff>:
{
	LedPtrConfig->Level=STD_HIGH;
	Dio_WriteChannel(LedPtrConfig->Channel,LedPtrConfig->Level);
}
void LedOff(LED_t *LedPtrConfig)
{
    1b2c:	fc 01       	movw	r30, r24
	LedPtrConfig->Level=STD_LOW;
    1b2e:	11 82       	std	Z+1, r1	; 0x01
	Dio_WriteChannel(LedPtrConfig->Channel,LedPtrConfig->Level);
    1b30:	80 81       	ld	r24, Z
    1b32:	60 e0       	ldi	r22, 0x00	; 0
    1b34:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>

}
    1b38:	08 95       	ret

00001b3a <LedOn>:
#include "LED_Cfg.h"
#include "LED.h"

#if(MODE==ActiveHigh)
void LedOn(LED_t *LedPtrConfig)
{
    1b3a:	fc 01       	movw	r30, r24
	LedPtrConfig->Level=STD_HIGH;
    1b3c:	81 e0       	ldi	r24, 0x01	; 1
    1b3e:	81 83       	std	Z+1, r24	; 0x01
	Dio_WriteChannel(LedPtrConfig->Channel,LedPtrConfig->Level);
    1b40:	80 81       	ld	r24, Z
    1b42:	61 e0       	ldi	r22, 0x01	; 1
    1b44:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
}
    1b48:	08 95       	ret

00001b4a <LCD_WriteHalfPort>:
	_delay_ms(2);
}

#elif LcdMode == BIT_4_MODE
static void LCD_WriteHalfPort(u8 data)
{
    1b4a:	1f 93       	push	r17
    1b4c:	18 2f       	mov	r17, r24
	Dio_WriteChannel(D4,READ_BIT(data,0));
    1b4e:	68 2f       	mov	r22, r24
    1b50:	61 70       	andi	r22, 0x01	; 1
    1b52:	83 e0       	ldi	r24, 0x03	; 3
    1b54:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(D5,READ_BIT(data,1));
    1b58:	61 2f       	mov	r22, r17
    1b5a:	66 95       	lsr	r22
    1b5c:	61 70       	andi	r22, 0x01	; 1
    1b5e:	84 e0       	ldi	r24, 0x04	; 4
    1b60:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(D6,READ_BIT(data,2));
    1b64:	16 95       	lsr	r17
    1b66:	16 95       	lsr	r17
    1b68:	61 2f       	mov	r22, r17
    1b6a:	61 70       	andi	r22, 0x01	; 1
    1b6c:	85 e0       	ldi	r24, 0x05	; 5
    1b6e:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(D7,READ_BIT(data,3));
    1b72:	16 95       	lsr	r17
    1b74:	11 70       	andi	r17, 0x01	; 1
    1b76:	86 e0       	ldi	r24, 0x06	; 6
    1b78:	61 2f       	mov	r22, r17
    1b7a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>

}
    1b7e:	1f 91       	pop	r17
    1b80:	08 95       	ret

00001b82 <LCD_WriteData>:
	Dio_WriteChannel(E,STD_LOW);
	_delay_ms(1);
}

void LCD_WriteData(u8 Data)
{
    1b82:	ff 92       	push	r15
    1b84:	0f 93       	push	r16
    1b86:	1f 93       	push	r17
    1b88:	f8 2e       	mov	r15, r24
	Dio_WriteChannel(RS,STD_HIGH);
    1b8a:	80 e0       	ldi	r24, 0x00	; 0
    1b8c:	61 e0       	ldi	r22, 0x01	; 1
    1b8e:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(RW,STD_LOW);
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	60 e0       	ldi	r22, 0x00	; 0
    1b96:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(E,STD_HIGH);
    1b9a:	82 e0       	ldi	r24, 0x02	; 2
    1b9c:	61 e0       	ldi	r22, 0x01	; 1
    1b9e:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	LCD_WriteHalfPort(Data>>4);
    1ba2:	8f 2d       	mov	r24, r15
    1ba4:	82 95       	swap	r24
    1ba6:	8f 70       	andi	r24, 0x0F	; 15
    1ba8:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <LCD_WriteHalfPort>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1bac:	00 ed       	ldi	r16, 0xD0	; 208
    1bae:	17 e0       	ldi	r17, 0x07	; 7
    1bb0:	c8 01       	movw	r24, r16
    1bb2:	01 97       	sbiw	r24, 0x01	; 1
    1bb4:	f1 f7       	brne	.-4      	; 0x1bb2 <LCD_WriteData+0x30>
	_delay_ms(1);
	Dio_WriteChannel(E,STD_LOW);
    1bb6:	82 e0       	ldi	r24, 0x02	; 2
    1bb8:	60 e0       	ldi	r22, 0x00	; 0
    1bba:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
    1bbe:	c8 01       	movw	r24, r16
    1bc0:	01 97       	sbiw	r24, 0x01	; 1
    1bc2:	f1 f7       	brne	.-4      	; 0x1bc0 <LCD_WriteData+0x3e>
	_delay_ms(1);
	Dio_WriteChannel(E,STD_HIGH);
    1bc4:	82 e0       	ldi	r24, 0x02	; 2
    1bc6:	61 e0       	ldi	r22, 0x01	; 1
    1bc8:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	LCD_WriteHalfPort(Data);
    1bcc:	8f 2d       	mov	r24, r15
    1bce:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <LCD_WriteHalfPort>
    1bd2:	c8 01       	movw	r24, r16
    1bd4:	01 97       	sbiw	r24, 0x01	; 1
    1bd6:	f1 f7       	brne	.-4      	; 0x1bd4 <LCD_WriteData+0x52>
	_delay_ms(1);
	Dio_WriteChannel(E,STD_LOW);
    1bd8:	82 e0       	ldi	r24, 0x02	; 2
    1bda:	60 e0       	ldi	r22, 0x00	; 0
    1bdc:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
    1be0:	c8 01       	movw	r24, r16
    1be2:	01 97       	sbiw	r24, 0x01	; 1
    1be4:	f1 f7       	brne	.-4      	; 0x1be2 <LCD_WriteData+0x60>
	_delay_ms(1);
}
    1be6:	1f 91       	pop	r17
    1be8:	0f 91       	pop	r16
    1bea:	ff 90       	pop	r15
    1bec:	08 95       	ret

00001bee <LCD_WriteCommand>:
	Dio_WriteChannel(D7,READ_BIT(data,3));

}

void LCD_WriteCommand(u8 Data)
{
    1bee:	ff 92       	push	r15
    1bf0:	0f 93       	push	r16
    1bf2:	1f 93       	push	r17
    1bf4:	f8 2e       	mov	r15, r24
	Dio_WriteChannel(RS,STD_LOW);
    1bf6:	80 e0       	ldi	r24, 0x00	; 0
    1bf8:	60 e0       	ldi	r22, 0x00	; 0
    1bfa:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(RW,STD_LOW);
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	60 e0       	ldi	r22, 0x00	; 0
    1c02:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(E,STD_HIGH);
    1c06:	82 e0       	ldi	r24, 0x02	; 2
    1c08:	61 e0       	ldi	r22, 0x01	; 1
    1c0a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	LCD_WriteHalfPort(Data>>4);
    1c0e:	8f 2d       	mov	r24, r15
    1c10:	82 95       	swap	r24
    1c12:	8f 70       	andi	r24, 0x0F	; 15
    1c14:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <LCD_WriteHalfPort>
    1c18:	00 ed       	ldi	r16, 0xD0	; 208
    1c1a:	17 e0       	ldi	r17, 0x07	; 7
    1c1c:	c8 01       	movw	r24, r16
    1c1e:	01 97       	sbiw	r24, 0x01	; 1
    1c20:	f1 f7       	brne	.-4      	; 0x1c1e <LCD_WriteCommand+0x30>
	_delay_ms(1);
	Dio_WriteChannel(E,STD_LOW);
    1c22:	82 e0       	ldi	r24, 0x02	; 2
    1c24:	60 e0       	ldi	r22, 0x00	; 0
    1c26:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
    1c2a:	c8 01       	movw	r24, r16
    1c2c:	01 97       	sbiw	r24, 0x01	; 1
    1c2e:	f1 f7       	brne	.-4      	; 0x1c2c <LCD_WriteCommand+0x3e>
	_delay_ms(1);
	Dio_WriteChannel(E,STD_HIGH);
    1c30:	82 e0       	ldi	r24, 0x02	; 2
    1c32:	61 e0       	ldi	r22, 0x01	; 1
    1c34:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	LCD_WriteHalfPort(Data);
    1c38:	8f 2d       	mov	r24, r15
    1c3a:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <LCD_WriteHalfPort>
    1c3e:	c8 01       	movw	r24, r16
    1c40:	01 97       	sbiw	r24, 0x01	; 1
    1c42:	f1 f7       	brne	.-4      	; 0x1c40 <LCD_WriteCommand+0x52>
	_delay_ms(1);
	Dio_WriteChannel(E,STD_LOW);
    1c44:	82 e0       	ldi	r24, 0x02	; 2
    1c46:	60 e0       	ldi	r22, 0x00	; 0
    1c48:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
    1c4c:	c8 01       	movw	r24, r16
    1c4e:	01 97       	sbiw	r24, 0x01	; 1
    1c50:	f1 f7       	brne	.-4      	; 0x1c4e <LCD_WriteCommand+0x60>
	_delay_ms(1);
}
    1c52:	1f 91       	pop	r17
    1c54:	0f 91       	pop	r16
    1c56:	ff 90       	pop	r15
    1c58:	08 95       	ret

00001c5a <LCD_init>:
	Dio_WriteChannel(E,STD_LOW);
	_delay_ms(1);
}

void LCD_init(void)
{
    1c5a:	0f 93       	push	r16
    1c5c:	1f 93       	push	r17
    1c5e:	84 ef       	ldi	r24, 0xF4	; 244
    1c60:	91 e0       	ldi	r25, 0x01	; 1
    1c62:	28 ec       	ldi	r18, 0xC8	; 200
    1c64:	30 e0       	ldi	r19, 0x00	; 0
    1c66:	f9 01       	movw	r30, r18
    1c68:	31 97       	sbiw	r30, 0x01	; 1
    1c6a:	f1 f7       	brne	.-4      	; 0x1c68 <LCD_init+0xe>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c6c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c6e:	d9 f7       	brne	.-10     	; 0x1c66 <LCD_init+0xc>
	_delay_ms(50);
	Dio_WriteChannel(RS,STD_LOW);
    1c70:	80 e0       	ldi	r24, 0x00	; 0
    1c72:	60 e0       	ldi	r22, 0x00	; 0
    1c74:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(RW,STD_LOW);
    1c78:	81 e0       	ldi	r24, 0x01	; 1
    1c7a:	60 e0       	ldi	r22, 0x00	; 0
    1c7c:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	Dio_WriteChannel(E,STD_HIGH);
    1c80:	82 e0       	ldi	r24, 0x02	; 2
    1c82:	61 e0       	ldi	r22, 0x01	; 1
    1c84:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
	LCD_WriteHalfPort(0x02);
    1c88:	82 e0       	ldi	r24, 0x02	; 2
    1c8a:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <LCD_WriteHalfPort>
    1c8e:	00 ed       	ldi	r16, 0xD0	; 208
    1c90:	17 e0       	ldi	r17, 0x07	; 7
    1c92:	c8 01       	movw	r24, r16
    1c94:	01 97       	sbiw	r24, 0x01	; 1
    1c96:	f1 f7       	brne	.-4      	; 0x1c94 <LCD_init+0x3a>
	_delay_ms(1);
	Dio_WriteChannel(E,STD_LOW);
    1c98:	82 e0       	ldi	r24, 0x02	; 2
    1c9a:	60 e0       	ldi	r22, 0x00	; 0
    1c9c:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
    1ca0:	c8 01       	movw	r24, r16
    1ca2:	01 97       	sbiw	r24, 0x01	; 1
    1ca4:	f1 f7       	brne	.-4      	; 0x1ca2 <LCD_init+0x48>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1ca6:	15 e8       	ldi	r17, 0x85	; 133
    1ca8:	81 2f       	mov	r24, r17
    1caa:	8a 95       	dec	r24
    1cac:	f1 f7       	brne	.-4      	; 0x1caa <LCD_init+0x50>
	_delay_ms(1);
	_delay_us(50);
	LCD_WriteCommand(0x28);
    1cae:	88 e2       	ldi	r24, 0x28	; 40
    1cb0:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
    1cb4:	81 2f       	mov	r24, r17
    1cb6:	8a 95       	dec	r24
    1cb8:	f1 f7       	brne	.-4      	; 0x1cb6 <LCD_init+0x5c>
	_delay_us(50);
	LCD_WriteCommand(0x0c);
    1cba:	8c e0       	ldi	r24, 0x0C	; 12
    1cbc:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
    1cc0:	1a 95       	dec	r17
    1cc2:	f1 f7       	brne	.-4      	; 0x1cc0 <LCD_init+0x66>
	_delay_us(50);
	LCD_WriteCommand(0x1);
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1cca:	00 ea       	ldi	r16, 0xA0	; 160
    1ccc:	1f e0       	ldi	r17, 0x0F	; 15
    1cce:	c8 01       	movw	r24, r16
    1cd0:	01 97       	sbiw	r24, 0x01	; 1
    1cd2:	f1 f7       	brne	.-4      	; 0x1cd0 <LCD_init+0x76>
	_delay_ms(2);
	LCD_WriteCommand(0x6);
    1cd4:	86 e0       	ldi	r24, 0x06	; 6
    1cd6:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
    1cda:	c8 01       	movw	r24, r16
    1cdc:	01 97       	sbiw	r24, 0x01	; 1
    1cde:	f1 f7       	brne	.-4      	; 0x1cdc <LCD_init+0x82>
	_delay_ms(2);
}
    1ce0:	1f 91       	pop	r17
    1ce2:	0f 91       	pop	r16
    1ce4:	08 95       	ret

00001ce6 <LCD_WriteFloatNum>:
	LCD_WriteData(address);
}

void LCD_WriteFloatNum(f32 num)
{
}
    1ce6:	08 95       	ret

00001ce8 <LCD_Clear>:

}

void LCD_Clear(void)
{
	LCD_WriteCommand(0x01);
    1ce8:	81 e0       	ldi	r24, 0x01	; 1
    1cea:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
}
    1cee:	08 95       	ret

00001cf0 <LCD_CursorMove>:
	}
}

void LCD_CursorMove(u8 row,u8 col)
{
	if(row==1)
    1cf0:	81 30       	cpi	r24, 0x01	; 1
    1cf2:	19 f4       	brne	.+6      	; 0x1cfa <LCD_CursorMove+0xa>
	{
		LCD_WriteCommand(col+0x80);
    1cf4:	86 2f       	mov	r24, r22
    1cf6:	80 58       	subi	r24, 0x80	; 128
    1cf8:	09 c0       	rjmp	.+18     	; 0x1d0c <LCD_CursorMove+0x1c>
	}
	else if(row==2)
    1cfa:	82 30       	cpi	r24, 0x02	; 2
    1cfc:	19 f4       	brne	.+6      	; 0x1d04 <LCD_CursorMove+0x14>
	{
		LCD_WriteCommand(col+0x40+0x80);
    1cfe:	86 2f       	mov	r24, r22
    1d00:	80 54       	subi	r24, 0x40	; 64
    1d02:	04 c0       	rjmp	.+8      	; 0x1d0c <LCD_CursorMove+0x1c>
	}
	else if(row==3)
    1d04:	83 30       	cpi	r24, 0x03	; 3
    1d06:	29 f4       	brne	.+10     	; 0x1d12 <LCD_CursorMove+0x22>
	{
		LCD_WriteCommand(col+0X10+0x80);
    1d08:	86 2f       	mov	r24, r22
    1d0a:	80 57       	subi	r24, 0x70	; 112
    1d0c:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
    1d10:	08 95       	ret
	}
	else if(row==4)
    1d12:	84 30       	cpi	r24, 0x04	; 4
    1d14:	21 f4       	brne	.+8      	; 0x1d1e <LCD_CursorMove+0x2e>
	{
		LCD_WriteCommand(col+0X50+0x80);
    1d16:	86 2f       	mov	r24, r22
    1d18:	80 53       	subi	r24, 0x30	; 48
    1d1a:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
    1d1e:	08 95       	ret

00001d20 <LCD_DrowPattarn>:
	LCD_WriteData(((num%10)/1)+'0');

}

void LCD_DrowPattarn(u8 * pattarn,u8 address,u8 row,u8 col)
{
    1d20:	df 92       	push	r13
    1d22:	ef 92       	push	r14
    1d24:	ff 92       	push	r15
    1d26:	0f 93       	push	r16
    1d28:	1f 93       	push	r17
    1d2a:	cf 93       	push	r28
    1d2c:	df 93       	push	r29
    1d2e:	8c 01       	movw	r16, r24
    1d30:	f6 2e       	mov	r15, r22
    1d32:	e4 2e       	mov	r14, r20
    1d34:	d2 2e       	mov	r13, r18
	LCD_WriteCommand(0x40+address*8);
    1d36:	86 2f       	mov	r24, r22
    1d38:	88 0f       	add	r24, r24
    1d3a:	88 0f       	add	r24, r24
    1d3c:	88 0f       	add	r24, r24
    1d3e:	80 5c       	subi	r24, 0xC0	; 192
    1d40:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <LCD_WriteCommand>
    1d44:	c0 e0       	ldi	r28, 0x00	; 0
    1d46:	d0 e0       	ldi	r29, 0x00	; 0
	for(u8 i =0 ;i<8;i++)
	{
		LCD_WriteData(pattarn[i]);
    1d48:	f8 01       	movw	r30, r16
    1d4a:	ec 0f       	add	r30, r28
    1d4c:	fd 1f       	adc	r31, r29
    1d4e:	80 81       	ld	r24, Z
    1d50:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
    1d54:	21 96       	adiw	r28, 0x01	; 1
}

void LCD_DrowPattarn(u8 * pattarn,u8 address,u8 row,u8 col)
{
	LCD_WriteCommand(0x40+address*8);
	for(u8 i =0 ;i<8;i++)
    1d56:	c8 30       	cpi	r28, 0x08	; 8
    1d58:	d1 05       	cpc	r29, r1
    1d5a:	b1 f7       	brne	.-20     	; 0x1d48 <LCD_DrowPattarn+0x28>
	{
		LCD_WriteData(pattarn[i]);
	}
	LCD_CursorMove(row,col);
    1d5c:	8e 2d       	mov	r24, r14
    1d5e:	6d 2d       	mov	r22, r13
    1d60:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <LCD_CursorMove>
	LCD_WriteData(address);
    1d64:	8f 2d       	mov	r24, r15
    1d66:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
}
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	ff 90       	pop	r15
    1d74:	ef 90       	pop	r14
    1d76:	df 90       	pop	r13
    1d78:	08 95       	ret

00001d7a <LCD_WriteNum_2D>:
	LCD_WriteData(((num%10)/1)+'0');

}

void LCD_WriteNum_2D(u16 num)
{
    1d7a:	0f 93       	push	r16
    1d7c:	1f 93       	push	r17
    1d7e:	8c 01       	movw	r16, r24
	LCD_WriteData(((num%100)/10)+'0');
    1d80:	64 e6       	ldi	r22, 0x64	; 100
    1d82:	70 e0       	ldi	r23, 0x00	; 0
    1d84:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1d88:	6a e0       	ldi	r22, 0x0A	; 10
    1d8a:	70 e0       	ldi	r23, 0x00	; 0
    1d8c:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1d90:	86 2f       	mov	r24, r22
    1d92:	80 5d       	subi	r24, 0xD0	; 208
    1d94:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
	LCD_WriteData(((num%10)/1)+'0');
    1d98:	c8 01       	movw	r24, r16
    1d9a:	6a e0       	ldi	r22, 0x0A	; 10
    1d9c:	70 e0       	ldi	r23, 0x00	; 0
    1d9e:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1da2:	80 5d       	subi	r24, 0xD0	; 208
    1da4:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>

}
    1da8:	1f 91       	pop	r17
    1daa:	0f 91       	pop	r16
    1dac:	08 95       	ret

00001dae <LCD_WriteNum_4D>:


}

void LCD_WriteNum_4D(u16 num)
{
    1dae:	0f 93       	push	r16
    1db0:	1f 93       	push	r17
    1db2:	8c 01       	movw	r16, r24
	LCD_WriteData(((num%10000)/1000)+'0');
    1db4:	60 e1       	ldi	r22, 0x10	; 16
    1db6:	77 e2       	ldi	r23, 0x27	; 39
    1db8:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1dbc:	68 ee       	ldi	r22, 0xE8	; 232
    1dbe:	73 e0       	ldi	r23, 0x03	; 3
    1dc0:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1dc4:	86 2f       	mov	r24, r22
    1dc6:	80 5d       	subi	r24, 0xD0	; 208
    1dc8:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
	LCD_WriteData(((num%1000)/100)+'0');
    1dcc:	c8 01       	movw	r24, r16
    1dce:	68 ee       	ldi	r22, 0xE8	; 232
    1dd0:	73 e0       	ldi	r23, 0x03	; 3
    1dd2:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1dd6:	64 e6       	ldi	r22, 0x64	; 100
    1dd8:	70 e0       	ldi	r23, 0x00	; 0
    1dda:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1dde:	86 2f       	mov	r24, r22
    1de0:	80 5d       	subi	r24, 0xD0	; 208
    1de2:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
	LCD_WriteData(((num%100)/10)+'0');
    1de6:	c8 01       	movw	r24, r16
    1de8:	64 e6       	ldi	r22, 0x64	; 100
    1dea:	70 e0       	ldi	r23, 0x00	; 0
    1dec:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1df0:	6a e0       	ldi	r22, 0x0A	; 10
    1df2:	70 e0       	ldi	r23, 0x00	; 0
    1df4:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1df8:	86 2f       	mov	r24, r22
    1dfa:	80 5d       	subi	r24, 0xD0	; 208
    1dfc:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
	LCD_WriteData(((num%10)/1)+'0');
    1e00:	c8 01       	movw	r24, r16
    1e02:	6a e0       	ldi	r22, 0x0A	; 10
    1e04:	70 e0       	ldi	r23, 0x00	; 0
    1e06:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__udivmodhi4>
    1e0a:	80 5d       	subi	r24, 0xD0	; 208
    1e0c:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>

}
    1e10:	1f 91       	pop	r17
    1e12:	0f 91       	pop	r16
    1e14:	08 95       	ret

00001e16 <LCD_WriteNumInBinary>:
	 */

}

void LCD_WriteNumInBinary(u8 num)
{
    1e16:	ef 92       	push	r14
    1e18:	ff 92       	push	r15
    1e1a:	1f 93       	push	r17
    1e1c:	df 93       	push	r29
    1e1e:	cf 93       	push	r28
    1e20:	cd b7       	in	r28, 0x3d	; 61
    1e22:	de b7       	in	r29, 0x3e	; 62
    1e24:	a0 97       	sbiw	r28, 0x20	; 32
    1e26:	0f b6       	in	r0, 0x3f	; 63
    1e28:	f8 94       	cli
    1e2a:	de bf       	out	0x3e, r29	; 62
    1e2c:	0f be       	out	0x3f, r0	; 63
    1e2e:	cd bf       	out	0x3d, r28	; 61
    1e30:	38 2f       	mov	r19, r24
	u8 rem = 0;
	u8 i = 0;
	u16 arr[16]={0};
	u8 j = 0;

	if(num>0)
    1e32:	88 23       	and	r24, r24
    1e34:	59 f1       	breq	.+86     	; 0x1e8c <LCD_WriteNumInBinary+0x76>

void LCD_WriteNumInBinary(u8 num)
{
	u8 rem = 0;
	u8 i = 0;
	u16 arr[16]={0};
    1e36:	fe 01       	movw	r30, r28
    1e38:	31 96       	adiw	r30, 0x01	; 1
    1e3a:	80 e2       	ldi	r24, 0x20	; 32
    1e3c:	df 01       	movw	r26, r30
    1e3e:	1d 92       	st	X+, r1
    1e40:	8a 95       	dec	r24
    1e42:	e9 f7       	brne	.-6      	; 0x1e3e <LCD_WriteNumInBinary+0x28>
    1e44:	20 e0       	ldi	r18, 0x00	; 0
	if(num>0)
	{
		while(num>0)
		{
			rem=num%2;
			arr[i]=rem+'0';
    1e46:	af 01       	movw	r20, r30
    1e48:	e2 2f       	mov	r30, r18
    1e4a:	f0 e0       	ldi	r31, 0x00	; 0
    1e4c:	ee 0f       	add	r30, r30
    1e4e:	ff 1f       	adc	r31, r31
    1e50:	e4 0f       	add	r30, r20
    1e52:	f5 1f       	adc	r31, r21
    1e54:	83 2f       	mov	r24, r19
    1e56:	81 70       	andi	r24, 0x01	; 1
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	c0 96       	adiw	r24, 0x30	; 48
    1e5c:	91 83       	std	Z+1, r25	; 0x01
    1e5e:	80 83       	st	Z, r24
			i++;
    1e60:	2f 5f       	subi	r18, 0xFF	; 255
			num=num/2;
    1e62:	36 95       	lsr	r19
	u16 arr[16]={0};
	u8 j = 0;

	if(num>0)
	{
		while(num>0)
    1e64:	89 f7       	brne	.-30     	; 0x1e48 <LCD_WriteNumInBinary+0x32>
    1e66:	12 2f       	mov	r17, r18
			i++;
			num=num/2;
		}
		for( j=i;j>0;j--)
		{
			LCD_WriteData(arr[j-1]);
    1e68:	7e 01       	movw	r14, r28
    1e6a:	08 94       	sec
    1e6c:	e1 1c       	adc	r14, r1
    1e6e:	f1 1c       	adc	r15, r1
    1e70:	0b c0       	rjmp	.+22     	; 0x1e88 <LCD_WriteNumInBinary+0x72>
    1e72:	e1 2f       	mov	r30, r17
    1e74:	f0 e0       	ldi	r31, 0x00	; 0
    1e76:	31 97       	sbiw	r30, 0x01	; 1
    1e78:	ee 0f       	add	r30, r30
    1e7a:	ff 1f       	adc	r31, r31
    1e7c:	ee 0d       	add	r30, r14
    1e7e:	ff 1d       	adc	r31, r15
    1e80:	80 81       	ld	r24, Z
    1e82:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
			rem=num%2;
			arr[i]=rem+'0';
			i++;
			num=num/2;
		}
		for( j=i;j>0;j--)
    1e86:	11 50       	subi	r17, 0x01	; 1
    1e88:	11 23       	and	r17, r17
    1e8a:	99 f7       	brne	.-26     	; 0x1e72 <LCD_WriteNumInBinary+0x5c>
	}




}
    1e8c:	a0 96       	adiw	r28, 0x20	; 32
    1e8e:	0f b6       	in	r0, 0x3f	; 63
    1e90:	f8 94       	cli
    1e92:	de bf       	out	0x3e, r29	; 62
    1e94:	0f be       	out	0x3f, r0	; 63
    1e96:	cd bf       	out	0x3d, r28	; 61
    1e98:	cf 91       	pop	r28
    1e9a:	df 91       	pop	r29
    1e9c:	1f 91       	pop	r17
    1e9e:	ff 90       	pop	r15
    1ea0:	ef 90       	pop	r14
    1ea2:	08 95       	ret

00001ea4 <LCD_WriteNum>:
{
	LCD_WriteCommand(0x01);
}

void LCD_WriteNum(s16 num)
{
    1ea4:	cf 92       	push	r12
    1ea6:	df 92       	push	r13
    1ea8:	ef 92       	push	r14
    1eaa:	ff 92       	push	r15
    1eac:	0f 93       	push	r16
    1eae:	1f 93       	push	r17
    1eb0:	df 93       	push	r29
    1eb2:	cf 93       	push	r28
    1eb4:	cd b7       	in	r28, 0x3d	; 61
    1eb6:	de b7       	in	r29, 0x3e	; 62
    1eb8:	a0 97       	sbiw	r28, 0x20	; 32
    1eba:	0f b6       	in	r0, 0x3f	; 63
    1ebc:	f8 94       	cli
    1ebe:	de bf       	out	0x3e, r29	; 62
    1ec0:	0f be       	out	0x3f, r0	; 63
    1ec2:	cd bf       	out	0x3d, r28	; 61
    1ec4:	8c 01       	movw	r16, r24
	u8 rem = 0;
	u8 i = 0;
	u16 arr[16]={0};
    1ec6:	7e 01       	movw	r14, r28
    1ec8:	08 94       	sec
    1eca:	e1 1c       	adc	r14, r1
    1ecc:	f1 1c       	adc	r15, r1
    1ece:	80 e2       	ldi	r24, 0x20	; 32
    1ed0:	f7 01       	movw	r30, r14
    1ed2:	11 92       	st	Z+, r1
    1ed4:	8a 95       	dec	r24
    1ed6:	e9 f7       	brne	.-6      	; 0x1ed2 <LCD_WriteNum+0x2e>
	u8 j = 0;
	if(num>0)
    1ed8:	10 16       	cp	r1, r16
    1eda:	11 06       	cpc	r1, r17
    1edc:	74 f5       	brge	.+92     	; 0x1f3a <LCD_WriteNum+0x96>
    1ede:	40 e0       	ldi	r20, 0x00	; 0
	{
		while(num>0)
		{
			rem=num%10;
			arr[i]=rem+'0';
    1ee0:	e4 2f       	mov	r30, r20
    1ee2:	f0 e0       	ldi	r31, 0x00	; 0
    1ee4:	ee 0f       	add	r30, r30
    1ee6:	ff 1f       	adc	r31, r31
    1ee8:	ee 0d       	add	r30, r14
    1eea:	ff 1d       	adc	r31, r15
    1eec:	c8 01       	movw	r24, r16
    1eee:	6a e0       	ldi	r22, 0x0A	; 10
    1ef0:	70 e0       	ldi	r23, 0x00	; 0
    1ef2:	0e 94 93 22 	call	0x4526	; 0x4526 <__divmodhi4>
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	c0 96       	adiw	r24, 0x30	; 48
    1efa:	91 83       	std	Z+1, r25	; 0x01
    1efc:	80 83       	st	Z, r24
			i++;
    1efe:	4f 5f       	subi	r20, 0xFF	; 255
			num=num/10;
    1f00:	c8 01       	movw	r24, r16
    1f02:	6a e0       	ldi	r22, 0x0A	; 10
    1f04:	70 e0       	ldi	r23, 0x00	; 0
    1f06:	0e 94 93 22 	call	0x4526	; 0x4526 <__divmodhi4>
    1f0a:	8b 01       	movw	r16, r22
	u8 i = 0;
	u16 arr[16]={0};
	u8 j = 0;
	if(num>0)
	{
		while(num>0)
    1f0c:	61 15       	cp	r22, r1
    1f0e:	71 05       	cpc	r23, r1
    1f10:	39 f7       	brne	.-50     	; 0x1ee0 <LCD_WriteNum+0x3c>
    1f12:	14 2f       	mov	r17, r20
			i++;
			num=num/10;
		}
		for( j=i;j>0;j--)
		{
			LCD_WriteData(arr[j-1]);
    1f14:	7e 01       	movw	r14, r28
    1f16:	08 94       	sec
    1f18:	e1 1c       	adc	r14, r1
    1f1a:	f1 1c       	adc	r15, r1
    1f1c:	0b c0       	rjmp	.+22     	; 0x1f34 <LCD_WriteNum+0x90>
    1f1e:	e1 2f       	mov	r30, r17
    1f20:	f0 e0       	ldi	r31, 0x00	; 0
    1f22:	31 97       	sbiw	r30, 0x01	; 1
    1f24:	ee 0f       	add	r30, r30
    1f26:	ff 1f       	adc	r31, r31
    1f28:	ee 0d       	add	r30, r14
    1f2a:	ff 1d       	adc	r31, r15
    1f2c:	80 81       	ld	r24, Z
    1f2e:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
			rem=num%10;
			arr[i]=rem+'0';
			i++;
			num=num/10;
		}
		for( j=i;j>0;j--)
    1f32:	11 50       	subi	r17, 0x01	; 1
    1f34:	11 23       	and	r17, r17
    1f36:	99 f7       	brne	.-26     	; 0x1f1e <LCD_WriteNum+0x7a>
    1f38:	3c c0       	rjmp	.+120    	; 0x1fb2 <LCD_WriteNum+0x10e>
		{
			LCD_WriteData(arr[j-1]);
		}
	}
	else if(num<0)
    1f3a:	01 15       	cp	r16, r1
    1f3c:	11 05       	cpc	r17, r1
    1f3e:	b1 f1       	breq	.+108    	; 0x1fac <LCD_WriteNum+0x108>
	{
		LCD_WriteData('-');
    1f40:	8d e2       	ldi	r24, 0x2D	; 45
    1f42:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
    1f46:	40 e0       	ldi	r20, 0x00	; 0
		while(num<0)
		{
			rem=num%10;
			arr[i]=-rem+'0';
    1f48:	67 01       	movw	r12, r14
    1f4a:	50 e3       	ldi	r21, 0x30	; 48
    1f4c:	e5 2e       	mov	r14, r21
    1f4e:	f1 2c       	mov	r15, r1
    1f50:	e4 2f       	mov	r30, r20
    1f52:	f0 e0       	ldi	r31, 0x00	; 0
    1f54:	ee 0f       	add	r30, r30
    1f56:	ff 1f       	adc	r31, r31
    1f58:	ec 0d       	add	r30, r12
    1f5a:	fd 1d       	adc	r31, r13
    1f5c:	c8 01       	movw	r24, r16
    1f5e:	6a e0       	ldi	r22, 0x0A	; 10
    1f60:	70 e0       	ldi	r23, 0x00	; 0
    1f62:	0e 94 93 22 	call	0x4526	; 0x4526 <__divmodhi4>
    1f66:	97 01       	movw	r18, r14
    1f68:	28 1b       	sub	r18, r24
    1f6a:	31 09       	sbc	r19, r1
    1f6c:	31 83       	std	Z+1, r19	; 0x01
    1f6e:	20 83       	st	Z, r18
			i++;
    1f70:	4f 5f       	subi	r20, 0xFF	; 255
			num=num/10;
    1f72:	c8 01       	movw	r24, r16
    1f74:	6a e0       	ldi	r22, 0x0A	; 10
    1f76:	70 e0       	ldi	r23, 0x00	; 0
    1f78:	0e 94 93 22 	call	0x4526	; 0x4526 <__divmodhi4>
    1f7c:	8b 01       	movw	r16, r22
		}
	}
	else if(num<0)
	{
		LCD_WriteData('-');
		while(num<0)
    1f7e:	61 15       	cp	r22, r1
    1f80:	71 05       	cpc	r23, r1
    1f82:	31 f7       	brne	.-52     	; 0x1f50 <LCD_WriteNum+0xac>
    1f84:	14 2f       	mov	r17, r20
			i++;
			num=num/10;
		}
		for( j=i;j>0;j--)
		{
			LCD_WriteData(arr[j-1]);
    1f86:	7e 01       	movw	r14, r28
    1f88:	08 94       	sec
    1f8a:	e1 1c       	adc	r14, r1
    1f8c:	f1 1c       	adc	r15, r1
    1f8e:	0b c0       	rjmp	.+22     	; 0x1fa6 <LCD_WriteNum+0x102>
    1f90:	e1 2f       	mov	r30, r17
    1f92:	f0 e0       	ldi	r31, 0x00	; 0
    1f94:	31 97       	sbiw	r30, 0x01	; 1
    1f96:	ee 0f       	add	r30, r30
    1f98:	ff 1f       	adc	r31, r31
    1f9a:	ee 0d       	add	r30, r14
    1f9c:	ff 1d       	adc	r31, r15
    1f9e:	80 81       	ld	r24, Z
    1fa0:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
			rem=num%10;
			arr[i]=-rem+'0';
			i++;
			num=num/10;
		}
		for( j=i;j>0;j--)
    1fa4:	11 50       	subi	r17, 0x01	; 1
    1fa6:	11 23       	and	r17, r17
    1fa8:	99 f7       	brne	.-26     	; 0x1f90 <LCD_WriteNum+0xec>
    1faa:	03 c0       	rjmp	.+6      	; 0x1fb2 <LCD_WriteNum+0x10e>
		{
			LCD_WriteData(arr[j-1]);
		}
	}
	else
		LCD_WriteData('0');
    1fac:	80 e3       	ldi	r24, 0x30	; 48
    1fae:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
		}
		while(reversed!=1)
	}
	 */

}
    1fb2:	a0 96       	adiw	r28, 0x20	; 32
    1fb4:	0f b6       	in	r0, 0x3f	; 63
    1fb6:	f8 94       	cli
    1fb8:	de bf       	out	0x3e, r29	; 62
    1fba:	0f be       	out	0x3f, r0	; 63
    1fbc:	cd bf       	out	0x3d, r28	; 61
    1fbe:	cf 91       	pop	r28
    1fc0:	df 91       	pop	r29
    1fc2:	1f 91       	pop	r17
    1fc4:	0f 91       	pop	r16
    1fc6:	ff 90       	pop	r15
    1fc8:	ef 90       	pop	r14
    1fca:	df 90       	pop	r13
    1fcc:	cf 90       	pop	r12
    1fce:	08 95       	ret

00001fd0 <LCD_WriteString>:
#include "LCD.h"
#include "Dio.h"
#include "LCD_Cfg.h"
#include "LcdService.h"
void LCD_WriteString(u8 *str)
{
    1fd0:	1f 93       	push	r17
    1fd2:	cf 93       	push	r28
    1fd4:	df 93       	push	r29
    1fd6:	ec 01       	movw	r28, r24
    1fd8:	10 e0       	ldi	r17, 0x00	; 0
    1fda:	03 c0       	rjmp	.+6      	; 0x1fe2 <LCD_WriteString+0x12>
	for(u8 i = 0;str[i];i++)
	{
		LCD_WriteData(str[i]);
    1fdc:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
#include "Dio.h"
#include "LCD_Cfg.h"
#include "LcdService.h"
void LCD_WriteString(u8 *str)
{
	for(u8 i = 0;str[i];i++)
    1fe0:	1f 5f       	subi	r17, 0xFF	; 255
    1fe2:	fe 01       	movw	r30, r28
    1fe4:	e1 0f       	add	r30, r17
    1fe6:	f1 1d       	adc	r31, r1
    1fe8:	80 81       	ld	r24, Z
    1fea:	88 23       	and	r24, r24
    1fec:	b9 f7       	brne	.-18     	; 0x1fdc <LCD_WriteString+0xc>
	{
		LCD_WriteData(str[i]);
	}
}
    1fee:	df 91       	pop	r29
    1ff0:	cf 91       	pop	r28
    1ff2:	1f 91       	pop	r17
    1ff4:	08 95       	ret

00001ff6 <GetKeyState>:

	return  Return;
}*/

u8 GetKeyState (void)
{
    1ff6:	bf 92       	push	r11
    1ff8:	cf 92       	push	r12
    1ffa:	df 92       	push	r13
    1ffc:	ef 92       	push	r14
    1ffe:	ff 92       	push	r15
    2000:	0f 93       	push	r16
    2002:	1f 93       	push	r17
    2004:	cf 93       	push	r28
    2006:	df 93       	push	r29
    2008:	95 ed       	ldi	r25, 0xD5	; 213
    200a:	c9 2e       	mov	r12, r25
    200c:	91 e0       	ldi	r25, 0x01	; 1
    200e:	d9 2e       	mov	r13, r25
    2010:	bb 24       	eor	r11, r11
    2012:	ba 94       	dec	r11
    2014:	ee 24       	eor	r14, r14
    2016:	ff 24       	eor	r15, r15
	extern u8 KeypadValue[NumRow][NumCol];

		for(r =0;r<NumRow;r++)
		{

			Dio_WriteChannel(RowArr[r],STD_LOW);
    2018:	f6 01       	movw	r30, r12
    201a:	80 81       	ld	r24, Z
    201c:	60 e0       	ldi	r22, 0x00	; 0
    201e:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
    2022:	09 ed       	ldi	r16, 0xD9	; 217
    2024:	11 e0       	ldi	r17, 0x01	; 1
    2026:	e7 01       	movw	r28, r14
    2028:	cc 0f       	add	r28, r28
    202a:	dd 1f       	adc	r29, r29
    202c:	cc 0f       	add	r28, r28
    202e:	dd 1f       	adc	r29, r29
    2030:	cb 53       	subi	r28, 0x3B	; 59
    2032:	de 4f       	sbci	r29, 0xFE	; 254
			for(c=0;c<NumCol;c++)
			{
				if(Dio_ReadChannel(ColArr[c])==STD_LOW)
    2034:	f8 01       	movw	r30, r16
    2036:	80 81       	ld	r24, Z
    2038:	0e 94 55 0b 	call	0x16aa	; 0x16aa <Dio_ReadChannel>
    203c:	88 23       	and	r24, r24
    203e:	39 f4       	brne	.+14     	; 0x204e <GetKeyState+0x58>
				{
					Key=KeypadValue[r][c];
    2040:	b8 80       	ld	r11, Y
					while(Dio_ReadChannel(ColArr[c])==STD_LOW);
    2042:	f8 01       	movw	r30, r16
    2044:	80 81       	ld	r24, Z
    2046:	0e 94 55 0b 	call	0x16aa	; 0x16aa <Dio_ReadChannel>
    204a:	88 23       	and	r24, r24
    204c:	d1 f3       	breq	.-12     	; 0x2042 <GetKeyState+0x4c>
    204e:	0f 5f       	subi	r16, 0xFF	; 255
    2050:	1f 4f       	sbci	r17, 0xFF	; 255
    2052:	21 96       	adiw	r28, 0x01	; 1

		for(r =0;r<NumRow;r++)
		{

			Dio_WriteChannel(RowArr[r],STD_LOW);
			for(c=0;c<NumCol;c++)
    2054:	f1 e0       	ldi	r31, 0x01	; 1
    2056:	0d 3d       	cpi	r16, 0xDD	; 221
    2058:	1f 07       	cpc	r17, r31
    205a:	61 f7       	brne	.-40     	; 0x2034 <GetKeyState+0x3e>
					Key=KeypadValue[r][c];
					while(Dio_ReadChannel(ColArr[c])==STD_LOW);

				}
			}
			Dio_WriteChannel(RowArr[r],STD_HIGH);
    205c:	f6 01       	movw	r30, r12
    205e:	81 91       	ld	r24, Z+
    2060:	6f 01       	movw	r12, r30
    2062:	61 e0       	ldi	r22, 0x01	; 1
    2064:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <Dio_WriteChannel>
    2068:	08 94       	sec
    206a:	e1 1c       	adc	r14, r1
    206c:	f1 1c       	adc	r15, r1

	extern u8 RowArr[NumRow];
	extern u8 ColArr[NumCol];
	extern u8 KeypadValue[NumRow][NumCol];

		for(r =0;r<NumRow;r++)
    206e:	f4 e0       	ldi	r31, 0x04	; 4
    2070:	ef 16       	cp	r14, r31
    2072:	f1 04       	cpc	r15, r1
    2074:	89 f6       	brne	.-94     	; 0x2018 <GetKeyState+0x22>

		}

		return Key;

}
    2076:	8b 2d       	mov	r24, r11
    2078:	df 91       	pop	r29
    207a:	cf 91       	pop	r28
    207c:	1f 91       	pop	r17
    207e:	0f 91       	pop	r16
    2080:	ff 90       	pop	r15
    2082:	ef 90       	pop	r14
    2084:	df 90       	pop	r13
    2086:	cf 90       	pop	r12
    2088:	bf 90       	pop	r11
    208a:	08 95       	ret

0000208c <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    208c:	80 91 55 02 	lds	r24, 0x0255
    2090:	88 23       	and	r24, r24
    2092:	21 f0       	breq	.+8      	; 0x209c <xArePollingQueuesStillRunning+0x10>
    2094:	80 91 56 02 	lds	r24, 0x0256
    2098:	81 11       	cpse	r24, r1
    209a:	81 e0       	ldi	r24, 0x01	; 1
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    209c:	10 92 55 02 	sts	0x0255, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    20a0:	10 92 56 02 	sts	0x0256, r1

	return xReturn;
}
    20a4:	08 95       	ret

000020a6 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    20a6:	8f 92       	push	r8
    20a8:	9f 92       	push	r9
    20aa:	af 92       	push	r10
    20ac:	bf 92       	push	r11
    20ae:	cf 92       	push	r12
    20b0:	df 92       	push	r13
    20b2:	ef 92       	push	r14
    20b4:	ff 92       	push	r15
    20b6:	0f 93       	push	r16
    20b8:	1f 93       	push	r17
    20ba:	18 2f       	mov	r17, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    20bc:	8a e0       	ldi	r24, 0x0A	; 10
    20be:	62 e0       	ldi	r22, 0x02	; 2
    20c0:	40 e0       	ldi	r20, 0x00	; 0
    20c2:	0e 94 bd 1a 	call	0x357a	; 0x357a <xQueueGenericCreate>
    20c6:	90 93 58 02 	sts	0x0258, r25
    20ca:	80 93 57 02 	sts	0x0257, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    20ce:	87 e5       	ldi	r24, 0x57	; 87
    20d0:	88 2e       	mov	r8, r24
    20d2:	82 e0       	ldi	r24, 0x02	; 2
    20d4:	98 2e       	mov	r9, r24
    20d6:	8b ec       	ldi	r24, 0xCB	; 203
    20d8:	90 e1       	ldi	r25, 0x10	; 16
    20da:	60 e6       	ldi	r22, 0x60	; 96
    20dc:	70 e0       	ldi	r23, 0x00	; 0
    20de:	45 e5       	ldi	r20, 0x55	; 85
    20e0:	50 e0       	ldi	r21, 0x00	; 0
    20e2:	94 01       	movw	r18, r8
    20e4:	01 2f       	mov	r16, r17
    20e6:	ee 24       	eor	r14, r14
    20e8:	ff 24       	eor	r15, r15
    20ea:	cc 24       	eor	r12, r12
    20ec:	dd 24       	eor	r13, r13
    20ee:	aa 24       	eor	r10, r10
    20f0:	bb 24       	eor	r11, r11
    20f2:	0e 94 85 20 	call	0x410a	; 0x410a <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    20f6:	8f e8       	ldi	r24, 0x8F	; 143
    20f8:	90 e1       	ldi	r25, 0x10	; 16
    20fa:	68 e6       	ldi	r22, 0x68	; 104
    20fc:	70 e0       	ldi	r23, 0x00	; 0
    20fe:	45 e5       	ldi	r20, 0x55	; 85
    2100:	50 e0       	ldi	r21, 0x00	; 0
    2102:	94 01       	movw	r18, r8
    2104:	0e 94 85 20 	call	0x410a	; 0x410a <xTaskGenericCreate>
}
    2108:	1f 91       	pop	r17
    210a:	0f 91       	pop	r16
    210c:	ff 90       	pop	r15
    210e:	ef 90       	pop	r14
    2110:	df 90       	pop	r13
    2112:	cf 90       	pop	r12
    2114:	bf 90       	pop	r11
    2116:	af 90       	pop	r10
    2118:	9f 90       	pop	r9
    211a:	8f 90       	pop	r8
    211c:	08 95       	ret

0000211e <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    211e:	cf 92       	push	r12
    2120:	df 92       	push	r13
    2122:	ef 92       	push	r14
    2124:	ff 92       	push	r15
    2126:	0f 93       	push	r16
    2128:	1f 93       	push	r17
    212a:	df 93       	push	r29
    212c:	cf 93       	push	r28
    212e:	00 d0       	rcall	.+0      	; 0x2130 <vPolledQueueProducer+0x12>
    2130:	cd b7       	in	r28, 0x3d	; 61
    2132:	de b7       	in	r29, 0x3e	; 62
    2134:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    2136:	1a 82       	std	Y+2, r1	; 0x02
    2138:	19 82       	std	Y+1, r1	; 0x01
    213a:	00 e0       	ldi	r16, 0x00	; 0
    213c:	10 e0       	ldi	r17, 0x00	; 0
	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    213e:	6e 01       	movw	r12, r28
    2140:	08 94       	sec
    2142:	c1 1c       	adc	r12, r1
    2144:	d1 1c       	adc	r13, r1
    2146:	1f c0       	rjmp	.+62     	; 0x2186 <vPolledQueueProducer+0x68>
    2148:	f7 01       	movw	r30, r14
    214a:	80 81       	ld	r24, Z
    214c:	91 81       	ldd	r25, Z+1	; 0x01
    214e:	b6 01       	movw	r22, r12
    2150:	40 e0       	ldi	r20, 0x00	; 0
    2152:	50 e0       	ldi	r21, 0x00	; 0
    2154:	20 e0       	ldi	r18, 0x00	; 0
    2156:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <xQueueGenericSend>
    215a:	81 30       	cpi	r24, 0x01	; 1
    215c:	11 f0       	breq	.+4      	; 0x2162 <vPolledQueueProducer+0x44>
    215e:	01 e0       	ldi	r16, 0x01	; 1
    2160:	11 c0       	rjmp	.+34     	; 0x2184 <vPolledQueueProducer+0x66>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    2162:	00 23       	and	r16, r16
    2164:	51 f4       	brne	.+20     	; 0x217a <vPolledQueueProducer+0x5c>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    2166:	0f b6       	in	r0, 0x3f	; 63
    2168:	f8 94       	cli
    216a:	0f 92       	push	r0
						xPollingProducerCount++;
    216c:	80 91 56 02 	lds	r24, 0x0256
    2170:	8f 5f       	subi	r24, 0xFF	; 255
    2172:	80 93 56 02 	sts	0x0256, r24
					portEXIT_CRITICAL();
    2176:	0f 90       	pop	r0
    2178:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    217a:	89 81       	ldd	r24, Y+1	; 0x01
    217c:	9a 81       	ldd	r25, Y+2	; 0x02
    217e:	01 96       	adiw	r24, 0x01	; 1
    2180:	9a 83       	std	Y+2, r25	; 0x02
    2182:	89 83       	std	Y+1, r24	; 0x01
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2184:	1f 5f       	subi	r17, 0xFF	; 255
    2186:	13 30       	cpi	r17, 0x03	; 3
    2188:	fc f2       	brlt	.-66     	; 0x2148 <vPolledQueueProducer+0x2a>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    218a:	88 ec       	ldi	r24, 0xC8	; 200
    218c:	90 e0       	ldi	r25, 0x00	; 0
    218e:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <vTaskDelay>
    2192:	10 e0       	ldi	r17, 0x00	; 0
    2194:	d9 cf       	rjmp	.-78     	; 0x2148 <vPolledQueueProducer+0x2a>

00002196 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    2196:	9f 92       	push	r9
    2198:	af 92       	push	r10
    219a:	bf 92       	push	r11
    219c:	cf 92       	push	r12
    219e:	df 92       	push	r13
    21a0:	ef 92       	push	r14
    21a2:	ff 92       	push	r15
    21a4:	0f 93       	push	r16
    21a6:	1f 93       	push	r17
    21a8:	df 93       	push	r29
    21aa:	cf 93       	push	r28
    21ac:	00 d0       	rcall	.+0      	; 0x21ae <vPolledQueueConsumer+0x18>
    21ae:	cd b7       	in	r28, 0x3d	; 61
    21b0:	de b7       	in	r29, 0x3e	; 62
    21b2:	98 2e       	mov	r9, r24
    21b4:	c9 2e       	mov	r12, r25
    21b6:	ee 24       	eor	r14, r14
    21b8:	ff 24       	eor	r15, r15
    21ba:	dd 24       	eor	r13, r13
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    21bc:	5e 01       	movw	r10, r28
    21be:	08 94       	sec
    21c0:	a1 1c       	adc	r10, r1
    21c2:	b1 1c       	adc	r11, r1
    21c4:	23 c0       	rjmp	.+70     	; 0x220c <vPolledQueueConsumer+0x76>
    21c6:	f8 01       	movw	r30, r16
    21c8:	80 81       	ld	r24, Z
    21ca:	91 81       	ldd	r25, Z+1	; 0x01
    21cc:	b5 01       	movw	r22, r10
    21ce:	40 e0       	ldi	r20, 0x00	; 0
    21d0:	50 e0       	ldi	r21, 0x00	; 0
    21d2:	20 e0       	ldi	r18, 0x00	; 0
    21d4:	0e 94 1d 19 	call	0x323a	; 0x323a <xQueueGenericReceive>
    21d8:	81 30       	cpi	r24, 0x01	; 1
    21da:	c1 f4       	brne	.+48     	; 0x220c <vPolledQueueConsumer+0x76>
			{
				if( usData != usExpectedValue )
    21dc:	29 81       	ldd	r18, Y+1	; 0x01
    21de:	3a 81       	ldd	r19, Y+2	; 0x02
    21e0:	2e 15       	cp	r18, r14
    21e2:	3f 05       	cpc	r19, r15
    21e4:	19 f0       	breq	.+6      	; 0x21ec <vPolledQueueConsumer+0x56>
    21e6:	dd 24       	eor	r13, r13
    21e8:	d3 94       	inc	r13
    21ea:	0c c0       	rjmp	.+24     	; 0x2204 <vPolledQueueConsumer+0x6e>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    21ec:	dd 20       	and	r13, r13
    21ee:	51 f4       	brne	.+20     	; 0x2204 <vPolledQueueConsumer+0x6e>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    21f0:	0f b6       	in	r0, 0x3f	; 63
    21f2:	f8 94       	cli
    21f4:	0f 92       	push	r0
							xPollingConsumerCount++;
    21f6:	80 91 55 02 	lds	r24, 0x0255
    21fa:	8f 5f       	subi	r24, 0xFF	; 255
    21fc:	80 93 55 02 	sts	0x0255, r24
						portEXIT_CRITICAL();
    2200:	0f 90       	pop	r0
    2202:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2204:	79 01       	movw	r14, r18
    2206:	08 94       	sec
    2208:	e1 1c       	adc	r14, r1
    220a:	f1 1c       	adc	r15, r1
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    220c:	09 2d       	mov	r16, r9
    220e:	1c 2d       	mov	r17, r12
    2210:	f8 01       	movw	r30, r16
    2212:	80 81       	ld	r24, Z
    2214:	91 81       	ldd	r25, Z+1	; 0x01
    2216:	0e 94 f3 16 	call	0x2de6	; 0x2de6 <uxQueueMessagesWaiting>
    221a:	88 23       	and	r24, r24
    221c:	a1 f6       	brne	.-88     	; 0x21c6 <vPolledQueueConsumer+0x30>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    221e:	84 eb       	ldi	r24, 0xB4	; 180
    2220:	90 e0       	ldi	r25, 0x00	; 0
    2222:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <vTaskDelay>
    2226:	f2 cf       	rjmp	.-28     	; 0x220c <vPolledQueueConsumer+0x76>

00002228 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2228:	ef 92       	push	r14
    222a:	ff 92       	push	r15
    222c:	0f 93       	push	r16
    222e:	1f 93       	push	r17
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2230:	dc 01       	movw	r26, r24
    2232:	15 96       	adiw	r26, 0x05	; 5
    2234:	ed 91       	ld	r30, X+
    2236:	fc 91       	ld	r31, X
    2238:	16 97       	sbiw	r26, 0x06	; 6
    223a:	e6 80       	ldd	r14, Z+6	; 0x06
    223c:	f7 80       	ldd	r15, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    223e:	87 01       	movw	r16, r14
    2240:	04 5f       	subi	r16, 0xF4	; 244
    2242:	1f 4f       	sbci	r17, 0xFF	; 255
    2244:	c8 01       	movw	r24, r16
    2246:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    224a:	8a e8       	ldi	r24, 0x8A	; 138
    224c:	92 e0       	ldi	r25, 0x02	; 2
    224e:	b8 01       	movw	r22, r16
    2250:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
    2254:	20 e0       	ldi	r18, 0x00	; 0
    2256:	e0 91 59 02 	lds	r30, 0x0259
    225a:	f0 91 5a 02 	lds	r31, 0x025A
    225e:	d7 01       	movw	r26, r14
    2260:	56 96       	adiw	r26, 0x16	; 22
    2262:	9c 91       	ld	r25, X
    2264:	86 89       	ldd	r24, Z+22	; 0x16
    2266:	98 17       	cp	r25, r24
    2268:	08 f0       	brcs	.+2      	; 0x226c <xCoRoutineRemoveFromEventList+0x44>
    226a:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    226c:	82 2f       	mov	r24, r18
    226e:	1f 91       	pop	r17
    2270:	0f 91       	pop	r16
    2272:	ff 90       	pop	r15
    2274:	ef 90       	pop	r14
    2276:	08 95       	ret

00002278 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2278:	ff 92       	push	r15
    227a:	0f 93       	push	r16
    227c:	1f 93       	push	r17
    227e:	cf 93       	push	r28
    2280:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2282:	99 e0       	ldi	r25, 0x09	; 9
    2284:	f9 2e       	mov	r15, r25
    2286:	21 c0       	rjmp	.+66     	; 0x22ca <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2288:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    228a:	e0 91 8f 02 	lds	r30, 0x028F
    228e:	f0 91 90 02 	lds	r31, 0x0290
    2292:	06 81       	ldd	r16, Z+6	; 0x06
    2294:	17 81       	ldd	r17, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2296:	c8 01       	movw	r24, r16
    2298:	0c 96       	adiw	r24, 0x0c	; 12
    229a:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    229e:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    22a0:	e8 01       	movw	r28, r16
    22a2:	22 96       	adiw	r28, 0x02	; 2
    22a4:	ce 01       	movw	r24, r28
    22a6:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    22aa:	f8 01       	movw	r30, r16
    22ac:	96 89       	ldd	r25, Z+22	; 0x16
    22ae:	80 91 5b 02 	lds	r24, 0x025B
    22b2:	89 17       	cp	r24, r25
    22b4:	10 f4       	brcc	.+4      	; 0x22ba <vCoRoutineSchedule+0x42>
    22b6:	90 93 5b 02 	sts	0x025B, r25
    22ba:	9f 9d       	mul	r25, r15
    22bc:	c0 01       	movw	r24, r0
    22be:	11 24       	eor	r1, r1
    22c0:	8e 59       	subi	r24, 0x9E	; 158
    22c2:	9d 4f       	sbci	r25, 0xFD	; 253
    22c4:	be 01       	movw	r22, r28
    22c6:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    22ca:	80 91 8a 02 	lds	r24, 0x028A
    22ce:	88 23       	and	r24, r24
    22d0:	d9 f6       	brne	.-74     	; 0x2288 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    22d2:	0e 94 fe 1a 	call	0x35fc	; 0x35fc <xTaskGetTickCount>
    22d6:	20 91 5c 02 	lds	r18, 0x025C
    22da:	30 91 5d 02 	lds	r19, 0x025D
    22de:	82 1b       	sub	r24, r18
    22e0:	93 0b       	sbc	r25, r19
    22e2:	90 93 5f 02 	sts	0x025F, r25
    22e6:	80 93 5e 02 	sts	0x025E, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    22ea:	89 e0       	ldi	r24, 0x09	; 9
    22ec:	f8 2e       	mov	r15, r24
    22ee:	53 c0       	rjmp	.+166    	; 0x2396 <vCoRoutineSchedule+0x11e>
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    22f0:	01 96       	adiw	r24, 0x01	; 1
    22f2:	90 93 61 02 	sts	0x0261, r25
    22f6:	80 93 60 02 	sts	0x0260, r24
		xPassedTicks--;
    22fa:	21 50       	subi	r18, 0x01	; 1
    22fc:	30 40       	sbci	r19, 0x00	; 0
    22fe:	30 93 5f 02 	sts	0x025F, r19
    2302:	20 93 5e 02 	sts	0x025E, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2306:	89 2b       	or	r24, r25
    2308:	09 f0       	breq	.+2      	; 0x230c <vCoRoutineSchedule+0x94>
    230a:	3e c0       	rjmp	.+124    	; 0x2388 <vCoRoutineSchedule+0x110>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    230c:	20 91 86 02 	lds	r18, 0x0286
    2310:	30 91 87 02 	lds	r19, 0x0287
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2314:	80 91 88 02 	lds	r24, 0x0288
    2318:	90 91 89 02 	lds	r25, 0x0289
    231c:	90 93 87 02 	sts	0x0287, r25
    2320:	80 93 86 02 	sts	0x0286, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2324:	30 93 89 02 	sts	0x0289, r19
    2328:	20 93 88 02 	sts	0x0288, r18
    232c:	2d c0       	rjmp	.+90     	; 0x2388 <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    232e:	05 80       	ldd	r0, Z+5	; 0x05
    2330:	f6 81       	ldd	r31, Z+6	; 0x06
    2332:	e0 2d       	mov	r30, r0
    2334:	c6 81       	ldd	r28, Z+6	; 0x06
    2336:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2338:	20 91 60 02 	lds	r18, 0x0260
    233c:	30 91 61 02 	lds	r19, 0x0261
    2340:	8a 81       	ldd	r24, Y+2	; 0x02
    2342:	9b 81       	ldd	r25, Y+3	; 0x03
    2344:	28 17       	cp	r18, r24
    2346:	39 07       	cpc	r19, r25
    2348:	30 f1       	brcs	.+76     	; 0x2396 <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    234a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    234c:	8e 01       	movw	r16, r28
    234e:	0e 5f       	subi	r16, 0xFE	; 254
    2350:	1f 4f       	sbci	r17, 0xFF	; 255
    2352:	c8 01       	movw	r24, r16
    2354:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    2358:	8c 89       	ldd	r24, Y+20	; 0x14
    235a:	9d 89       	ldd	r25, Y+21	; 0x15
    235c:	89 2b       	or	r24, r25
    235e:	21 f0       	breq	.+8      	; 0x2368 <vCoRoutineSchedule+0xf0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2360:	ce 01       	movw	r24, r28
    2362:	0c 96       	adiw	r24, 0x0c	; 12
    2364:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2368:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    236a:	9e 89       	ldd	r25, Y+22	; 0x16
    236c:	80 91 5b 02 	lds	r24, 0x025B
    2370:	89 17       	cp	r24, r25
    2372:	10 f4       	brcc	.+4      	; 0x2378 <vCoRoutineSchedule+0x100>
    2374:	90 93 5b 02 	sts	0x025B, r25
    2378:	9f 9d       	mul	r25, r15
    237a:	c0 01       	movw	r24, r0
    237c:	11 24       	eor	r1, r1
    237e:	8e 59       	subi	r24, 0x9E	; 158
    2380:	9d 4f       	sbci	r25, 0xFD	; 253
    2382:	b8 01       	movw	r22, r16
    2384:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2388:	e0 91 86 02 	lds	r30, 0x0286
    238c:	f0 91 87 02 	lds	r31, 0x0287
    2390:	80 81       	ld	r24, Z
    2392:	88 23       	and	r24, r24
    2394:	61 f6       	brne	.-104    	; 0x232e <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2396:	20 91 5e 02 	lds	r18, 0x025E
    239a:	30 91 5f 02 	lds	r19, 0x025F
    239e:	80 91 60 02 	lds	r24, 0x0260
    23a2:	90 91 61 02 	lds	r25, 0x0261
    23a6:	21 15       	cp	r18, r1
    23a8:	31 05       	cpc	r19, r1
    23aa:	09 f0       	breq	.+2      	; 0x23ae <vCoRoutineSchedule+0x136>
    23ac:	a1 cf       	rjmp	.-190    	; 0x22f0 <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    23ae:	90 93 5d 02 	sts	0x025D, r25
    23b2:	80 93 5c 02 	sts	0x025C, r24
    23b6:	90 91 5b 02 	lds	r25, 0x025B

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    23ba:	29 e0       	ldi	r18, 0x09	; 9
    23bc:	06 c0       	rjmp	.+12     	; 0x23ca <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    23be:	99 23       	and	r25, r25
    23c0:	19 f4       	brne	.+6      	; 0x23c8 <vCoRoutineSchedule+0x150>
    23c2:	10 92 5b 02 	sts	0x025B, r1
    23c6:	32 c0       	rjmp	.+100    	; 0x242c <vCoRoutineSchedule+0x1b4>
    23c8:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    23ca:	92 9f       	mul	r25, r18
    23cc:	d0 01       	movw	r26, r0
    23ce:	11 24       	eor	r1, r1
    23d0:	ae 59       	subi	r26, 0x9E	; 158
    23d2:	bd 4f       	sbci	r27, 0xFD	; 253
    23d4:	8c 91       	ld	r24, X
    23d6:	88 23       	and	r24, r24
    23d8:	91 f3       	breq	.-28     	; 0x23be <vCoRoutineSchedule+0x146>
    23da:	90 93 5b 02 	sts	0x025B, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    23de:	11 96       	adiw	r26, 0x01	; 1
    23e0:	ed 91       	ld	r30, X+
    23e2:	fc 91       	ld	r31, X
    23e4:	12 97       	sbiw	r26, 0x02	; 2
    23e6:	02 80       	ldd	r0, Z+2	; 0x02
    23e8:	f3 81       	ldd	r31, Z+3	; 0x03
    23ea:	e0 2d       	mov	r30, r0
    23ec:	12 96       	adiw	r26, 0x02	; 2
    23ee:	fc 93       	st	X, r31
    23f0:	ee 93       	st	-X, r30
    23f2:	11 97       	sbiw	r26, 0x01	; 1
    23f4:	cd 01       	movw	r24, r26
    23f6:	03 96       	adiw	r24, 0x03	; 3
    23f8:	e8 17       	cp	r30, r24
    23fa:	f9 07       	cpc	r31, r25
    23fc:	31 f4       	brne	.+12     	; 0x240a <vCoRoutineSchedule+0x192>
    23fe:	82 81       	ldd	r24, Z+2	; 0x02
    2400:	93 81       	ldd	r25, Z+3	; 0x03
    2402:	12 96       	adiw	r26, 0x02	; 2
    2404:	9c 93       	st	X, r25
    2406:	8e 93       	st	-X, r24
    2408:	11 97       	sbiw	r26, 0x01	; 1
    240a:	11 96       	adiw	r26, 0x01	; 1
    240c:	ed 91       	ld	r30, X+
    240e:	fc 91       	ld	r31, X
    2410:	12 97       	sbiw	r26, 0x02	; 2
    2412:	06 80       	ldd	r0, Z+6	; 0x06
    2414:	f7 81       	ldd	r31, Z+7	; 0x07
    2416:	e0 2d       	mov	r30, r0
    2418:	f0 93 5a 02 	sts	0x025A, r31
    241c:	e0 93 59 02 	sts	0x0259, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2420:	20 81       	ld	r18, Z
    2422:	31 81       	ldd	r19, Z+1	; 0x01
    2424:	cf 01       	movw	r24, r30
    2426:	67 89       	ldd	r22, Z+23	; 0x17
    2428:	f9 01       	movw	r30, r18
    242a:	09 95       	icall

	return;
}
    242c:	df 91       	pop	r29
    242e:	cf 91       	pop	r28
    2430:	1f 91       	pop	r17
    2432:	0f 91       	pop	r16
    2434:	ff 90       	pop	r15
    2436:	08 95       	ret

00002438 <vCoRoutineAddToDelayedList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2438:	0f 93       	push	r16
    243a:	1f 93       	push	r17
    243c:	cf 93       	push	r28
    243e:	df 93       	push	r29
    2440:	eb 01       	movw	r28, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2442:	00 91 60 02 	lds	r16, 0x0260
    2446:	10 91 61 02 	lds	r17, 0x0261
    244a:	08 0f       	add	r16, r24
    244c:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    244e:	80 91 59 02 	lds	r24, 0x0259
    2452:	90 91 5a 02 	lds	r25, 0x025A
    2456:	02 96       	adiw	r24, 0x02	; 2
    2458:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    245c:	e0 91 59 02 	lds	r30, 0x0259
    2460:	f0 91 5a 02 	lds	r31, 0x025A
    2464:	13 83       	std	Z+3, r17	; 0x03
    2466:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2468:	80 91 60 02 	lds	r24, 0x0260
    246c:	90 91 61 02 	lds	r25, 0x0261
    2470:	bf 01       	movw	r22, r30
    2472:	6e 5f       	subi	r22, 0xFE	; 254
    2474:	7f 4f       	sbci	r23, 0xFF	; 255
    2476:	08 17       	cp	r16, r24
    2478:	19 07       	cpc	r17, r25
    247a:	28 f4       	brcc	.+10     	; 0x2486 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    247c:	80 91 88 02 	lds	r24, 0x0288
    2480:	90 91 89 02 	lds	r25, 0x0289
    2484:	04 c0       	rjmp	.+8      	; 0x248e <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2486:	80 91 86 02 	lds	r24, 0x0286
    248a:	90 91 87 02 	lds	r25, 0x0287
    248e:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <vListInsert>
	}

	if( pxEventList )
    2492:	20 97       	sbiw	r28, 0x00	; 0
    2494:	49 f0       	breq	.+18     	; 0x24a8 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2496:	60 91 59 02 	lds	r22, 0x0259
    249a:	70 91 5a 02 	lds	r23, 0x025A
    249e:	64 5f       	subi	r22, 0xF4	; 244
    24a0:	7f 4f       	sbci	r23, 0xFF	; 255
    24a2:	ce 01       	movw	r24, r28
    24a4:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <vListInsert>
	}
}
    24a8:	df 91       	pop	r29
    24aa:	cf 91       	pop	r28
    24ac:	1f 91       	pop	r17
    24ae:	0f 91       	pop	r16
    24b0:	08 95       	ret

000024b2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    24b2:	af 92       	push	r10
    24b4:	bf 92       	push	r11
    24b6:	cf 92       	push	r12
    24b8:	df 92       	push	r13
    24ba:	ef 92       	push	r14
    24bc:	ff 92       	push	r15
    24be:	0f 93       	push	r16
    24c0:	1f 93       	push	r17
    24c2:	cf 93       	push	r28
    24c4:	df 93       	push	r29
    24c6:	6c 01       	movw	r12, r24
    24c8:	b6 2e       	mov	r11, r22
    24ca:	a4 2e       	mov	r10, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    24cc:	8a e1       	ldi	r24, 0x1A	; 26
    24ce:	90 e0       	ldi	r25, 0x00	; 0
    24d0:	0e 94 74 14 	call	0x28e8	; 0x28e8 <pvPortMalloc>
    24d4:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    24d6:	00 97       	sbiw	r24, 0x00	; 0
    24d8:	11 f4       	brne	.+4      	; 0x24de <xCoRoutineCreate+0x2c>
    24da:	8f ef       	ldi	r24, 0xFF	; 255
    24dc:	59 c0       	rjmp	.+178    	; 0x2590 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    24de:	80 91 59 02 	lds	r24, 0x0259
    24e2:	90 91 5a 02 	lds	r25, 0x025A
    24e6:	89 2b       	or	r24, r25
    24e8:	21 f5       	brne	.+72     	; 0x2532 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    24ea:	d0 93 5a 02 	sts	0x025A, r29
    24ee:	c0 93 59 02 	sts	0x0259, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    24f2:	82 e6       	ldi	r24, 0x62	; 98
    24f4:	92 e0       	ldi	r25, 0x02	; 2
    24f6:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
    24fa:	8b e6       	ldi	r24, 0x6B	; 107
    24fc:	92 e0       	ldi	r25, 0x02	; 2
    24fe:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    2502:	24 e7       	ldi	r18, 0x74	; 116
    2504:	e2 2e       	mov	r14, r18
    2506:	22 e0       	ldi	r18, 0x02	; 2
    2508:	f2 2e       	mov	r15, r18
    250a:	c7 01       	movw	r24, r14
    250c:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2510:	0d e7       	ldi	r16, 0x7D	; 125
    2512:	12 e0       	ldi	r17, 0x02	; 2
    2514:	c8 01       	movw	r24, r16
    2516:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    251a:	8a e8       	ldi	r24, 0x8A	; 138
    251c:	92 e0       	ldi	r25, 0x02	; 2
    251e:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2522:	f0 92 87 02 	sts	0x0287, r15
    2526:	e0 92 86 02 	sts	0x0286, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    252a:	10 93 89 02 	sts	0x0289, r17
    252e:	00 93 88 02 	sts	0x0288, r16
    2532:	eb 2c       	mov	r14, r11
    2534:	bb 20       	and	r11, r11
    2536:	11 f0       	breq	.+4      	; 0x253c <xCoRoutineCreate+0x8a>
    2538:	ee 24       	eor	r14, r14
    253a:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    253c:	19 8e       	std	Y+25, r1	; 0x19
    253e:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2540:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2542:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2544:	fe 01       	movw	r30, r28
    2546:	c1 92       	st	Z+, r12
    2548:	d1 92       	st	Z+, r13
    254a:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    254c:	cf 01       	movw	r24, r30
    254e:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2552:	ce 01       	movw	r24, r28
    2554:	0c 96       	adiw	r24, 0x0c	; 12
    2556:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    255a:	d9 87       	std	Y+9, r29	; 0x09
    255c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    255e:	db 8b       	std	Y+19, r29	; 0x13
    2560:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2562:	82 e0       	ldi	r24, 0x02	; 2
    2564:	90 e0       	ldi	r25, 0x00	; 0
    2566:	8e 19       	sub	r24, r14
    2568:	91 09       	sbc	r25, r1
    256a:	9d 87       	std	Y+13, r25	; 0x0d
    256c:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    256e:	9e 89       	ldd	r25, Y+22	; 0x16
    2570:	80 91 5b 02 	lds	r24, 0x025B
    2574:	89 17       	cp	r24, r25
    2576:	10 f4       	brcc	.+4      	; 0x257c <xCoRoutineCreate+0xca>
    2578:	90 93 5b 02 	sts	0x025B, r25
    257c:	89 e0       	ldi	r24, 0x09	; 9
    257e:	98 9f       	mul	r25, r24
    2580:	c0 01       	movw	r24, r0
    2582:	11 24       	eor	r1, r1
    2584:	8e 59       	subi	r24, 0x9E	; 158
    2586:	9d 4f       	sbci	r25, 0xFD	; 253
    2588:	b8 01       	movw	r22, r16
    258a:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
    258e:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}
    2590:	df 91       	pop	r29
    2592:	cf 91       	pop	r28
    2594:	1f 91       	pop	r17
    2596:	0f 91       	pop	r16
    2598:	ff 90       	pop	r15
    259a:	ef 90       	pop	r14
    259c:	df 90       	pop	r13
    259e:	cf 90       	pop	r12
    25a0:	bf 90       	pop	r11
    25a2:	af 90       	pop	r10
    25a4:	08 95       	ret

000025a6 <xEventGroupClearBits>:
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    25a6:	fc 01       	movw	r30, r24

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    25a8:	0f b6       	in	r0, 0x3f	; 63
    25aa:	f8 94       	cli
    25ac:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    25ae:	20 81       	ld	r18, Z
    25b0:	31 81       	ldd	r19, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    25b2:	60 95       	com	r22
    25b4:	70 95       	com	r23
    25b6:	62 23       	and	r22, r18
    25b8:	73 23       	and	r23, r19
    25ba:	71 83       	std	Z+1, r23	; 0x01
    25bc:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
    25be:	0f 90       	pop	r0
    25c0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    25c2:	c9 01       	movw	r24, r18
    25c4:	08 95       	ret

000025c6 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    25c6:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
    25c8:	80 81       	ld	r24, Z
    25ca:	91 81       	ldd	r25, Z+1	; 0x01
    25cc:	08 95       	ret

000025ce <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    25ce:	ba 01       	movw	r22, r20
    25d0:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <xEventGroupClearBits>
}
    25d4:	08 95       	ret

000025d6 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    25d6:	cf 93       	push	r28
    25d8:	df 93       	push	r29
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    25da:	ec 01       	movw	r28, r24
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
    25dc:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskSuspendAll>
    25e0:	06 c0       	rjmp	.+12     	; 0x25ee <vEventGroupDelete+0x18>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    25e2:	8f 81       	ldd	r24, Y+7	; 0x07
    25e4:	98 85       	ldd	r25, Y+8	; 0x08
    25e6:	60 e0       	ldi	r22, 0x00	; 0
    25e8:	72 e0       	ldi	r23, 0x02	; 2
    25ea:	0e 94 bf 1b 	call	0x377e	; 0x377e <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    25ee:	8a 81       	ldd	r24, Y+2	; 0x02
    25f0:	88 23       	and	r24, r24
    25f2:	b9 f7       	brne	.-18     	; 0x25e2 <vEventGroupDelete+0xc>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    25f4:	ce 01       	movw	r24, r28
    25f6:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortFree>
	}
	( void ) xTaskResumeAll();
    25fa:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
}
    25fe:	df 91       	pop	r29
    2600:	cf 91       	pop	r28
    2602:	08 95       	ret

00002604 <xEventGroupSetBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2604:	cf 92       	push	r12
    2606:	df 92       	push	r13
    2608:	ef 92       	push	r14
    260a:	ff 92       	push	r15
    260c:	0f 93       	push	r16
    260e:	1f 93       	push	r17
    2610:	cf 93       	push	r28
    2612:	df 93       	push	r29
    2614:	8b 01       	movw	r16, r22
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2616:	ec 01       	movw	r28, r24
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2618:	85 e0       	ldi	r24, 0x05	; 5
    261a:	e8 2e       	mov	r14, r24
    261c:	f1 2c       	mov	r15, r1
    261e:	ec 0e       	add	r14, r28
    2620:	fd 1e       	adc	r15, r29
	vTaskSuspendAll();
    2622:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2626:	ef 81       	ldd	r30, Y+7	; 0x07
    2628:	f8 85       	ldd	r31, Y+8	; 0x08

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    262a:	88 81       	ld	r24, Y
    262c:	99 81       	ldd	r25, Y+1	; 0x01
    262e:	80 2b       	or	r24, r16
    2630:	91 2b       	or	r25, r17
    2632:	99 83       	std	Y+1, r25	; 0x01
    2634:	88 83       	st	Y, r24
    2636:	00 e0       	ldi	r16, 0x00	; 0
    2638:	10 e0       	ldi	r17, 0x00	; 0
    263a:	24 c0       	rjmp	.+72     	; 0x2684 <xEventGroupSetBits+0x80>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    263c:	d2 80       	ldd	r13, Z+2	; 0x02
    263e:	c3 80       	ldd	r12, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2640:	80 81       	ld	r24, Z
    2642:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2644:	bc 01       	movw	r22, r24
    2646:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2648:	ac 01       	movw	r20, r24
    264a:	50 70       	andi	r21, 0x00	; 0
    264c:	28 81       	ld	r18, Y
    264e:	39 81       	ldd	r19, Y+1	; 0x01

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2650:	92 fd       	sbrc	r25, 2
    2652:	05 c0       	rjmp	.+10     	; 0x265e <xEventGroupSetBits+0x5a>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2654:	24 23       	and	r18, r20
    2656:	35 23       	and	r19, r21
    2658:	23 2b       	or	r18, r19
    265a:	31 f4       	brne	.+12     	; 0x2668 <xEventGroupSetBits+0x64>
    265c:	0f c0       	rjmp	.+30     	; 0x267c <xEventGroupSetBits+0x78>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    265e:	24 23       	and	r18, r20
    2660:	35 23       	and	r19, r21
    2662:	24 17       	cp	r18, r20
    2664:	35 07       	cpc	r19, r21
    2666:	51 f4       	brne	.+20     	; 0x267c <xEventGroupSetBits+0x78>
			}

			if( xMatchFound != pdFALSE )
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2668:	70 ff       	sbrs	r23, 0
    266a:	02 c0       	rjmp	.+4      	; 0x2670 <xEventGroupSetBits+0x6c>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    266c:	04 2b       	or	r16, r20
    266e:	15 2b       	or	r17, r21
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2670:	68 81       	ld	r22, Y
    2672:	79 81       	ldd	r23, Y+1	; 0x01
    2674:	72 60       	ori	r23, 0x02	; 2
    2676:	cf 01       	movw	r24, r30
    2678:	0e 94 bf 1b 	call	0x377e	; 0x377e <xTaskRemoveFromUnorderedEventList>
    267c:	8d 2d       	mov	r24, r13
    267e:	9c 2d       	mov	r25, r12
    2680:	9c 01       	movw	r18, r24
    2682:	f9 01       	movw	r30, r18

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2684:	ee 15       	cp	r30, r14
    2686:	ff 05       	cpc	r31, r15
    2688:	c9 f6       	brne	.-78     	; 0x263c <xEventGroupSetBits+0x38>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    268a:	00 95       	com	r16
    268c:	10 95       	com	r17
    268e:	88 81       	ld	r24, Y
    2690:	99 81       	ldd	r25, Y+1	; 0x01
    2692:	80 23       	and	r24, r16
    2694:	91 23       	and	r25, r17
    2696:	99 83       	std	Y+1, r25	; 0x01
    2698:	88 83       	st	Y, r24
	}
	( void ) xTaskResumeAll();
    269a:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
    269e:	88 81       	ld	r24, Y
    26a0:	99 81       	ldd	r25, Y+1	; 0x01
    26a2:	df 91       	pop	r29
    26a4:	cf 91       	pop	r28
    26a6:	1f 91       	pop	r17
    26a8:	0f 91       	pop	r16
    26aa:	ff 90       	pop	r15
    26ac:	ef 90       	pop	r14
    26ae:	df 90       	pop	r13
    26b0:	cf 90       	pop	r12
    26b2:	08 95       	ret

000026b4 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    26b4:	ba 01       	movw	r22, r20
    26b6:	0e 94 02 13 	call	0x2604	; 0x2604 <xEventGroupSetBits>
}
    26ba:	08 95       	ret

000026bc <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    26bc:	af 92       	push	r10
    26be:	bf 92       	push	r11
    26c0:	cf 92       	push	r12
    26c2:	df 92       	push	r13
    26c4:	ef 92       	push	r14
    26c6:	ff 92       	push	r15
    26c8:	0f 93       	push	r16
    26ca:	1f 93       	push	r17
    26cc:	cf 93       	push	r28
    26ce:	df 93       	push	r29
    26d0:	7b 01       	movw	r14, r22
    26d2:	a4 2e       	mov	r10, r20
    26d4:	b2 2e       	mov	r11, r18
    26d6:	68 01       	movw	r12, r16
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    26d8:	8c 01       	movw	r16, r24
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    26da:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    26de:	f8 01       	movw	r30, r16
    26e0:	20 81       	ld	r18, Z
    26e2:	31 81       	ldd	r19, Z+1	; 0x01
    26e4:	c7 01       	movw	r24, r14
    26e6:	82 23       	and	r24, r18
    26e8:	93 23       	and	r25, r19

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    26ea:	bb 20       	and	r11, r11
    26ec:	21 f4       	brne	.+8      	; 0x26f6 <xEventGroupWaitBits+0x3a>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    26ee:	89 2b       	or	r24, r25
    26f0:	09 f0       	breq	.+2      	; 0x26f4 <xEventGroupWaitBits+0x38>
    26f2:	5a c0       	rjmp	.+180    	; 0x27a8 <xEventGroupWaitBits+0xec>
    26f4:	04 c0       	rjmp	.+8      	; 0x26fe <xEventGroupWaitBits+0x42>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    26f6:	8e 15       	cp	r24, r14
    26f8:	9f 05       	cpc	r25, r15
    26fa:	09 f4       	brne	.+2      	; 0x26fe <xEventGroupWaitBits+0x42>
    26fc:	55 c0       	rjmp	.+170    	; 0x27a8 <xEventGroupWaitBits+0xec>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    26fe:	c1 14       	cp	r12, r1
    2700:	d1 04       	cpc	r13, r1
    2702:	59 f4       	brne	.+22     	; 0x271a <xEventGroupWaitBits+0x5e>
    2704:	e9 01       	movw	r28, r18
    2706:	1b c0       	rjmp	.+54     	; 0x273e <xEventGroupWaitBits+0x82>
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2708:	c7 01       	movw	r24, r14
    270a:	80 95       	com	r24
    270c:	90 95       	com	r25
    270e:	82 23       	and	r24, r18
    2710:	93 23       	and	r25, r19
    2712:	f8 01       	movw	r30, r16
    2714:	91 83       	std	Z+1, r25	; 0x01
    2716:	80 83       	st	Z, r24
    2718:	4a c0       	rjmp	.+148    	; 0x27ae <xEventGroupWaitBits+0xf2>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    271a:	aa 20       	and	r10, r10
    271c:	19 f0       	breq	.+6      	; 0x2724 <xEventGroupWaitBits+0x68>
    271e:	60 e0       	ldi	r22, 0x00	; 0
    2720:	71 e0       	ldi	r23, 0x01	; 1
    2722:	02 c0       	rjmp	.+4      	; 0x2728 <xEventGroupWaitBits+0x6c>
    2724:	60 e0       	ldi	r22, 0x00	; 0
    2726:	70 e0       	ldi	r23, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2728:	b1 10       	cpse	r11, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    272a:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    272c:	6e 29       	or	r22, r14
    272e:	7f 29       	or	r23, r15
    2730:	c8 01       	movw	r24, r16
    2732:	02 96       	adiw	r24, 0x02	; 2
    2734:	a6 01       	movw	r20, r12
    2736:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <vTaskPlaceOnUnorderedEventList>
    273a:	c0 e0       	ldi	r28, 0x00	; 0
    273c:	d0 e0       	ldi	r29, 0x00	; 0
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    273e:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
    2742:	cd 28       	or	r12, r13
    2744:	29 f1       	breq	.+74     	; 0x2790 <xEventGroupWaitBits+0xd4>
	{
		if( xAlreadyYielded == pdFALSE )
    2746:	88 23       	and	r24, r24
    2748:	11 f4       	brne	.+4      	; 0x274e <xEventGroupWaitBits+0x92>
		{
			portYIELD_WITHIN_API();
    274a:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    274e:	0e 94 a7 1b 	call	0x374e	; 0x374e <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2752:	91 fd       	sbrc	r25, 1
    2754:	1b c0       	rjmp	.+54     	; 0x278c <xEventGroupWaitBits+0xd0>
		{
			taskENTER_CRITICAL();
    2756:	0f b6       	in	r0, 0x3f	; 63
    2758:	f8 94       	cli
    275a:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    275c:	f8 01       	movw	r30, r16
    275e:	80 81       	ld	r24, Z
    2760:	91 81       	ldd	r25, Z+1	; 0x01
    2762:	97 01       	movw	r18, r14
    2764:	28 23       	and	r18, r24
    2766:	39 23       	and	r19, r25

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    2768:	bb 20       	and	r11, r11
    276a:	19 f4       	brne	.+6      	; 0x2772 <xEventGroupWaitBits+0xb6>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    276c:	23 2b       	or	r18, r19
    276e:	19 f5       	brne	.+70     	; 0x27b6 <xEventGroupWaitBits+0xfa>
    2770:	0b c0       	rjmp	.+22     	; 0x2788 <xEventGroupWaitBits+0xcc>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2772:	2e 15       	cp	r18, r14
    2774:	3f 05       	cpc	r19, r15
    2776:	41 f4       	brne	.+16     	; 0x2788 <xEventGroupWaitBits+0xcc>
    2778:	1e c0       	rjmp	.+60     	; 0x27b6 <xEventGroupWaitBits+0xfa>
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
				{
					if( xClearOnExit != pdFALSE )
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    277a:	e0 94       	com	r14
    277c:	f0 94       	com	r15
    277e:	e8 22       	and	r14, r24
    2780:	f9 22       	and	r15, r25
    2782:	f8 01       	movw	r30, r16
    2784:	f1 82       	std	Z+1, r15	; 0x01
    2786:	e0 82       	st	Z, r14
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2788:	0f 90       	pop	r0
    278a:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    278c:	ec 01       	movw	r28, r24
    278e:	d0 70       	andi	r29, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
    2790:	ce 01       	movw	r24, r28
    2792:	df 91       	pop	r29
    2794:	cf 91       	pop	r28
    2796:	1f 91       	pop	r17
    2798:	0f 91       	pop	r16
    279a:	ff 90       	pop	r15
    279c:	ef 90       	pop	r14
    279e:	df 90       	pop	r13
    27a0:	cf 90       	pop	r12
    27a2:	bf 90       	pop	r11
    27a4:	af 90       	pop	r10
    27a6:	08 95       	ret
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    27a8:	aa 20       	and	r10, r10
    27aa:	09 f0       	breq	.+2      	; 0x27ae <xEventGroupWaitBits+0xf2>
    27ac:	ad cf       	rjmp	.-166    	; 0x2708 <xEventGroupWaitBits+0x4c>
    27ae:	e9 01       	movw	r28, r18
    27b0:	cc 24       	eor	r12, r12
    27b2:	dd 24       	eor	r13, r13
    27b4:	c4 cf       	rjmp	.-120    	; 0x273e <xEventGroupWaitBits+0x82>

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
				{
					if( xClearOnExit != pdFALSE )
    27b6:	aa 20       	and	r10, r10
    27b8:	01 f7       	brne	.-64     	; 0x277a <xEventGroupWaitBits+0xbe>
    27ba:	e6 cf       	rjmp	.-52     	; 0x2788 <xEventGroupWaitBits+0xcc>

000027bc <xEventGroupSync>:
	return ( EventGroupHandle_t ) pxEventBits;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    27bc:	8f 92       	push	r8
    27be:	9f 92       	push	r9
    27c0:	af 92       	push	r10
    27c2:	bf 92       	push	r11
    27c4:	cf 92       	push	r12
    27c6:	df 92       	push	r13
    27c8:	ef 92       	push	r14
    27ca:	ff 92       	push	r15
    27cc:	0f 93       	push	r16
    27ce:	1f 93       	push	r17
    27d0:	cf 93       	push	r28
    27d2:	df 93       	push	r29
    27d4:	f8 2e       	mov	r15, r24
    27d6:	e9 2e       	mov	r14, r25
    27d8:	8b 01       	movw	r16, r22
    27da:	5a 01       	movw	r10, r20
    27dc:	49 01       	movw	r8, r18
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    27de:	c8 2e       	mov	r12, r24
    27e0:	d9 2e       	mov	r13, r25
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    27e2:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    27e6:	f6 01       	movw	r30, r12
    27e8:	c0 81       	ld	r28, Z
    27ea:	d1 81       	ldd	r29, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    27ec:	8f 2d       	mov	r24, r15
    27ee:	9e 2d       	mov	r25, r14
    27f0:	b8 01       	movw	r22, r16
    27f2:	0e 94 02 13 	call	0x2604	; 0x2604 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    27f6:	c0 2b       	or	r28, r16
    27f8:	d1 2b       	or	r29, r17
    27fa:	c5 01       	movw	r24, r10
    27fc:	8c 23       	and	r24, r28
    27fe:	9d 23       	and	r25, r29
    2800:	8a 15       	cp	r24, r10
    2802:	9b 05       	cpc	r25, r11
    2804:	69 f4       	brne	.+26     	; 0x2820 <xEventGroupSync+0x64>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2806:	95 01       	movw	r18, r10
    2808:	20 95       	com	r18
    280a:	30 95       	com	r19
    280c:	f6 01       	movw	r30, r12
    280e:	80 81       	ld	r24, Z
    2810:	91 81       	ldd	r25, Z+1	; 0x01
    2812:	82 23       	and	r24, r18
    2814:	93 23       	and	r25, r19
    2816:	91 83       	std	Z+1, r25	; 0x01
    2818:	80 83       	st	Z, r24
    281a:	88 24       	eor	r8, r8
    281c:	99 24       	eor	r9, r9
    281e:	10 c0       	rjmp	.+32     	; 0x2840 <xEventGroupSync+0x84>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2820:	81 14       	cp	r8, r1
    2822:	91 04       	cpc	r9, r1
    2824:	51 f0       	breq	.+20     	; 0x283a <xEventGroupSync+0x7e>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2826:	b5 01       	movw	r22, r10
    2828:	75 60       	ori	r23, 0x05	; 5
    282a:	c6 01       	movw	r24, r12
    282c:	02 96       	adiw	r24, 0x02	; 2
    282e:	a4 01       	movw	r20, r8
    2830:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <vTaskPlaceOnUnorderedEventList>
    2834:	c0 e0       	ldi	r28, 0x00	; 0
    2836:	d0 e0       	ldi	r29, 0x00	; 0
    2838:	03 c0       	rjmp	.+6      	; 0x2840 <xEventGroupSync+0x84>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    283a:	f6 01       	movw	r30, r12
    283c:	c0 81       	ld	r28, Z
    283e:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2840:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
    2844:	89 28       	or	r8, r9
    2846:	f9 f0       	breq	.+62     	; 0x2886 <xEventGroupSync+0xca>
	{
		if( xAlreadyYielded == pdFALSE )
    2848:	88 23       	and	r24, r24
    284a:	11 f4       	brne	.+4      	; 0x2850 <xEventGroupSync+0x94>
		{
			portYIELD_WITHIN_API();
    284c:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2850:	0e 94 a7 1b 	call	0x374e	; 0x374e <uxTaskResetEventItemValue>
    2854:	9c 01       	movw	r18, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2856:	91 fd       	sbrc	r25, 1
    2858:	14 c0       	rjmp	.+40     	; 0x2882 <xEventGroupSync+0xc6>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    285a:	0f b6       	in	r0, 0x3f	; 63
    285c:	f8 94       	cli
    285e:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2860:	f6 01       	movw	r30, r12
    2862:	20 81       	ld	r18, Z
    2864:	31 81       	ldd	r19, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2866:	c5 01       	movw	r24, r10
    2868:	82 23       	and	r24, r18
    286a:	93 23       	and	r25, r19
    286c:	8a 15       	cp	r24, r10
    286e:	9b 05       	cpc	r25, r11
    2870:	31 f4       	brne	.+12     	; 0x287e <xEventGroupSync+0xc2>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2872:	a0 94       	com	r10
    2874:	b0 94       	com	r11
    2876:	a2 22       	and	r10, r18
    2878:	b3 22       	and	r11, r19
    287a:	b1 82       	std	Z+1, r11	; 0x01
    287c:	a0 82       	st	Z, r10
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    287e:	0f 90       	pop	r0
    2880:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2882:	e9 01       	movw	r28, r18
    2884:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
    2886:	ce 01       	movw	r24, r28
    2888:	df 91       	pop	r29
    288a:	cf 91       	pop	r28
    288c:	1f 91       	pop	r17
    288e:	0f 91       	pop	r16
    2890:	ff 90       	pop	r15
    2892:	ef 90       	pop	r14
    2894:	df 90       	pop	r13
    2896:	cf 90       	pop	r12
    2898:	bf 90       	pop	r11
    289a:	af 90       	pop	r10
    289c:	9f 90       	pop	r9
    289e:	8f 90       	pop	r8
    28a0:	08 95       	ret

000028a2 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    28a2:	cf 93       	push	r28
    28a4:	df 93       	push	r29
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    28a6:	8b e0       	ldi	r24, 0x0B	; 11
    28a8:	90 e0       	ldi	r25, 0x00	; 0
    28aa:	0e 94 74 14 	call	0x28e8	; 0x28e8 <pvPortMalloc>
    28ae:	ec 01       	movw	r28, r24
	if( pxEventBits != NULL )
    28b0:	00 97       	sbiw	r24, 0x00	; 0
    28b2:	31 f0       	breq	.+12     	; 0x28c0 <xEventGroupCreate+0x1e>
	{
		pxEventBits->uxEventBits = 0;
    28b4:	fc 01       	movw	r30, r24
    28b6:	11 92       	st	Z+, r1
    28b8:	11 92       	st	Z+, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    28ba:	cf 01       	movw	r24, r30
    28bc:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
}
    28c0:	ce 01       	movw	r24, r28
    28c2:	df 91       	pop	r29
    28c4:	cf 91       	pop	r28
    28c6:	08 95       	ret

000028c8 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    28c8:	08 95       	ret

000028ca <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    28ca:	10 92 94 02 	sts	0x0294, r1
    28ce:	10 92 93 02 	sts	0x0293, r1
}
    28d2:	08 95       	ret

000028d4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    28d4:	23 e1       	ldi	r18, 0x13	; 19
    28d6:	35 e0       	ldi	r19, 0x05	; 5
    28d8:	80 91 93 02 	lds	r24, 0x0293
    28dc:	90 91 94 02 	lds	r25, 0x0294
    28e0:	28 1b       	sub	r18, r24
    28e2:	39 0b       	sbc	r19, r25
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    28e4:	c9 01       	movw	r24, r18
    28e6:	08 95       	ret

000028e8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    28e8:	cf 93       	push	r28
    28ea:	df 93       	push	r29
    28ec:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    28ee:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    28f2:	80 91 95 02 	lds	r24, 0x0295
    28f6:	90 91 96 02 	lds	r25, 0x0296
    28fa:	89 2b       	or	r24, r25
    28fc:	31 f4       	brne	.+12     	; 0x290a <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    28fe:	88 e9       	ldi	r24, 0x98	; 152
    2900:	92 e0       	ldi	r25, 0x02	; 2
    2902:	90 93 96 02 	sts	0x0296, r25
    2906:	80 93 95 02 	sts	0x0295, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    290a:	20 91 93 02 	lds	r18, 0x0293
    290e:	30 91 94 02 	lds	r19, 0x0294
    2912:	ce 01       	movw	r24, r28
    2914:	82 0f       	add	r24, r18
    2916:	93 1f       	adc	r25, r19
    2918:	45 e0       	ldi	r20, 0x05	; 5
    291a:	83 31       	cpi	r24, 0x13	; 19
    291c:	94 07       	cpc	r25, r20
    291e:	70 f4       	brcc	.+28     	; 0x293c <pvPortMalloc+0x54>
    2920:	28 17       	cp	r18, r24
    2922:	39 07       	cpc	r19, r25
    2924:	58 f4       	brcc	.+22     	; 0x293c <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2926:	c0 91 95 02 	lds	r28, 0x0295
    292a:	d0 91 96 02 	lds	r29, 0x0296
    292e:	c2 0f       	add	r28, r18
    2930:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2932:	90 93 94 02 	sts	0x0294, r25
    2936:	80 93 93 02 	sts	0x0293, r24
    293a:	02 c0       	rjmp	.+4      	; 0x2940 <pvPortMalloc+0x58>
    293c:	c0 e0       	ldi	r28, 0x00	; 0
    293e:	d0 e0       	ldi	r29, 0x00	; 0
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2940:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2944:	ce 01       	movw	r24, r28
    2946:	df 91       	pop	r29
    2948:	cf 91       	pop	r28
    294a:	08 95       	ret

0000294c <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    294c:	9f 92       	push	r9
    294e:	af 92       	push	r10
    2950:	bf 92       	push	r11
    2952:	cf 92       	push	r12
    2954:	df 92       	push	r13
    2956:	ef 92       	push	r14
    2958:	ff 92       	push	r15
    295a:	0f 93       	push	r16
    295c:	1f 93       	push	r17
    295e:	df 93       	push	r29
    2960:	cf 93       	push	r28
    2962:	00 d0       	rcall	.+0      	; 0x2964 <vCompeteingIntMathTask+0x18>
    2964:	00 d0       	rcall	.+0      	; 0x2966 <vCompeteingIntMathTask+0x1a>
    2966:	cd b7       	in	r28, 0x3d	; 61
    2968:	de b7       	in	r29, 0x3e	; 62
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    296a:	8c 01       	movw	r16, r24
    296c:	ee 24       	eor	r14, r14
    296e:	ff 24       	eor	r15, r15
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2970:	9b e7       	ldi	r25, 0x7B	; 123
    2972:	a9 2e       	mov	r10, r25
    2974:	b1 2c       	mov	r11, r1
    2976:	c1 2c       	mov	r12, r1
    2978:	d1 2c       	mov	r13, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    297a:	99 24       	eor	r9, r9
    297c:	93 94       	inc	r9
    297e:	03 c0       	rjmp	.+6      	; 0x2986 <vCompeteingIntMathTask+0x3a>
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    2980:	81 e0       	ldi	r24, 0x01	; 1
    2982:	e8 2e       	mov	r14, r24
    2984:	f1 2c       	mov	r15, r1
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2986:	a9 82       	std	Y+1, r10	; 0x01
    2988:	ba 82       	std	Y+2, r11	; 0x02
    298a:	cb 82       	std	Y+3, r12	; 0x03
    298c:	dc 82       	std	Y+4, r13	; 0x04
		lValue += intgCONST2;
    298e:	89 81       	ldd	r24, Y+1	; 0x01
    2990:	9a 81       	ldd	r25, Y+2	; 0x02
    2992:	ab 81       	ldd	r26, Y+3	; 0x03
    2994:	bc 81       	ldd	r27, Y+4	; 0x04
    2996:	89 5b       	subi	r24, 0xB9	; 185
    2998:	9b 46       	sbci	r25, 0x6B	; 107
    299a:	ac 4f       	sbci	r26, 0xFC	; 252
    299c:	bf 4f       	sbci	r27, 0xFF	; 255
    299e:	89 83       	std	Y+1, r24	; 0x01
    29a0:	9a 83       	std	Y+2, r25	; 0x02
    29a2:	ab 83       	std	Y+3, r26	; 0x03
    29a4:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    29a6:	69 81       	ldd	r22, Y+1	; 0x01
    29a8:	7a 81       	ldd	r23, Y+2	; 0x02
    29aa:	8b 81       	ldd	r24, Y+3	; 0x03
    29ac:	9c 81       	ldd	r25, Y+4	; 0x04
    29ae:	2d ef       	ldi	r18, 0xFD	; 253
    29b0:	3f ef       	ldi	r19, 0xFF	; 255
    29b2:	4f ef       	ldi	r20, 0xFF	; 255
    29b4:	5f ef       	ldi	r21, 0xFF	; 255
    29b6:	0e 94 60 22 	call	0x44c0	; 0x44c0 <__mulsi3>
    29ba:	69 83       	std	Y+1, r22	; 0x01
    29bc:	7a 83       	std	Y+2, r23	; 0x02
    29be:	8b 83       	std	Y+3, r24	; 0x03
    29c0:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    29c2:	69 81       	ldd	r22, Y+1	; 0x01
    29c4:	7a 81       	ldd	r23, Y+2	; 0x02
    29c6:	8b 81       	ldd	r24, Y+3	; 0x03
    29c8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ca:	27 e0       	ldi	r18, 0x07	; 7
    29cc:	30 e0       	ldi	r19, 0x00	; 0
    29ce:	40 e0       	ldi	r20, 0x00	; 0
    29d0:	50 e0       	ldi	r21, 0x00	; 0
    29d2:	0e 94 c8 22 	call	0x4590	; 0x4590 <__divmodsi4>
    29d6:	c9 01       	movw	r24, r18
    29d8:	da 01       	movw	r26, r20
    29da:	89 83       	std	Y+1, r24	; 0x01
    29dc:	9a 83       	std	Y+2, r25	; 0x02
    29de:	ab 83       	std	Y+3, r26	; 0x03
    29e0:	bc 83       	std	Y+4, r27	; 0x04

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    29e2:	89 81       	ldd	r24, Y+1	; 0x01
    29e4:	9a 81       	ldd	r25, Y+2	; 0x02
    29e6:	ab 81       	ldd	r26, Y+3	; 0x03
    29e8:	bc 81       	ldd	r27, Y+4	; 0x04
    29ea:	8b 51       	subi	r24, 0x1B	; 27
    29ec:	97 47       	sbci	r25, 0x77	; 119
    29ee:	ae 4f       	sbci	r26, 0xFE	; 254
    29f0:	bf 4f       	sbci	r27, 0xFF	; 255
    29f2:	31 f6       	brne	.-116    	; 0x2980 <vCompeteingIntMathTask+0x34>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    29f4:	e1 14       	cp	r14, r1
    29f6:	f1 04       	cpc	r15, r1
    29f8:	09 f0       	breq	.+2      	; 0x29fc <vCompeteingIntMathTask+0xb0>
    29fa:	c2 cf       	rjmp	.-124    	; 0x2980 <vCompeteingIntMathTask+0x34>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    29fc:	0f b6       	in	r0, 0x3f	; 63
    29fe:	f8 94       	cli
    2a00:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    2a02:	f8 01       	movw	r30, r16
    2a04:	90 82       	st	Z, r9
			portEXIT_CRITICAL();
    2a06:	0f 90       	pop	r0
    2a08:	0f be       	out	0x3f, r0	; 63
    2a0a:	bd cf       	rjmp	.-134    	; 0x2986 <vCompeteingIntMathTask+0x3a>

00002a0c <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    2a0c:	80 91 ab 07 	lds	r24, 0x07AB
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    2a10:	10 92 ab 07 	sts	0x07AB, r1
    2a14:	81 11       	cpse	r24, r1
    2a16:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    2a18:	08 95       	ret

00002a1a <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    2a1a:	af 92       	push	r10
    2a1c:	bf 92       	push	r11
    2a1e:	cf 92       	push	r12
    2a20:	df 92       	push	r13
    2a22:	ef 92       	push	r14
    2a24:	ff 92       	push	r15
    2a26:	0f 93       	push	r16
    2a28:	08 2f       	mov	r16, r24
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    2a2a:	86 ea       	ldi	r24, 0xA6	; 166
    2a2c:	94 e1       	ldi	r25, 0x14	; 20
    2a2e:	60 e7       	ldi	r22, 0x70	; 112
    2a30:	70 e0       	ldi	r23, 0x00	; 0
    2a32:	45 e5       	ldi	r20, 0x55	; 85
    2a34:	50 e0       	ldi	r21, 0x00	; 0
    2a36:	2b ea       	ldi	r18, 0xAB	; 171
    2a38:	37 e0       	ldi	r19, 0x07	; 7
    2a3a:	ee 24       	eor	r14, r14
    2a3c:	ff 24       	eor	r15, r15
    2a3e:	cc 24       	eor	r12, r12
    2a40:	dd 24       	eor	r13, r13
    2a42:	aa 24       	eor	r10, r10
    2a44:	bb 24       	eor	r11, r11
    2a46:	0e 94 85 20 	call	0x410a	; 0x410a <xTaskGenericCreate>
	}
}
    2a4a:	0f 91       	pop	r16
    2a4c:	ff 90       	pop	r15
    2a4e:	ef 90       	pop	r14
    2a50:	df 90       	pop	r13
    2a52:	cf 90       	pop	r12
    2a54:	bf 90       	pop	r11
    2a56:	af 90       	pop	r10
    2a58:	08 95       	ret

00002a5a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2a5a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2a5c:	9c 01       	movw	r18, r24
    2a5e:	2d 5f       	subi	r18, 0xFD	; 253
    2a60:	3f 4f       	sbci	r19, 0xFF	; 255
    2a62:	32 83       	std	Z+2, r19	; 0x02
    2a64:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2a66:	8f ef       	ldi	r24, 0xFF	; 255
    2a68:	9f ef       	ldi	r25, 0xFF	; 255
    2a6a:	94 83       	std	Z+4, r25	; 0x04
    2a6c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2a6e:	36 83       	std	Z+6, r19	; 0x06
    2a70:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2a72:	30 87       	std	Z+8, r19	; 0x08
    2a74:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2a76:	10 82       	st	Z, r1
}
    2a78:	08 95       	ret

00002a7a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	11 86       	std	Z+9, r1	; 0x09
    2a7e:	10 86       	std	Z+8, r1	; 0x08
}
    2a80:	08 95       	ret

00002a82 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2a82:	ac 01       	movw	r20, r24
ListItem_t * const pxIndex = pxList->pxIndex;
    2a84:	fc 01       	movw	r30, r24
    2a86:	a1 81       	ldd	r26, Z+1	; 0x01
    2a88:	b2 81       	ldd	r27, Z+2	; 0x02

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2a8a:	fb 01       	movw	r30, r22
    2a8c:	b3 83       	std	Z+3, r27	; 0x03
    2a8e:	a2 83       	std	Z+2, r26	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2a90:	14 96       	adiw	r26, 0x04	; 4
    2a92:	8d 91       	ld	r24, X+
    2a94:	9c 91       	ld	r25, X
    2a96:	15 97       	sbiw	r26, 0x05	; 5
    2a98:	95 83       	std	Z+5, r25	; 0x05
    2a9a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2a9c:	14 96       	adiw	r26, 0x04	; 4
    2a9e:	ed 91       	ld	r30, X+
    2aa0:	fc 91       	ld	r31, X
    2aa2:	15 97       	sbiw	r26, 0x05	; 5
    2aa4:	73 83       	std	Z+3, r23	; 0x03
    2aa6:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    2aa8:	15 96       	adiw	r26, 0x05	; 5
    2aaa:	7c 93       	st	X, r23
    2aac:	6e 93       	st	-X, r22
    2aae:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2ab0:	fb 01       	movw	r30, r22
    2ab2:	51 87       	std	Z+9, r21	; 0x09
    2ab4:	40 87       	std	Z+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    2ab6:	fa 01       	movw	r30, r20
    2ab8:	80 81       	ld	r24, Z
    2aba:	8f 5f       	subi	r24, 0xFF	; 255
    2abc:	80 83       	st	Z, r24
}
    2abe:	08 95       	ret

00002ac0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2ac0:	cf 93       	push	r28
    2ac2:	df 93       	push	r29
    2ac4:	9c 01       	movw	r18, r24
    2ac6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2ac8:	48 81       	ld	r20, Y
    2aca:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2acc:	8f ef       	ldi	r24, 0xFF	; 255
    2ace:	4f 3f       	cpi	r20, 0xFF	; 255
    2ad0:	58 07       	cpc	r21, r24
    2ad2:	21 f4       	brne	.+8      	; 0x2adc <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2ad4:	f9 01       	movw	r30, r18
    2ad6:	a7 81       	ldd	r26, Z+7	; 0x07
    2ad8:	b0 85       	ldd	r27, Z+8	; 0x08
    2ada:	0d c0       	rjmp	.+26     	; 0x2af6 <vListInsert+0x36>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2adc:	d9 01       	movw	r26, r18
    2ade:	13 96       	adiw	r26, 0x03	; 3
    2ae0:	12 96       	adiw	r26, 0x02	; 2
    2ae2:	ed 91       	ld	r30, X+
    2ae4:	fc 91       	ld	r31, X
    2ae6:	13 97       	sbiw	r26, 0x03	; 3
    2ae8:	80 81       	ld	r24, Z
    2aea:	91 81       	ldd	r25, Z+1	; 0x01
    2aec:	48 17       	cp	r20, r24
    2aee:	59 07       	cpc	r21, r25
    2af0:	10 f0       	brcs	.+4      	; 0x2af6 <vListInsert+0x36>
    2af2:	df 01       	movw	r26, r30
    2af4:	f5 cf       	rjmp	.-22     	; 0x2ae0 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2af6:	12 96       	adiw	r26, 0x02	; 2
    2af8:	ed 91       	ld	r30, X+
    2afa:	fc 91       	ld	r31, X
    2afc:	13 97       	sbiw	r26, 0x03	; 3
    2afe:	fb 83       	std	Y+3, r31	; 0x03
    2b00:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2b02:	d5 83       	std	Z+5, r29	; 0x05
    2b04:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2b06:	bd 83       	std	Y+5, r27	; 0x05
    2b08:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2b0a:	13 96       	adiw	r26, 0x03	; 3
    2b0c:	dc 93       	st	X, r29
    2b0e:	ce 93       	st	-X, r28
    2b10:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2b12:	39 87       	std	Y+9, r19	; 0x09
    2b14:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2b16:	f9 01       	movw	r30, r18
    2b18:	80 81       	ld	r24, Z
    2b1a:	8f 5f       	subi	r24, 0xFF	; 255
    2b1c:	80 83       	st	Z, r24
}
    2b1e:	df 91       	pop	r29
    2b20:	cf 91       	pop	r28
    2b22:	08 95       	ret

00002b24 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2b24:	cf 93       	push	r28
    2b26:	df 93       	push	r29
    2b28:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2b2a:	18 96       	adiw	r26, 0x08	; 8
    2b2c:	cd 91       	ld	r28, X+
    2b2e:	dc 91       	ld	r29, X
    2b30:	19 97       	sbiw	r26, 0x09	; 9

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2b32:	12 96       	adiw	r26, 0x02	; 2
    2b34:	4d 91       	ld	r20, X+
    2b36:	5c 91       	ld	r21, X
    2b38:	13 97       	sbiw	r26, 0x03	; 3
    2b3a:	14 96       	adiw	r26, 0x04	; 4
    2b3c:	8d 91       	ld	r24, X+
    2b3e:	9c 91       	ld	r25, X
    2b40:	15 97       	sbiw	r26, 0x05	; 5
    2b42:	fa 01       	movw	r30, r20
    2b44:	95 83       	std	Z+5, r25	; 0x05
    2b46:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2b48:	14 96       	adiw	r26, 0x04	; 4
    2b4a:	2d 91       	ld	r18, X+
    2b4c:	3c 91       	ld	r19, X
    2b4e:	15 97       	sbiw	r26, 0x05	; 5
    2b50:	f9 01       	movw	r30, r18
    2b52:	53 83       	std	Z+3, r21	; 0x03
    2b54:	42 83       	std	Z+2, r20	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2b56:	89 81       	ldd	r24, Y+1	; 0x01
    2b58:	9a 81       	ldd	r25, Y+2	; 0x02
    2b5a:	8a 17       	cp	r24, r26
    2b5c:	9b 07       	cpc	r25, r27
    2b5e:	11 f4       	brne	.+4      	; 0x2b64 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2b60:	3a 83       	std	Y+2, r19	; 0x02
    2b62:	29 83       	std	Y+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2b64:	19 96       	adiw	r26, 0x09	; 9
    2b66:	1c 92       	st	X, r1
    2b68:	1e 92       	st	-X, r1
    2b6a:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    2b6c:	88 81       	ld	r24, Y
    2b6e:	81 50       	subi	r24, 0x01	; 1
    2b70:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
    2b72:	df 91       	pop	r29
    2b74:	cf 91       	pop	r28
    2b76:	08 95       	ret

00002b78 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2b78:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2b7a:	91 e1       	ldi	r25, 0x11	; 17
    2b7c:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2b7e:	22 e2       	ldi	r18, 0x22	; 34
    2b80:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2b82:	83 e3       	ldi	r24, 0x33	; 51
    2b84:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2b86:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2b88:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2b8a:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2b8c:	80 e8       	ldi	r24, 0x80	; 128
    2b8e:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2b90:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2b92:	82 e0       	ldi	r24, 0x02	; 2
    2b94:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2b96:	83 e0       	ldi	r24, 0x03	; 3
    2b98:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2b9a:	84 e0       	ldi	r24, 0x04	; 4
    2b9c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2b9e:	85 e0       	ldi	r24, 0x05	; 5
    2ba0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2ba2:	86 e0       	ldi	r24, 0x06	; 6
    2ba4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2ba6:	87 e0       	ldi	r24, 0x07	; 7
    2ba8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2baa:	88 e0       	ldi	r24, 0x08	; 8
    2bac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2bae:	89 e0       	ldi	r24, 0x09	; 9
    2bb0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2bb2:	80 e1       	ldi	r24, 0x10	; 16
    2bb4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2bb6:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2bb8:	82 e1       	ldi	r24, 0x12	; 18
    2bba:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2bbc:	83 e1       	ldi	r24, 0x13	; 19
    2bbe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2bc0:	84 e1       	ldi	r24, 0x14	; 20
    2bc2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2bc4:	85 e1       	ldi	r24, 0x15	; 21
    2bc6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2bc8:	86 e1       	ldi	r24, 0x16	; 22
    2bca:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2bcc:	87 e1       	ldi	r24, 0x17	; 23
    2bce:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2bd0:	88 e1       	ldi	r24, 0x18	; 24
    2bd2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2bd4:	89 e1       	ldi	r24, 0x19	; 25
    2bd6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2bd8:	80 e2       	ldi	r24, 0x20	; 32
    2bda:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2bdc:	81 e2       	ldi	r24, 0x21	; 33
    2bde:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2be0:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2be2:	83 e2       	ldi	r24, 0x23	; 35
    2be4:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2be6:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2be8:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2bea:	86 e2       	ldi	r24, 0x26	; 38
    2bec:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2bee:	87 e2       	ldi	r24, 0x27	; 39
    2bf0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2bf2:	88 e2       	ldi	r24, 0x28	; 40
    2bf4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2bf6:	89 e2       	ldi	r24, 0x29	; 41
    2bf8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2bfa:	80 e3       	ldi	r24, 0x30	; 48
    2bfc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2bfe:	81 e3       	ldi	r24, 0x31	; 49
    2c00:	82 93       	st	-Z, r24
    2c02:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2c04:	cf 01       	movw	r24, r30
    2c06:	08 95       	ret

00002c08 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2c08:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    2c0a:	8c e7       	ldi	r24, 0x7C	; 124
    2c0c:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2c0e:	8b e0       	ldi	r24, 0x0B	; 11
    2c10:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2c12:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2c14:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    2c16:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2c18:	a0 91 ac 07 	lds	r26, 0x07AC
    2c1c:	b0 91 ad 07 	lds	r27, 0x07AD
    2c20:	cd 91       	ld	r28, X+
    2c22:	cd bf       	out	0x3d, r28	; 61
    2c24:	dd 91       	ld	r29, X+
    2c26:	de bf       	out	0x3e, r29	; 62
    2c28:	ff 91       	pop	r31
    2c2a:	ef 91       	pop	r30
    2c2c:	df 91       	pop	r29
    2c2e:	cf 91       	pop	r28
    2c30:	bf 91       	pop	r27
    2c32:	af 91       	pop	r26
    2c34:	9f 91       	pop	r25
    2c36:	8f 91       	pop	r24
    2c38:	7f 91       	pop	r23
    2c3a:	6f 91       	pop	r22
    2c3c:	5f 91       	pop	r21
    2c3e:	4f 91       	pop	r20
    2c40:	3f 91       	pop	r19
    2c42:	2f 91       	pop	r18
    2c44:	1f 91       	pop	r17
    2c46:	0f 91       	pop	r16
    2c48:	ff 90       	pop	r15
    2c4a:	ef 90       	pop	r14
    2c4c:	df 90       	pop	r13
    2c4e:	cf 90       	pop	r12
    2c50:	bf 90       	pop	r11
    2c52:	af 90       	pop	r10
    2c54:	9f 90       	pop	r9
    2c56:	8f 90       	pop	r8
    2c58:	7f 90       	pop	r7
    2c5a:	6f 90       	pop	r6
    2c5c:	5f 90       	pop	r5
    2c5e:	4f 90       	pop	r4
    2c60:	3f 90       	pop	r3
    2c62:	2f 90       	pop	r2
    2c64:	1f 90       	pop	r1
    2c66:	0f 90       	pop	r0
    2c68:	0f be       	out	0x3f, r0	; 63
    2c6a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2c6c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2c6e:	81 e0       	ldi	r24, 0x01	; 1
    2c70:	08 95       	ret

00002c72 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2c72:	08 95       	ret

00002c74 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c74:	0f 92       	push	r0
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	f8 94       	cli
    2c7a:	0f 92       	push	r0
    2c7c:	1f 92       	push	r1
    2c7e:	11 24       	eor	r1, r1
    2c80:	2f 92       	push	r2
    2c82:	3f 92       	push	r3
    2c84:	4f 92       	push	r4
    2c86:	5f 92       	push	r5
    2c88:	6f 92       	push	r6
    2c8a:	7f 92       	push	r7
    2c8c:	8f 92       	push	r8
    2c8e:	9f 92       	push	r9
    2c90:	af 92       	push	r10
    2c92:	bf 92       	push	r11
    2c94:	cf 92       	push	r12
    2c96:	df 92       	push	r13
    2c98:	ef 92       	push	r14
    2c9a:	ff 92       	push	r15
    2c9c:	0f 93       	push	r16
    2c9e:	1f 93       	push	r17
    2ca0:	2f 93       	push	r18
    2ca2:	3f 93       	push	r19
    2ca4:	4f 93       	push	r20
    2ca6:	5f 93       	push	r21
    2ca8:	6f 93       	push	r22
    2caa:	7f 93       	push	r23
    2cac:	8f 93       	push	r24
    2cae:	9f 93       	push	r25
    2cb0:	af 93       	push	r26
    2cb2:	bf 93       	push	r27
    2cb4:	cf 93       	push	r28
    2cb6:	df 93       	push	r29
    2cb8:	ef 93       	push	r30
    2cba:	ff 93       	push	r31
    2cbc:	a0 91 ac 07 	lds	r26, 0x07AC
    2cc0:	b0 91 ad 07 	lds	r27, 0x07AD
    2cc4:	0d b6       	in	r0, 0x3d	; 61
    2cc6:	0d 92       	st	X+, r0
    2cc8:	0e b6       	in	r0, 0x3e	; 62
    2cca:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2ccc:	0e 94 33 1c 	call	0x3866	; 0x3866 <xTaskIncrementTick>
    2cd0:	88 23       	and	r24, r24
    2cd2:	11 f0       	breq	.+4      	; 0x2cd8 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2cd4:	0e 94 12 1b 	call	0x3624	; 0x3624 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2cd8:	a0 91 ac 07 	lds	r26, 0x07AC
    2cdc:	b0 91 ad 07 	lds	r27, 0x07AD
    2ce0:	cd 91       	ld	r28, X+
    2ce2:	cd bf       	out	0x3d, r28	; 61
    2ce4:	dd 91       	ld	r29, X+
    2ce6:	de bf       	out	0x3e, r29	; 62
    2ce8:	ff 91       	pop	r31
    2cea:	ef 91       	pop	r30
    2cec:	df 91       	pop	r29
    2cee:	cf 91       	pop	r28
    2cf0:	bf 91       	pop	r27
    2cf2:	af 91       	pop	r26
    2cf4:	9f 91       	pop	r25
    2cf6:	8f 91       	pop	r24
    2cf8:	7f 91       	pop	r23
    2cfa:	6f 91       	pop	r22
    2cfc:	5f 91       	pop	r21
    2cfe:	4f 91       	pop	r20
    2d00:	3f 91       	pop	r19
    2d02:	2f 91       	pop	r18
    2d04:	1f 91       	pop	r17
    2d06:	0f 91       	pop	r16
    2d08:	ff 90       	pop	r15
    2d0a:	ef 90       	pop	r14
    2d0c:	df 90       	pop	r13
    2d0e:	cf 90       	pop	r12
    2d10:	bf 90       	pop	r11
    2d12:	af 90       	pop	r10
    2d14:	9f 90       	pop	r9
    2d16:	8f 90       	pop	r8
    2d18:	7f 90       	pop	r7
    2d1a:	6f 90       	pop	r6
    2d1c:	5f 90       	pop	r5
    2d1e:	4f 90       	pop	r4
    2d20:	3f 90       	pop	r3
    2d22:	2f 90       	pop	r2
    2d24:	1f 90       	pop	r1
    2d26:	0f 90       	pop	r0
    2d28:	0f be       	out	0x3f, r0	; 63
    2d2a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d2c:	08 95       	ret

00002d2e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2d2e:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2d32:	18 95       	reti

00002d34 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2d34:	0f 92       	push	r0
    2d36:	0f b6       	in	r0, 0x3f	; 63
    2d38:	f8 94       	cli
    2d3a:	0f 92       	push	r0
    2d3c:	1f 92       	push	r1
    2d3e:	11 24       	eor	r1, r1
    2d40:	2f 92       	push	r2
    2d42:	3f 92       	push	r3
    2d44:	4f 92       	push	r4
    2d46:	5f 92       	push	r5
    2d48:	6f 92       	push	r6
    2d4a:	7f 92       	push	r7
    2d4c:	8f 92       	push	r8
    2d4e:	9f 92       	push	r9
    2d50:	af 92       	push	r10
    2d52:	bf 92       	push	r11
    2d54:	cf 92       	push	r12
    2d56:	df 92       	push	r13
    2d58:	ef 92       	push	r14
    2d5a:	ff 92       	push	r15
    2d5c:	0f 93       	push	r16
    2d5e:	1f 93       	push	r17
    2d60:	2f 93       	push	r18
    2d62:	3f 93       	push	r19
    2d64:	4f 93       	push	r20
    2d66:	5f 93       	push	r21
    2d68:	6f 93       	push	r22
    2d6a:	7f 93       	push	r23
    2d6c:	8f 93       	push	r24
    2d6e:	9f 93       	push	r25
    2d70:	af 93       	push	r26
    2d72:	bf 93       	push	r27
    2d74:	cf 93       	push	r28
    2d76:	df 93       	push	r29
    2d78:	ef 93       	push	r30
    2d7a:	ff 93       	push	r31
    2d7c:	a0 91 ac 07 	lds	r26, 0x07AC
    2d80:	b0 91 ad 07 	lds	r27, 0x07AD
    2d84:	0d b6       	in	r0, 0x3d	; 61
    2d86:	0d 92       	st	X+, r0
    2d88:	0e b6       	in	r0, 0x3e	; 62
    2d8a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2d8c:	0e 94 12 1b 	call	0x3624	; 0x3624 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2d90:	a0 91 ac 07 	lds	r26, 0x07AC
    2d94:	b0 91 ad 07 	lds	r27, 0x07AD
    2d98:	cd 91       	ld	r28, X+
    2d9a:	cd bf       	out	0x3d, r28	; 61
    2d9c:	dd 91       	ld	r29, X+
    2d9e:	de bf       	out	0x3e, r29	; 62
    2da0:	ff 91       	pop	r31
    2da2:	ef 91       	pop	r30
    2da4:	df 91       	pop	r29
    2da6:	cf 91       	pop	r28
    2da8:	bf 91       	pop	r27
    2daa:	af 91       	pop	r26
    2dac:	9f 91       	pop	r25
    2dae:	8f 91       	pop	r24
    2db0:	7f 91       	pop	r23
    2db2:	6f 91       	pop	r22
    2db4:	5f 91       	pop	r21
    2db6:	4f 91       	pop	r20
    2db8:	3f 91       	pop	r19
    2dba:	2f 91       	pop	r18
    2dbc:	1f 91       	pop	r17
    2dbe:	0f 91       	pop	r16
    2dc0:	ff 90       	pop	r15
    2dc2:	ef 90       	pop	r14
    2dc4:	df 90       	pop	r13
    2dc6:	cf 90       	pop	r12
    2dc8:	bf 90       	pop	r11
    2dca:	af 90       	pop	r10
    2dcc:	9f 90       	pop	r9
    2dce:	8f 90       	pop	r8
    2dd0:	7f 90       	pop	r7
    2dd2:	6f 90       	pop	r6
    2dd4:	5f 90       	pop	r5
    2dd6:	4f 90       	pop	r4
    2dd8:	3f 90       	pop	r3
    2dda:	2f 90       	pop	r2
    2ddc:	1f 90       	pop	r1
    2dde:	0f 90       	pop	r0
    2de0:	0f be       	out	0x3f, r0	; 63
    2de2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2de4:	08 95       	ret

00002de6 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2de6:	0f b6       	in	r0, 0x3f	; 63
    2de8:	f8 94       	cli
    2dea:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2dec:	fc 01       	movw	r30, r24
    2dee:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    2df0:	0f 90       	pop	r0
    2df2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2df4:	08 95       	ret

00002df6 <uxQueueSpacesAvailable>:
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2df6:	fc 01       	movw	r30, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2df8:	0f b6       	in	r0, 0x3f	; 63
    2dfa:	f8 94       	cli
    2dfc:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2dfe:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    2e00:	0f 90       	pop	r0
    2e02:	0f be       	out	0x3f, r0	; 63
    2e04:	83 8d       	ldd	r24, Z+27	; 0x1b

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e06:	89 1b       	sub	r24, r25
    2e08:	08 95       	ret

00002e0a <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2e0a:	fc 01       	movw	r30, r24
    2e0c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e0e:	08 95       	ret

00002e10 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2e10:	fc 01       	movw	r30, r24
    2e12:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e14:	90 e0       	ldi	r25, 0x00	; 0
    2e16:	88 23       	and	r24, r24
    2e18:	09 f4       	brne	.+2      	; 0x2e1c <xQueueIsQueueEmptyFromISR+0xc>
    2e1a:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2e1c:	89 2f       	mov	r24, r25
    2e1e:	08 95       	ret

00002e20 <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    2e20:	fc 01       	movw	r30, r24
    2e22:	92 8d       	ldd	r25, Z+26	; 0x1a
    2e24:	20 e0       	ldi	r18, 0x00	; 0
    2e26:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e28:	98 17       	cp	r25, r24
    2e2a:	09 f4       	brne	.+2      	; 0x2e2e <xQueueIsQueueFullFromISR+0xe>
    2e2c:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2e2e:	82 2f       	mov	r24, r18
    2e30:	08 95       	ret

00002e32 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2e32:	1f 93       	push	r17
    2e34:	cf 93       	push	r28
    2e36:	df 93       	push	r29
    2e38:	ec 01       	movw	r28, r24
    2e3a:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2e3c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2e3e:	44 23       	and	r20, r20
    2e40:	e1 f1       	breq	.+120    	; 0x2eba <prvCopyDataToQueue+0x88>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2e42:	11 23       	and	r17, r17
    2e44:	b1 f4       	brne	.+44     	; 0x2e72 <prvCopyDataToQueue+0x40>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2e46:	8c 81       	ldd	r24, Y+4	; 0x04
    2e48:	9d 81       	ldd	r25, Y+5	; 0x05
    2e4a:	50 e0       	ldi	r21, 0x00	; 0
    2e4c:	0e 94 1a 23 	call	0x4634	; 0x4634 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2e50:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2e52:	2c 81       	ldd	r18, Y+4	; 0x04
    2e54:	3d 81       	ldd	r19, Y+5	; 0x05
    2e56:	28 0f       	add	r18, r24
    2e58:	31 1d       	adc	r19, r1
    2e5a:	3d 83       	std	Y+5, r19	; 0x05
    2e5c:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e60:	9b 81       	ldd	r25, Y+3	; 0x03
    2e62:	28 17       	cp	r18, r24
    2e64:	39 07       	cpc	r19, r25
    2e66:	48 f1       	brcs	.+82     	; 0x2eba <prvCopyDataToQueue+0x88>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2e68:	88 81       	ld	r24, Y
    2e6a:	99 81       	ldd	r25, Y+1	; 0x01
    2e6c:	9d 83       	std	Y+5, r25	; 0x05
    2e6e:	8c 83       	std	Y+4, r24	; 0x04
    2e70:	24 c0       	rjmp	.+72     	; 0x2eba <prvCopyDataToQueue+0x88>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e72:	8e 81       	ldd	r24, Y+6	; 0x06
    2e74:	9f 81       	ldd	r25, Y+7	; 0x07
    2e76:	50 e0       	ldi	r21, 0x00	; 0
    2e78:	0e 94 1a 23 	call	0x4634	; 0x4634 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2e7c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	44 27       	eor	r20, r20
    2e82:	55 27       	eor	r21, r21
    2e84:	48 1b       	sub	r20, r24
    2e86:	59 0b       	sbc	r21, r25
    2e88:	8e 81       	ldd	r24, Y+6	; 0x06
    2e8a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e8c:	84 0f       	add	r24, r20
    2e8e:	95 1f       	adc	r25, r21
    2e90:	9f 83       	std	Y+7, r25	; 0x07
    2e92:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2e94:	28 81       	ld	r18, Y
    2e96:	39 81       	ldd	r19, Y+1	; 0x01
    2e98:	82 17       	cp	r24, r18
    2e9a:	93 07       	cpc	r25, r19
    2e9c:	30 f4       	brcc	.+12     	; 0x2eaa <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea2:	84 0f       	add	r24, r20
    2ea4:	95 1f       	adc	r25, r21
    2ea6:	9f 83       	std	Y+7, r25	; 0x07
    2ea8:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2eaa:	12 30       	cpi	r17, 0x02	; 2
    2eac:	31 f4       	brne	.+12     	; 0x2eba <prvCopyDataToQueue+0x88>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2eae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2eb0:	88 23       	and	r24, r24
    2eb2:	19 f0       	breq	.+6      	; 0x2eba <prvCopyDataToQueue+0x88>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2eb4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2eb6:	81 50       	subi	r24, 0x01	; 1
    2eb8:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2eba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ebc:	8f 5f       	subi	r24, 0xFF	; 255
    2ebe:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
    2ec0:	80 e0       	ldi	r24, 0x00	; 0
    2ec2:	df 91       	pop	r29
    2ec4:	cf 91       	pop	r28
    2ec6:	1f 91       	pop	r17
    2ec8:	08 95       	ret

00002eca <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2eca:	fc 01       	movw	r30, r24
    2ecc:	56 2f       	mov	r21, r22
    2ece:	a7 2f       	mov	r26, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2ed0:	24 8d       	ldd	r18, Z+28	; 0x1c
    2ed2:	22 23       	and	r18, r18
    2ed4:	b9 f0       	breq	.+46     	; 0x2f04 <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2ed6:	86 81       	ldd	r24, Z+6	; 0x06
    2ed8:	97 81       	ldd	r25, Z+7	; 0x07
    2eda:	82 0f       	add	r24, r18
    2edc:	91 1d       	adc	r25, r1
    2ede:	97 83       	std	Z+7, r25	; 0x07
    2ee0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2ee2:	22 81       	ldd	r18, Z+2	; 0x02
    2ee4:	33 81       	ldd	r19, Z+3	; 0x03
    2ee6:	82 17       	cp	r24, r18
    2ee8:	93 07       	cpc	r25, r19
    2eea:	20 f0       	brcs	.+8      	; 0x2ef4 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2eec:	80 81       	ld	r24, Z
    2eee:	91 81       	ldd	r25, Z+1	; 0x01
    2ef0:	97 83       	std	Z+7, r25	; 0x07
    2ef2:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2ef4:	44 8d       	ldd	r20, Z+28	; 0x1c
    2ef6:	66 81       	ldd	r22, Z+6	; 0x06
    2ef8:	77 81       	ldd	r23, Z+7	; 0x07
    2efa:	85 2f       	mov	r24, r21
    2efc:	9a 2f       	mov	r25, r26
    2efe:	50 e0       	ldi	r21, 0x00	; 0
    2f00:	0e 94 1a 23 	call	0x4634	; 0x4634 <memcpy>
    2f04:	08 95       	ret

00002f06 <xQueuePeekFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2f06:	0f 93       	push	r16
    2f08:	1f 93       	push	r17
    2f0a:	cf 93       	push	r28
    2f0c:	df 93       	push	r29
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f0e:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f10:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f12:	88 23       	and	r24, r24
    2f14:	41 f0       	breq	.+16     	; 0x2f26 <xQueuePeekFromISR+0x20>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2f16:	0e 81       	ldd	r16, Y+6	; 0x06
    2f18:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f1a:	ce 01       	movw	r24, r28
    2f1c:	0e 94 65 17 	call	0x2eca	; 0x2eca <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2f20:	1f 83       	std	Y+7, r17	; 0x07
    2f22:	0e 83       	std	Y+6, r16	; 0x06
    2f24:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2f26:	df 91       	pop	r29
    2f28:	cf 91       	pop	r28
    2f2a:	1f 91       	pop	r17
    2f2c:	0f 91       	pop	r16
    2f2e:	08 95       	ret

00002f30 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    2f30:	0f 93       	push	r16
    2f32:	1f 93       	push	r17
    2f34:	cf 93       	push	r28
    2f36:	df 93       	push	r29
    2f38:	fb 01       	movw	r30, r22
    2f3a:	8a 01       	movw	r16, r20
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f3c:	ec 01       	movw	r28, r24

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f3e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f40:	88 23       	and	r24, r24
    2f42:	61 f1       	breq	.+88     	; 0x2f9c <xQueueCRReceiveFromISR+0x6c>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2f44:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2f46:	2e 81       	ldd	r18, Y+6	; 0x06
    2f48:	3f 81       	ldd	r19, Y+7	; 0x07
    2f4a:	28 0f       	add	r18, r24
    2f4c:	31 1d       	adc	r19, r1
    2f4e:	3f 83       	std	Y+7, r19	; 0x07
    2f50:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    2f52:	8a 81       	ldd	r24, Y+2	; 0x02
    2f54:	9b 81       	ldd	r25, Y+3	; 0x03
    2f56:	28 17       	cp	r18, r24
    2f58:	39 07       	cpc	r19, r25
    2f5a:	20 f0       	brcs	.+8      	; 0x2f64 <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2f5c:	88 81       	ld	r24, Y
    2f5e:	99 81       	ldd	r25, Y+1	; 0x01
    2f60:	9f 83       	std	Y+7, r25	; 0x07
    2f62:	8e 83       	std	Y+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    2f64:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f66:	81 50       	subi	r24, 0x01	; 1
    2f68:	8a 8f       	std	Y+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2f6a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2f6c:	6e 81       	ldd	r22, Y+6	; 0x06
    2f6e:	7f 81       	ldd	r23, Y+7	; 0x07
    2f70:	cf 01       	movw	r24, r30
    2f72:	50 e0       	ldi	r21, 0x00	; 0
    2f74:	0e 94 1a 23 	call	0x4634	; 0x4634 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    2f78:	f8 01       	movw	r30, r16
    2f7a:	80 81       	ld	r24, Z
    2f7c:	88 23       	and	r24, r24
    2f7e:	69 f4       	brne	.+26     	; 0x2f9a <xQueueCRReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f80:	88 85       	ldd	r24, Y+8	; 0x08
    2f82:	88 23       	and	r24, r24
    2f84:	51 f0       	breq	.+20     	; 0x2f9a <xQueueCRReceiveFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f86:	ce 01       	movw	r24, r28
    2f88:	08 96       	adiw	r24, 0x08	; 8
    2f8a:	0e 94 14 11 	call	0x2228	; 0x2228 <xCoRoutineRemoveFromEventList>
    2f8e:	88 23       	and	r24, r24
    2f90:	21 f0       	breq	.+8      	; 0x2f9a <xQueueCRReceiveFromISR+0x6a>
					{
						*pxCoRoutineWoken = pdTRUE;
    2f92:	81 e0       	ldi	r24, 0x01	; 1
    2f94:	f8 01       	movw	r30, r16
    2f96:	80 83       	st	Z, r24
    2f98:	01 c0       	rjmp	.+2      	; 0x2f9c <xQueueCRReceiveFromISR+0x6c>
    2f9a:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    2f9c:	df 91       	pop	r29
    2f9e:	cf 91       	pop	r28
    2fa0:	1f 91       	pop	r17
    2fa2:	0f 91       	pop	r16
    2fa4:	08 95       	ret

00002fa6 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    2fa6:	1f 93       	push	r17
    2fa8:	cf 93       	push	r28
    2faa:	df 93       	push	r29
    2fac:	14 2f       	mov	r17, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2fae:	ec 01       	movw	r28, r24

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2fb0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2fb2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2fb4:	98 17       	cp	r25, r24
    2fb6:	88 f4       	brcc	.+34     	; 0x2fda <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2fb8:	ce 01       	movw	r24, r28
    2fba:	40 e0       	ldi	r20, 0x00	; 0
    2fbc:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    2fc0:	11 23       	and	r17, r17
    2fc2:	59 f4       	brne	.+22     	; 0x2fda <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2fc4:	89 89       	ldd	r24, Y+17	; 0x11
    2fc6:	88 23       	and	r24, r24
    2fc8:	41 f0       	breq	.+16     	; 0x2fda <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2fca:	ce 01       	movw	r24, r28
    2fcc:	41 96       	adiw	r24, 0x11	; 17
    2fce:	0e 94 14 11 	call	0x2228	; 0x2228 <xCoRoutineRemoveFromEventList>
    2fd2:	48 2f       	mov	r20, r24
    2fd4:	81 11       	cpse	r24, r1
    2fd6:	41 e0       	ldi	r20, 0x01	; 1
    2fd8:	14 2f       	mov	r17, r20
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    2fda:	81 2f       	mov	r24, r17
    2fdc:	df 91       	pop	r29
    2fde:	cf 91       	pop	r28
    2fe0:	1f 91       	pop	r17
    2fe2:	08 95       	ret

00002fe4 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    2fe4:	cf 93       	push	r28
    2fe6:	df 93       	push	r29
    2fe8:	fb 01       	movw	r30, r22
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2fea:	ec 01       	movw	r28, r24

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2fec:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2fee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ff0:	88 23       	and	r24, r24
    2ff2:	71 f4       	brne	.+28     	; 0x3010 <xQueueCRReceive+0x2c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2ff4:	41 15       	cp	r20, r1
    2ff6:	51 05       	cpc	r21, r1
    2ff8:	41 f0       	breq	.+16     	; 0x300a <xQueueCRReceive+0x26>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2ffa:	61 96       	adiw	r28, 0x11	; 17
    2ffc:	ca 01       	movw	r24, r20
    2ffe:	be 01       	movw	r22, r28
    3000:	0e 94 1c 12 	call	0x2438	; 0x2438 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    3004:	78 94       	sei
    3006:	8c ef       	ldi	r24, 0xFC	; 252
    3008:	2f c0       	rjmp	.+94     	; 0x3068 <xQueueCRReceive+0x84>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    300a:	78 94       	sei
    300c:	80 e0       	ldi	r24, 0x00	; 0
    300e:	2c c0       	rjmp	.+88     	; 0x3068 <xQueueCRReceive+0x84>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    3010:	78 94       	sei

		portDISABLE_INTERRUPTS();
    3012:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3014:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3016:	88 23       	and	r24, r24
    3018:	31 f1       	breq	.+76     	; 0x3066 <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    301a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    301c:	2e 81       	ldd	r18, Y+6	; 0x06
    301e:	3f 81       	ldd	r19, Y+7	; 0x07
    3020:	28 0f       	add	r18, r24
    3022:	31 1d       	adc	r19, r1
    3024:	3f 83       	std	Y+7, r19	; 0x07
    3026:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    3028:	8a 81       	ldd	r24, Y+2	; 0x02
    302a:	9b 81       	ldd	r25, Y+3	; 0x03
    302c:	28 17       	cp	r18, r24
    302e:	39 07       	cpc	r19, r25
    3030:	20 f0       	brcs	.+8      	; 0x303a <xQueueCRReceive+0x56>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3032:	88 81       	ld	r24, Y
    3034:	99 81       	ldd	r25, Y+1	; 0x01
    3036:	9f 83       	std	Y+7, r25	; 0x07
    3038:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    303a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    303c:	81 50       	subi	r24, 0x01	; 1
    303e:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3040:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3042:	6e 81       	ldd	r22, Y+6	; 0x06
    3044:	7f 81       	ldd	r23, Y+7	; 0x07
    3046:	cf 01       	movw	r24, r30
    3048:	50 e0       	ldi	r21, 0x00	; 0
    304a:	0e 94 1a 23 	call	0x4634	; 0x4634 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    304e:	88 85       	ldd	r24, Y+8	; 0x08
    3050:	88 23       	and	r24, r24
    3052:	41 f0       	breq	.+16     	; 0x3064 <xQueueCRReceive+0x80>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3054:	ce 01       	movw	r24, r28
    3056:	08 96       	adiw	r24, 0x08	; 8
    3058:	0e 94 14 11 	call	0x2228	; 0x2228 <xCoRoutineRemoveFromEventList>
    305c:	88 23       	and	r24, r24
    305e:	11 f0       	breq	.+4      	; 0x3064 <xQueueCRReceive+0x80>
    3060:	8b ef       	ldi	r24, 0xFB	; 251
    3062:	01 c0       	rjmp	.+2      	; 0x3066 <xQueueCRReceive+0x82>
    3064:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    3066:	78 94       	sei

		return xReturn;
	}
    3068:	df 91       	pop	r29
    306a:	cf 91       	pop	r28
    306c:	08 95       	ret

0000306e <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    306e:	cf 93       	push	r28
    3070:	df 93       	push	r29
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3072:	ec 01       	movw	r28, r24

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    3074:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3076:	0f b6       	in	r0, 0x3f	; 63
    3078:	f8 94       	cli
    307a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    307c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    307e:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3080:	0f 90       	pop	r0
    3082:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3084:	89 17       	cp	r24, r25
    3086:	71 f4       	brne	.+28     	; 0x30a4 <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    3088:	41 15       	cp	r20, r1
    308a:	51 05       	cpc	r21, r1
    308c:	41 f0       	breq	.+16     	; 0x309e <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    308e:	28 96       	adiw	r28, 0x08	; 8
    3090:	ca 01       	movw	r24, r20
    3092:	be 01       	movw	r22, r28
    3094:	0e 94 1c 12 	call	0x2438	; 0x2438 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    3098:	78 94       	sei
    309a:	8c ef       	ldi	r24, 0xFC	; 252
    309c:	1b c0       	rjmp	.+54     	; 0x30d4 <xQueueCRSend+0x66>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    309e:	78 94       	sei
    30a0:	80 e0       	ldi	r24, 0x00	; 0
    30a2:	18 c0       	rjmp	.+48     	; 0x30d4 <xQueueCRSend+0x66>
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
    30a4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    30a6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    30a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    30aa:	89 17       	cp	r24, r25
    30ac:	10 f0       	brcs	.+4      	; 0x30b2 <xQueueCRSend+0x44>
    30ae:	80 e0       	ldi	r24, 0x00	; 0
    30b0:	10 c0       	rjmp	.+32     	; 0x30d2 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    30b2:	ce 01       	movw	r24, r28
    30b4:	40 e0       	ldi	r20, 0x00	; 0
    30b6:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30ba:	89 89       	ldd	r24, Y+17	; 0x11
    30bc:	88 23       	and	r24, r24
    30be:	41 f0       	breq	.+16     	; 0x30d0 <xQueueCRSend+0x62>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30c0:	ce 01       	movw	r24, r28
    30c2:	41 96       	adiw	r24, 0x11	; 17
    30c4:	0e 94 14 11 	call	0x2228	; 0x2228 <xCoRoutineRemoveFromEventList>
    30c8:	88 23       	and	r24, r24
    30ca:	11 f0       	breq	.+4      	; 0x30d0 <xQueueCRSend+0x62>
    30cc:	8b ef       	ldi	r24, 0xFB	; 251
    30ce:	01 c0       	rjmp	.+2      	; 0x30d2 <xQueueCRSend+0x64>
    30d0:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    30d2:	78 94       	sei

		return xReturn;
	}
    30d4:	df 91       	pop	r29
    30d6:	cf 91       	pop	r28
    30d8:	08 95       	ret

000030da <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    30da:	cf 93       	push	r28
    30dc:	df 93       	push	r29
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    30de:	ec 01       	movw	r28, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    30e0:	88 81       	ld	r24, Y
    30e2:	99 81       	ldd	r25, Y+1	; 0x01
    30e4:	00 97       	sbiw	r24, 0x00	; 0
    30e6:	11 f0       	breq	.+4      	; 0x30ec <vQueueDelete+0x12>
	{
		vPortFree( pxQueue->pcHead );
    30e8:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortFree>
	}
	vPortFree( pxQueue );
    30ec:	ce 01       	movw	r24, r28
    30ee:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortFree>
}
    30f2:	df 91       	pop	r29
    30f4:	cf 91       	pop	r28
    30f6:	08 95       	ret

000030f8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    30f8:	0f 93       	push	r16
    30fa:	1f 93       	push	r17
    30fc:	cf 93       	push	r28
    30fe:	df 93       	push	r29
    3100:	8a 01       	movw	r16, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3102:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3104:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3106:	88 23       	and	r24, r24
    3108:	e9 f0       	breq	.+58     	; 0x3144 <xQueueReceiveFromISR+0x4c>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    310a:	ce 01       	movw	r24, r28
    310c:	0e 94 65 17 	call	0x2eca	; 0x2eca <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3110:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3112:	81 50       	subi	r24, 0x01	; 1
    3114:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3116:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3118:	8f 3f       	cpi	r24, 0xFF	; 255
    311a:	81 f4       	brne	.+32     	; 0x313c <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    311c:	88 85       	ldd	r24, Y+8	; 0x08
    311e:	88 23       	and	r24, r24
    3120:	81 f0       	breq	.+32     	; 0x3142 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3122:	ce 01       	movw	r24, r28
    3124:	08 96       	adiw	r24, 0x08	; 8
    3126:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    312a:	88 23       	and	r24, r24
    312c:	51 f0       	breq	.+20     	; 0x3142 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    312e:	01 15       	cp	r16, r1
    3130:	11 05       	cpc	r17, r1
    3132:	39 f0       	breq	.+14     	; 0x3142 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3134:	81 e0       	ldi	r24, 0x01	; 1
    3136:	f8 01       	movw	r30, r16
    3138:	80 83       	st	Z, r24
    313a:	04 c0       	rjmp	.+8      	; 0x3144 <xQueueReceiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    313c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    313e:	8f 5f       	subi	r24, 0xFF	; 255
    3140:	8d 8f       	std	Y+29, r24	; 0x1d
    3142:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3144:	df 91       	pop	r29
    3146:	cf 91       	pop	r28
    3148:	1f 91       	pop	r17
    314a:	0f 91       	pop	r16
    314c:	08 95       	ret

0000314e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    314e:	0f 93       	push	r16
    3150:	1f 93       	push	r17
    3152:	cf 93       	push	r28
    3154:	df 93       	push	r29
    3156:	8a 01       	movw	r16, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3158:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    315a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    315c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    315e:	98 17       	cp	r25, r24
    3160:	20 f0       	brcs	.+8      	; 0x316a <xQueueGenericSendFromISR+0x1c>
    3162:	22 30       	cpi	r18, 0x02	; 2
    3164:	11 f0       	breq	.+4      	; 0x316a <xQueueGenericSendFromISR+0x1c>
    3166:	80 e0       	ldi	r24, 0x00	; 0
    3168:	23 c0       	rjmp	.+70     	; 0x31b0 <xQueueGenericSendFromISR+0x62>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    316a:	ce 01       	movw	r24, r28
    316c:	42 2f       	mov	r20, r18
    316e:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvCopyDataToQueue>
    3172:	88 23       	and	r24, r24
    3174:	31 f0       	breq	.+12     	; 0x3182 <xQueueGenericSendFromISR+0x34>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    3176:	01 15       	cp	r16, r1
    3178:	11 05       	cpc	r17, r1
    317a:	19 f0       	breq	.+6      	; 0x3182 <xQueueGenericSendFromISR+0x34>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    317c:	81 e0       	ldi	r24, 0x01	; 1
    317e:	f8 01       	movw	r30, r16
    3180:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3182:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3184:	8f 3f       	cpi	r24, 0xFF	; 255
    3186:	81 f4       	brne	.+32     	; 0x31a8 <xQueueGenericSendFromISR+0x5a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3188:	89 89       	ldd	r24, Y+17	; 0x11
    318a:	88 23       	and	r24, r24
    318c:	81 f0       	breq	.+32     	; 0x31ae <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    318e:	ce 01       	movw	r24, r28
    3190:	41 96       	adiw	r24, 0x11	; 17
    3192:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    3196:	88 23       	and	r24, r24
    3198:	51 f0       	breq	.+20     	; 0x31ae <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    319a:	01 15       	cp	r16, r1
    319c:	11 05       	cpc	r17, r1
    319e:	39 f0       	breq	.+14     	; 0x31ae <xQueueGenericSendFromISR+0x60>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    31a0:	81 e0       	ldi	r24, 0x01	; 1
    31a2:	f8 01       	movw	r30, r16
    31a4:	80 83       	st	Z, r24
    31a6:	04 c0       	rjmp	.+8      	; 0x31b0 <xQueueGenericSendFromISR+0x62>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    31a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    31aa:	8f 5f       	subi	r24, 0xFF	; 255
    31ac:	8e 8f       	std	Y+30, r24	; 0x1e
    31ae:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    31b0:	df 91       	pop	r29
    31b2:	cf 91       	pop	r28
    31b4:	1f 91       	pop	r17
    31b6:	0f 91       	pop	r16
    31b8:	08 95       	ret

000031ba <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    31ba:	0f 93       	push	r16
    31bc:	1f 93       	push	r17
    31be:	cf 93       	push	r28
    31c0:	df 93       	push	r29
    31c2:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    31c4:	0f b6       	in	r0, 0x3f	; 63
    31c6:	f8 94       	cli
    31c8:	0f 92       	push	r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    31ca:	8c 01       	movw	r16, r24
    31cc:	0f 5e       	subi	r16, 0xEF	; 239
    31ce:	1f 4f       	sbci	r17, 0xFF	; 255
    31d0:	0d c0       	rjmp	.+26     	; 0x31ec <prvUnlockQueue+0x32>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    31d2:	89 89       	ldd	r24, Y+17	; 0x11
    31d4:	88 23       	and	r24, r24
    31d6:	69 f0       	breq	.+26     	; 0x31f2 <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    31d8:	c8 01       	movw	r24, r16
    31da:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    31de:	88 23       	and	r24, r24
    31e0:	11 f0       	breq	.+4      	; 0x31e6 <prvUnlockQueue+0x2c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    31e2:	0e 94 9d 1b 	call	0x373a	; 0x373a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    31e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    31e8:	81 50       	subi	r24, 0x01	; 1
    31ea:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    31ec:	8e 8d       	ldd	r24, Y+30	; 0x1e
    31ee:	18 16       	cp	r1, r24
    31f0:	84 f3       	brlt	.-32     	; 0x31d2 <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    31f2:	8f ef       	ldi	r24, 0xFF	; 255
    31f4:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    31f6:	0f 90       	pop	r0
    31f8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    31fa:	0f b6       	in	r0, 0x3f	; 63
    31fc:	f8 94       	cli
    31fe:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3200:	8e 01       	movw	r16, r28
    3202:	08 5f       	subi	r16, 0xF8	; 248
    3204:	1f 4f       	sbci	r17, 0xFF	; 255
    3206:	0d c0       	rjmp	.+26     	; 0x3222 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3208:	88 85       	ldd	r24, Y+8	; 0x08
    320a:	88 23       	and	r24, r24
    320c:	69 f0       	breq	.+26     	; 0x3228 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    320e:	c8 01       	movw	r24, r16
    3210:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    3214:	88 23       	and	r24, r24
    3216:	11 f0       	breq	.+4      	; 0x321c <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    3218:	0e 94 9d 1b 	call	0x373a	; 0x373a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    321c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    321e:	81 50       	subi	r24, 0x01	; 1
    3220:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3222:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3224:	18 16       	cp	r1, r24
    3226:	84 f3       	brlt	.-32     	; 0x3208 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3228:	8f ef       	ldi	r24, 0xFF	; 255
    322a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    322c:	0f 90       	pop	r0
    322e:	0f be       	out	0x3f, r0	; 63
}
    3230:	df 91       	pop	r29
    3232:	cf 91       	pop	r28
    3234:	1f 91       	pop	r17
    3236:	0f 91       	pop	r16
    3238:	08 95       	ret

0000323a <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    323a:	7f 92       	push	r7
    323c:	8f 92       	push	r8
    323e:	9f 92       	push	r9
    3240:	af 92       	push	r10
    3242:	bf 92       	push	r11
    3244:	cf 92       	push	r12
    3246:	df 92       	push	r13
    3248:	ef 92       	push	r14
    324a:	ff 92       	push	r15
    324c:	0f 93       	push	r16
    324e:	1f 93       	push	r17
    3250:	df 93       	push	r29
    3252:	cf 93       	push	r28
    3254:	00 d0       	rcall	.+0      	; 0x3256 <xQueueGenericReceive+0x1c>
    3256:	00 d0       	rcall	.+0      	; 0x3258 <xQueueGenericReceive+0x1e>
    3258:	0f 92       	push	r0
    325a:	cd b7       	in	r28, 0x3d	; 61
    325c:	de b7       	in	r29, 0x3e	; 62
    325e:	5b 01       	movw	r10, r22
    3260:	5d 83       	std	Y+5, r21	; 0x05
    3262:	4c 83       	std	Y+4, r20	; 0x04
    3264:	72 2e       	mov	r7, r18
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3266:	8c 01       	movw	r16, r24
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3268:	91 e1       	ldi	r25, 0x11	; 17
    326a:	c9 2e       	mov	r12, r25
    326c:	d1 2c       	mov	r13, r1
    326e:	c0 0e       	add	r12, r16
    3270:	d1 1e       	adc	r13, r17
    3272:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3274:	7e 01       	movw	r14, r28
    3276:	08 94       	sec
    3278:	e1 1c       	adc	r14, r1
    327a:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    327c:	84 e0       	ldi	r24, 0x04	; 4
    327e:	88 2e       	mov	r8, r24
    3280:	91 2c       	mov	r9, r1
    3282:	8c 0e       	add	r8, r28
    3284:	9d 1e       	adc	r9, r29
    3286:	01 c0       	rjmp	.+2      	; 0x328a <xQueueGenericReceive+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3288:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    328a:	0f b6       	in	r0, 0x3f	; 63
    328c:	f8 94       	cli
    328e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3290:	f8 01       	movw	r30, r16
    3292:	82 8d       	ldd	r24, Z+26	; 0x1a
    3294:	88 23       	and	r24, r24
    3296:	39 f1       	breq	.+78     	; 0x32e6 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    3298:	e6 80       	ldd	r14, Z+6	; 0x06
    329a:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    329c:	c8 01       	movw	r24, r16
    329e:	b5 01       	movw	r22, r10
    32a0:	0e 94 65 17 	call	0x2eca	; 0x2eca <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    32a4:	77 20       	and	r7, r7
    32a6:	71 f4       	brne	.+28     	; 0x32c4 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    32a8:	f8 01       	movw	r30, r16
    32aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    32ac:	81 50       	subi	r24, 0x01	; 1
    32ae:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    32b0:	80 85       	ldd	r24, Z+8	; 0x08
    32b2:	88 23       	and	r24, r24
    32b4:	a1 f0       	breq	.+40     	; 0x32de <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    32b6:	c8 01       	movw	r24, r16
    32b8:	08 96       	adiw	r24, 0x08	; 8
    32ba:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    32be:	81 30       	cpi	r24, 0x01	; 1
    32c0:	71 f4       	brne	.+28     	; 0x32de <xQueueGenericReceive+0xa4>
    32c2:	0b c0       	rjmp	.+22     	; 0x32da <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    32c4:	f8 01       	movw	r30, r16
    32c6:	f7 82       	std	Z+7, r15	; 0x07
    32c8:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    32ca:	81 89       	ldd	r24, Z+17	; 0x11
    32cc:	88 23       	and	r24, r24
    32ce:	39 f0       	breq	.+14     	; 0x32de <xQueueGenericReceive+0xa4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32d0:	c6 01       	movw	r24, r12
    32d2:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    32d6:	88 23       	and	r24, r24
    32d8:	11 f0       	breq	.+4      	; 0x32de <xQueueGenericReceive+0xa4>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    32da:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    32de:	0f 90       	pop	r0
    32e0:	0f be       	out	0x3f, r0	; 63
    32e2:	81 e0       	ldi	r24, 0x01	; 1
    32e4:	4a c0       	rjmp	.+148    	; 0x337a <xQueueGenericReceive+0x140>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    32e6:	8c 81       	ldd	r24, Y+4	; 0x04
    32e8:	9d 81       	ldd	r25, Y+5	; 0x05
    32ea:	89 2b       	or	r24, r25
    32ec:	19 f4       	brne	.+6      	; 0x32f4 <xQueueGenericReceive+0xba>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    32ee:	0f 90       	pop	r0
    32f0:	0f be       	out	0x3f, r0	; 63
    32f2:	42 c0       	rjmp	.+132    	; 0x3378 <xQueueGenericReceive+0x13e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    32f4:	22 23       	and	r18, r18
    32f6:	19 f4       	brne	.+6      	; 0x32fe <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    32f8:	c7 01       	movw	r24, r14
    32fa:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    32fe:	0f 90       	pop	r0
    3300:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3302:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3306:	0f b6       	in	r0, 0x3f	; 63
    3308:	f8 94       	cli
    330a:	0f 92       	push	r0
    330c:	f8 01       	movw	r30, r16
    330e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3310:	8f 3f       	cpi	r24, 0xFF	; 255
    3312:	09 f4       	brne	.+2      	; 0x3316 <xQueueGenericReceive+0xdc>
    3314:	15 8e       	std	Z+29, r1	; 0x1d
    3316:	f8 01       	movw	r30, r16
    3318:	86 8d       	ldd	r24, Z+30	; 0x1e
    331a:	8f 3f       	cpi	r24, 0xFF	; 255
    331c:	09 f4       	brne	.+2      	; 0x3320 <xQueueGenericReceive+0xe6>
    331e:	16 8e       	std	Z+30, r1	; 0x1e
    3320:	0f 90       	pop	r0
    3322:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3324:	c7 01       	movw	r24, r14
    3326:	b4 01       	movw	r22, r8
    3328:	0e 94 66 1b 	call	0x36cc	; 0x36cc <xTaskCheckForTimeOut>
    332c:	88 23       	and	r24, r24
    332e:	f9 f4       	brne	.+62     	; 0x336e <xQueueGenericReceive+0x134>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3330:	0f b6       	in	r0, 0x3f	; 63
    3332:	f8 94       	cli
    3334:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3336:	f8 01       	movw	r30, r16
    3338:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    333a:	0f 90       	pop	r0
    333c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    333e:	88 23       	and	r24, r24
    3340:	81 f4       	brne	.+32     	; 0x3362 <xQueueGenericReceive+0x128>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3342:	6c 81       	ldd	r22, Y+4	; 0x04
    3344:	7d 81       	ldd	r23, Y+5	; 0x05
    3346:	c6 01       	movw	r24, r12
    3348:	0e 94 b5 1d 	call	0x3b6a	; 0x3b6a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    334c:	c8 01       	movw	r24, r16
    334e:	0e 94 dd 18 	call	0x31ba	; 0x31ba <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3352:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
    3356:	88 23       	and	r24, r24
    3358:	09 f0       	breq	.+2      	; 0x335c <xQueueGenericReceive+0x122>
    335a:	96 cf       	rjmp	.-212    	; 0x3288 <xQueueGenericReceive+0x4e>
				{
					portYIELD_WITHIN_API();
    335c:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    3360:	93 cf       	rjmp	.-218    	; 0x3288 <xQueueGenericReceive+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3362:	c8 01       	movw	r24, r16
    3364:	0e 94 dd 18 	call	0x31ba	; 0x31ba <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3368:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
    336c:	8d cf       	rjmp	.-230    	; 0x3288 <xQueueGenericReceive+0x4e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    336e:	c8 01       	movw	r24, r16
    3370:	0e 94 dd 18 	call	0x31ba	; 0x31ba <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3374:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
    3378:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    337a:	0f 90       	pop	r0
    337c:	0f 90       	pop	r0
    337e:	0f 90       	pop	r0
    3380:	0f 90       	pop	r0
    3382:	0f 90       	pop	r0
    3384:	cf 91       	pop	r28
    3386:	df 91       	pop	r29
    3388:	1f 91       	pop	r17
    338a:	0f 91       	pop	r16
    338c:	ff 90       	pop	r15
    338e:	ef 90       	pop	r14
    3390:	df 90       	pop	r13
    3392:	cf 90       	pop	r12
    3394:	bf 90       	pop	r11
    3396:	af 90       	pop	r10
    3398:	9f 90       	pop	r9
    339a:	8f 90       	pop	r8
    339c:	7f 90       	pop	r7
    339e:	08 95       	ret

000033a0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    33a0:	6f 92       	push	r6
    33a2:	7f 92       	push	r7
    33a4:	9f 92       	push	r9
    33a6:	af 92       	push	r10
    33a8:	bf 92       	push	r11
    33aa:	cf 92       	push	r12
    33ac:	df 92       	push	r13
    33ae:	ef 92       	push	r14
    33b0:	ff 92       	push	r15
    33b2:	0f 93       	push	r16
    33b4:	1f 93       	push	r17
    33b6:	df 93       	push	r29
    33b8:	cf 93       	push	r28
    33ba:	00 d0       	rcall	.+0      	; 0x33bc <xQueueGenericSend+0x1c>
    33bc:	00 d0       	rcall	.+0      	; 0x33be <xQueueGenericSend+0x1e>
    33be:	0f 92       	push	r0
    33c0:	cd b7       	in	r28, 0x3d	; 61
    33c2:	de b7       	in	r29, 0x3e	; 62
    33c4:	6b 01       	movw	r12, r22
    33c6:	5d 83       	std	Y+5, r21	; 0x05
    33c8:	4c 83       	std	Y+4, r20	; 0x04
    33ca:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    33cc:	8c 01       	movw	r16, r24
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    33ce:	48 e0       	ldi	r20, 0x08	; 8
    33d0:	e4 2e       	mov	r14, r20
    33d2:	f1 2c       	mov	r15, r1
    33d4:	e8 0e       	add	r14, r24
    33d6:	f9 1e       	adc	r15, r25
    33d8:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    33da:	5e 01       	movw	r10, r28
    33dc:	08 94       	sec
    33de:	a1 1c       	adc	r10, r1
    33e0:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    33e2:	34 e0       	ldi	r19, 0x04	; 4
    33e4:	63 2e       	mov	r6, r19
    33e6:	71 2c       	mov	r7, r1
    33e8:	6c 0e       	add	r6, r28
    33ea:	7d 1e       	adc	r7, r29
    33ec:	01 c0       	rjmp	.+2      	; 0x33f0 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    33ee:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    33f0:	0f b6       	in	r0, 0x3f	; 63
    33f2:	f8 94       	cli
    33f4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    33f6:	f8 01       	movw	r30, r16
    33f8:	92 8d       	ldd	r25, Z+26	; 0x1a
    33fa:	83 8d       	ldd	r24, Z+27	; 0x1b
    33fc:	98 17       	cp	r25, r24
    33fe:	18 f0       	brcs	.+6      	; 0x3406 <xQueueGenericSend+0x66>
    3400:	f2 e0       	ldi	r31, 0x02	; 2
    3402:	9f 16       	cp	r9, r31
    3404:	c9 f4       	brne	.+50     	; 0x3438 <xQueueGenericSend+0x98>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3406:	c8 01       	movw	r24, r16
    3408:	b6 01       	movw	r22, r12
    340a:	49 2d       	mov	r20, r9
    340c:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvCopyDataToQueue>
    3410:	98 2f       	mov	r25, r24
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3412:	f8 01       	movw	r30, r16
    3414:	81 89       	ldd	r24, Z+17	; 0x11
    3416:	88 23       	and	r24, r24
    3418:	39 f0       	breq	.+14     	; 0x3428 <xQueueGenericSend+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    341a:	c8 01       	movw	r24, r16
    341c:	41 96       	adiw	r24, 0x11	; 17
    341e:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    3422:	81 30       	cpi	r24, 0x01	; 1
    3424:	29 f4       	brne	.+10     	; 0x3430 <xQueueGenericSend+0x90>
    3426:	02 c0       	rjmp	.+4      	; 0x342c <xQueueGenericSend+0x8c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3428:	99 23       	and	r25, r25
    342a:	11 f0       	breq	.+4      	; 0x3430 <xQueueGenericSend+0x90>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    342c:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3430:	0f 90       	pop	r0
    3432:	0f be       	out	0x3f, r0	; 63
    3434:	81 e0       	ldi	r24, 0x01	; 1
    3436:	4c c0       	rjmp	.+152    	; 0x34d0 <xQueueGenericSend+0x130>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3438:	8c 81       	ldd	r24, Y+4	; 0x04
    343a:	9d 81       	ldd	r25, Y+5	; 0x05
    343c:	89 2b       	or	r24, r25
    343e:	19 f4       	brne	.+6      	; 0x3446 <xQueueGenericSend+0xa6>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3440:	0f 90       	pop	r0
    3442:	0f be       	out	0x3f, r0	; 63
    3444:	44 c0       	rjmp	.+136    	; 0x34ce <xQueueGenericSend+0x12e>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    3446:	22 23       	and	r18, r18
    3448:	19 f4       	brne	.+6      	; 0x3450 <xQueueGenericSend+0xb0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    344a:	c5 01       	movw	r24, r10
    344c:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3450:	0f 90       	pop	r0
    3452:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3454:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3458:	0f b6       	in	r0, 0x3f	; 63
    345a:	f8 94       	cli
    345c:	0f 92       	push	r0
    345e:	f8 01       	movw	r30, r16
    3460:	85 8d       	ldd	r24, Z+29	; 0x1d
    3462:	8f 3f       	cpi	r24, 0xFF	; 255
    3464:	09 f4       	brne	.+2      	; 0x3468 <xQueueGenericSend+0xc8>
    3466:	15 8e       	std	Z+29, r1	; 0x1d
    3468:	f8 01       	movw	r30, r16
    346a:	86 8d       	ldd	r24, Z+30	; 0x1e
    346c:	8f 3f       	cpi	r24, 0xFF	; 255
    346e:	09 f4       	brne	.+2      	; 0x3472 <xQueueGenericSend+0xd2>
    3470:	16 8e       	std	Z+30, r1	; 0x1e
    3472:	0f 90       	pop	r0
    3474:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3476:	c5 01       	movw	r24, r10
    3478:	b3 01       	movw	r22, r6
    347a:	0e 94 66 1b 	call	0x36cc	; 0x36cc <xTaskCheckForTimeOut>
    347e:	88 23       	and	r24, r24
    3480:	09 f5       	brne	.+66     	; 0x34c4 <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3482:	0f b6       	in	r0, 0x3f	; 63
    3484:	f8 94       	cli
    3486:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3488:	f8 01       	movw	r30, r16
    348a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    348c:	0f 90       	pop	r0
    348e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3490:	f8 01       	movw	r30, r16
    3492:	83 8d       	ldd	r24, Z+27	; 0x1b
    3494:	98 17       	cp	r25, r24
    3496:	81 f4       	brne	.+32     	; 0x34b8 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3498:	6c 81       	ldd	r22, Y+4	; 0x04
    349a:	7d 81       	ldd	r23, Y+5	; 0x05
    349c:	c7 01       	movw	r24, r14
    349e:	0e 94 b5 1d 	call	0x3b6a	; 0x3b6a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    34a2:	c8 01       	movw	r24, r16
    34a4:	0e 94 dd 18 	call	0x31ba	; 0x31ba <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    34a8:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
    34ac:	88 23       	and	r24, r24
    34ae:	09 f0       	breq	.+2      	; 0x34b2 <xQueueGenericSend+0x112>
    34b0:	9e cf       	rjmp	.-196    	; 0x33ee <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    34b2:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    34b6:	9b cf       	rjmp	.-202    	; 0x33ee <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    34b8:	c8 01       	movw	r24, r16
    34ba:	0e 94 dd 18 	call	0x31ba	; 0x31ba <prvUnlockQueue>
				( void ) xTaskResumeAll();
    34be:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
    34c2:	95 cf       	rjmp	.-214    	; 0x33ee <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    34c4:	c8 01       	movw	r24, r16
    34c6:	0e 94 dd 18 	call	0x31ba	; 0x31ba <prvUnlockQueue>
			( void ) xTaskResumeAll();
    34ca:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
    34ce:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    34d0:	0f 90       	pop	r0
    34d2:	0f 90       	pop	r0
    34d4:	0f 90       	pop	r0
    34d6:	0f 90       	pop	r0
    34d8:	0f 90       	pop	r0
    34da:	cf 91       	pop	r28
    34dc:	df 91       	pop	r29
    34de:	1f 91       	pop	r17
    34e0:	0f 91       	pop	r16
    34e2:	ff 90       	pop	r15
    34e4:	ef 90       	pop	r14
    34e6:	df 90       	pop	r13
    34e8:	cf 90       	pop	r12
    34ea:	bf 90       	pop	r11
    34ec:	af 90       	pop	r10
    34ee:	9f 90       	pop	r9
    34f0:	7f 90       	pop	r7
    34f2:	6f 90       	pop	r6
    34f4:	08 95       	ret

000034f6 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    34f6:	cf 93       	push	r28
    34f8:	df 93       	push	r29
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    34fa:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    34fc:	0f b6       	in	r0, 0x3f	; 63
    34fe:	f8 94       	cli
    3500:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3502:	ec 8d       	ldd	r30, Y+28	; 0x1c
    3504:	2b 8d       	ldd	r18, Y+27	; 0x1b
    3506:	e2 9f       	mul	r30, r18
    3508:	c0 01       	movw	r24, r0
    350a:	11 24       	eor	r1, r1
    350c:	48 81       	ld	r20, Y
    350e:	59 81       	ldd	r21, Y+1	; 0x01
    3510:	84 0f       	add	r24, r20
    3512:	95 1f       	adc	r25, r21
    3514:	9b 83       	std	Y+3, r25	; 0x03
    3516:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3518:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    351a:	5d 83       	std	Y+5, r21	; 0x05
    351c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    351e:	30 e0       	ldi	r19, 0x00	; 0
    3520:	21 50       	subi	r18, 0x01	; 1
    3522:	30 40       	sbci	r19, 0x00	; 0
    3524:	f0 e0       	ldi	r31, 0x00	; 0
    3526:	2e 9f       	mul	r18, r30
    3528:	c0 01       	movw	r24, r0
    352a:	2f 9f       	mul	r18, r31
    352c:	90 0d       	add	r25, r0
    352e:	3e 9f       	mul	r19, r30
    3530:	90 0d       	add	r25, r0
    3532:	11 24       	eor	r1, r1
    3534:	48 0f       	add	r20, r24
    3536:	59 1f       	adc	r21, r25
    3538:	5f 83       	std	Y+7, r21	; 0x07
    353a:	4e 83       	std	Y+6, r20	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    353c:	8f ef       	ldi	r24, 0xFF	; 255
    353e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    3540:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3542:	66 23       	and	r22, r22
    3544:	61 f4       	brne	.+24     	; 0x355e <xQueueGenericReset+0x68>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3546:	88 85       	ldd	r24, Y+8	; 0x08
    3548:	88 23       	and	r24, r24
    354a:	89 f0       	breq	.+34     	; 0x356e <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    354c:	ce 01       	movw	r24, r28
    354e:	08 96       	adiw	r24, 0x08	; 8
    3550:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <xTaskRemoveFromEventList>
    3554:	81 30       	cpi	r24, 0x01	; 1
    3556:	59 f4       	brne	.+22     	; 0x356e <xQueueGenericReset+0x78>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3558:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    355c:	08 c0       	rjmp	.+16     	; 0x356e <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    355e:	ce 01       	movw	r24, r28
    3560:	08 96       	adiw	r24, 0x08	; 8
    3562:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3566:	ce 01       	movw	r24, r28
    3568:	41 96       	adiw	r24, 0x11	; 17
    356a:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    356e:	0f 90       	pop	r0
    3570:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    3572:	81 e0       	ldi	r24, 0x01	; 1
    3574:	df 91       	pop	r29
    3576:	cf 91       	pop	r28
    3578:	08 95       	ret

0000357a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    357a:	0f 93       	push	r16
    357c:	1f 93       	push	r17
    357e:	cf 93       	push	r28
    3580:	df 93       	push	r29
    3582:	18 2f       	mov	r17, r24
    3584:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    3586:	88 23       	and	r24, r24
    3588:	e1 f0       	breq	.+56     	; 0x35c2 <xQueueGenericCreate+0x48>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    358a:	8f e1       	ldi	r24, 0x1F	; 31
    358c:	90 e0       	ldi	r25, 0x00	; 0
    358e:	0e 94 74 14 	call	0x28e8	; 0x28e8 <pvPortMalloc>
    3592:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    3594:	00 97       	sbiw	r24, 0x00	; 0
    3596:	a9 f0       	breq	.+42     	; 0x35c2 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    3598:	01 9f       	mul	r16, r17
    359a:	c0 01       	movw	r24, r0
    359c:	11 24       	eor	r1, r1
    359e:	01 96       	adiw	r24, 0x01	; 1
    35a0:	0e 94 74 14 	call	0x28e8	; 0x28e8 <pvPortMalloc>
    35a4:	99 83       	std	Y+1, r25	; 0x01
    35a6:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    35a8:	00 97       	sbiw	r24, 0x00	; 0
    35aa:	41 f0       	breq	.+16     	; 0x35bc <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    35ac:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    35ae:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    35b0:	ce 01       	movw	r24, r28
    35b2:	61 e0       	ldi	r22, 0x01	; 1
    35b4:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    35b8:	9e 01       	movw	r18, r28
    35ba:	05 c0       	rjmp	.+10     	; 0x35c6 <xQueueGenericCreate+0x4c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    35bc:	ce 01       	movw	r24, r28
    35be:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortFree>
    35c2:	20 e0       	ldi	r18, 0x00	; 0
    35c4:	30 e0       	ldi	r19, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    35c6:	c9 01       	movw	r24, r18
    35c8:	df 91       	pop	r29
    35ca:	cf 91       	pop	r28
    35cc:	1f 91       	pop	r17
    35ce:	0f 91       	pop	r16
    35d0:	08 95       	ret

000035d2 <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    35d2:	0f b6       	in	r0, 0x3f	; 63
    35d4:	f8 94       	cli
    35d6:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    35d8:	00 97       	sbiw	r24, 0x00	; 0
    35da:	29 f4       	brne	.+10     	; 0x35e6 <uxTaskPriorityGet+0x14>
    35dc:	e0 91 ac 07 	lds	r30, 0x07AC
    35e0:	f0 91 ad 07 	lds	r31, 0x07AD
    35e4:	01 c0       	rjmp	.+2      	; 0x35e8 <uxTaskPriorityGet+0x16>
    35e6:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    35e8:	0f 90       	pop	r0
    35ea:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    35ec:	86 89       	ldd	r24, Z+22	; 0x16
    35ee:	08 95       	ret

000035f0 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    35f0:	80 91 b3 07 	lds	r24, 0x07B3
    35f4:	8f 5f       	subi	r24, 0xFF	; 255
    35f6:	80 93 b3 07 	sts	0x07B3, r24
}
    35fa:	08 95       	ret

000035fc <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    35fc:	0f b6       	in	r0, 0x3f	; 63
    35fe:	f8 94       	cli
    3600:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3602:	20 91 af 07 	lds	r18, 0x07AF
    3606:	30 91 b0 07 	lds	r19, 0x07B0
	}
	taskEXIT_CRITICAL();
    360a:	0f 90       	pop	r0
    360c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    360e:	c9 01       	movw	r24, r18
    3610:	08 95       	ret

00003612 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    3612:	20 91 af 07 	lds	r18, 0x07AF
    3616:	30 91 b0 07 	lds	r19, 0x07B0
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    361a:	c9 01       	movw	r24, r18
    361c:	08 95       	ret

0000361e <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    361e:	80 91 b5 07 	lds	r24, 0x07B5
}
    3622:	08 95       	ret

00003624 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3624:	80 91 b3 07 	lds	r24, 0x07B3
    3628:	88 23       	and	r24, r24
    362a:	21 f0       	breq	.+8      	; 0x3634 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    362c:	81 e0       	ldi	r24, 0x01	; 1
    362e:	80 93 ae 07 	sts	0x07AE, r24
    3632:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    3634:	10 92 ae 07 	sts	0x07AE, r1
    3638:	05 c0       	rjmp	.+10     	; 0x3644 <vTaskSwitchContext+0x20>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    363a:	80 91 b2 07 	lds	r24, 0x07B2
    363e:	81 50       	subi	r24, 0x01	; 1
    3640:	80 93 b2 07 	sts	0x07B2, r24
    3644:	80 91 b2 07 	lds	r24, 0x07B2
    3648:	90 e0       	ldi	r25, 0x00	; 0
    364a:	fc 01       	movw	r30, r24
    364c:	23 e0       	ldi	r18, 0x03	; 3
    364e:	ee 0f       	add	r30, r30
    3650:	ff 1f       	adc	r31, r31
    3652:	2a 95       	dec	r18
    3654:	e1 f7       	brne	.-8      	; 0x364e <vTaskSwitchContext+0x2a>
    3656:	e8 0f       	add	r30, r24
    3658:	f9 1f       	adc	r31, r25
    365a:	e7 54       	subi	r30, 0x47	; 71
    365c:	f8 4f       	sbci	r31, 0xF8	; 248
    365e:	80 81       	ld	r24, Z
    3660:	88 23       	and	r24, r24
    3662:	59 f3       	breq	.-42     	; 0x363a <vTaskSwitchContext+0x16>
    3664:	90 91 b2 07 	lds	r25, 0x07B2
    3668:	89 e0       	ldi	r24, 0x09	; 9
    366a:	98 9f       	mul	r25, r24
    366c:	d0 01       	movw	r26, r0
    366e:	11 24       	eor	r1, r1
    3670:	a7 54       	subi	r26, 0x47	; 71
    3672:	b8 4f       	sbci	r27, 0xF8	; 248
    3674:	11 96       	adiw	r26, 0x01	; 1
    3676:	ed 91       	ld	r30, X+
    3678:	fc 91       	ld	r31, X
    367a:	12 97       	sbiw	r26, 0x02	; 2
    367c:	02 80       	ldd	r0, Z+2	; 0x02
    367e:	f3 81       	ldd	r31, Z+3	; 0x03
    3680:	e0 2d       	mov	r30, r0
    3682:	12 96       	adiw	r26, 0x02	; 2
    3684:	fc 93       	st	X, r31
    3686:	ee 93       	st	-X, r30
    3688:	11 97       	sbiw	r26, 0x01	; 1
    368a:	cd 01       	movw	r24, r26
    368c:	03 96       	adiw	r24, 0x03	; 3
    368e:	e8 17       	cp	r30, r24
    3690:	f9 07       	cpc	r31, r25
    3692:	31 f4       	brne	.+12     	; 0x36a0 <vTaskSwitchContext+0x7c>
    3694:	82 81       	ldd	r24, Z+2	; 0x02
    3696:	93 81       	ldd	r25, Z+3	; 0x03
    3698:	12 96       	adiw	r26, 0x02	; 2
    369a:	9c 93       	st	X, r25
    369c:	8e 93       	st	-X, r24
    369e:	11 97       	sbiw	r26, 0x01	; 1
    36a0:	11 96       	adiw	r26, 0x01	; 1
    36a2:	ed 91       	ld	r30, X+
    36a4:	fc 91       	ld	r31, X
    36a6:	12 97       	sbiw	r26, 0x02	; 2
    36a8:	86 81       	ldd	r24, Z+6	; 0x06
    36aa:	97 81       	ldd	r25, Z+7	; 0x07
    36ac:	90 93 ad 07 	sts	0x07AD, r25
    36b0:	80 93 ac 07 	sts	0x07AC, r24
    36b4:	08 95       	ret

000036b6 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    36b6:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    36b8:	80 91 b1 07 	lds	r24, 0x07B1
    36bc:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    36be:	80 91 af 07 	lds	r24, 0x07AF
    36c2:	90 91 b0 07 	lds	r25, 0x07B0
    36c6:	92 83       	std	Z+2, r25	; 0x02
    36c8:	81 83       	std	Z+1, r24	; 0x01
}
    36ca:	08 95       	ret

000036cc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    36cc:	fc 01       	movw	r30, r24
    36ce:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    36d0:	0f b6       	in	r0, 0x3f	; 63
    36d2:	f8 94       	cli
    36d4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    36d6:	40 91 af 07 	lds	r20, 0x07AF
    36da:	50 91 b0 07 	lds	r21, 0x07B0

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    36de:	6d 91       	ld	r22, X+
    36e0:	7c 91       	ld	r23, X
    36e2:	11 97       	sbiw	r26, 0x01	; 1
    36e4:	8f ef       	ldi	r24, 0xFF	; 255
    36e6:	6f 3f       	cpi	r22, 0xFF	; 255
    36e8:	78 07       	cpc	r23, r24
    36ea:	09 f1       	breq	.+66     	; 0x372e <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    36ec:	90 91 b1 07 	lds	r25, 0x07B1
    36f0:	80 81       	ld	r24, Z
    36f2:	98 17       	cp	r25, r24
    36f4:	29 f0       	breq	.+10     	; 0x3700 <xTaskCheckForTimeOut+0x34>
    36f6:	81 81       	ldd	r24, Z+1	; 0x01
    36f8:	92 81       	ldd	r25, Z+2	; 0x02
    36fa:	48 17       	cp	r20, r24
    36fc:	59 07       	cpc	r21, r25
    36fe:	c8 f4       	brcc	.+50     	; 0x3732 <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3700:	21 81       	ldd	r18, Z+1	; 0x01
    3702:	32 81       	ldd	r19, Z+2	; 0x02
    3704:	ca 01       	movw	r24, r20
    3706:	82 1b       	sub	r24, r18
    3708:	93 0b       	sbc	r25, r19
    370a:	86 17       	cp	r24, r22
    370c:	97 07       	cpc	r25, r23
    370e:	88 f4       	brcc	.+34     	; 0x3732 <xTaskCheckForTimeOut+0x66>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    3710:	24 1b       	sub	r18, r20
    3712:	35 0b       	sbc	r19, r21
    3714:	26 0f       	add	r18, r22
    3716:	37 1f       	adc	r19, r23
    3718:	2d 93       	st	X+, r18
    371a:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    371c:	80 91 b1 07 	lds	r24, 0x07B1
    3720:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3722:	80 91 af 07 	lds	r24, 0x07AF
    3726:	90 91 b0 07 	lds	r25, 0x07B0
    372a:	92 83       	std	Z+2, r25	; 0x02
    372c:	81 83       	std	Z+1, r24	; 0x01
    372e:	80 e0       	ldi	r24, 0x00	; 0
    3730:	01 c0       	rjmp	.+2      	; 0x3734 <xTaskCheckForTimeOut+0x68>
    3732:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    3734:	0f 90       	pop	r0
    3736:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3738:	08 95       	ret

0000373a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    373a:	81 e0       	ldi	r24, 0x01	; 1
    373c:	80 93 ae 07 	sts	0x07AE, r24
}
    3740:	08 95       	ret

00003742 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3742:	20 91 ac 07 	lds	r18, 0x07AC
    3746:	30 91 ad 07 	lds	r19, 0x07AD

		return xReturn;
	}
    374a:	c9 01       	movw	r24, r18
    374c:	08 95       	ret

0000374e <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    374e:	e0 91 ac 07 	lds	r30, 0x07AC
    3752:	f0 91 ad 07 	lds	r31, 0x07AD
    3756:	84 85       	ldd	r24, Z+12	; 0x0c
    3758:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    375a:	a0 91 ac 07 	lds	r26, 0x07AC
    375e:	b0 91 ad 07 	lds	r27, 0x07AD
    3762:	e0 91 ac 07 	lds	r30, 0x07AC
    3766:	f0 91 ad 07 	lds	r31, 0x07AD
    376a:	46 89       	ldd	r20, Z+22	; 0x16
    376c:	27 e0       	ldi	r18, 0x07	; 7
    376e:	30 e0       	ldi	r19, 0x00	; 0
    3770:	24 1b       	sub	r18, r20
    3772:	31 09       	sbc	r19, r1
    3774:	1d 96       	adiw	r26, 0x0d	; 13
    3776:	3c 93       	st	X, r19
    3778:	2e 93       	st	-X, r18
    377a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
}
    377c:	08 95       	ret

0000377e <xTaskRemoveFromUnorderedEventList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    377e:	0f 93       	push	r16
    3780:	1f 93       	push	r17
    3782:	cf 93       	push	r28
    3784:	df 93       	push	r29
    3786:	fc 01       	movw	r30, r24
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3788:	70 68       	ori	r23, 0x80	; 128
    378a:	71 83       	std	Z+1, r23	; 0x01
    378c:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    378e:	c6 81       	ldd	r28, Z+6	; 0x06
    3790:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3792:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3796:	8e 01       	movw	r16, r28
    3798:	0e 5f       	subi	r16, 0xFE	; 254
    379a:	1f 4f       	sbci	r17, 0xFF	; 255
    379c:	c8 01       	movw	r24, r16
    379e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    37a2:	9e 89       	ldd	r25, Y+22	; 0x16
    37a4:	80 91 b2 07 	lds	r24, 0x07B2
    37a8:	89 17       	cp	r24, r25
    37aa:	10 f4       	brcc	.+4      	; 0x37b0 <xTaskRemoveFromUnorderedEventList+0x32>
    37ac:	90 93 b2 07 	sts	0x07B2, r25
    37b0:	89 e0       	ldi	r24, 0x09	; 9
    37b2:	98 9f       	mul	r25, r24
    37b4:	c0 01       	movw	r24, r0
    37b6:	11 24       	eor	r1, r1
    37b8:	87 54       	subi	r24, 0x47	; 71
    37ba:	98 4f       	sbci	r25, 0xF8	; 248
    37bc:	b8 01       	movw	r22, r16
    37be:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    37c2:	e0 91 ac 07 	lds	r30, 0x07AC
    37c6:	f0 91 ad 07 	lds	r31, 0x07AD
    37ca:	9e 89       	ldd	r25, Y+22	; 0x16
    37cc:	86 89       	ldd	r24, Z+22	; 0x16
    37ce:	89 17       	cp	r24, r25
    37d0:	10 f0       	brcs	.+4      	; 0x37d6 <xTaskRemoveFromUnorderedEventList+0x58>
    37d2:	80 e0       	ldi	r24, 0x00	; 0
    37d4:	03 c0       	rjmp	.+6      	; 0x37dc <xTaskRemoveFromUnorderedEventList+0x5e>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	80 93 ae 07 	sts	0x07AE, r24
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    37dc:	df 91       	pop	r29
    37de:	cf 91       	pop	r28
    37e0:	1f 91       	pop	r17
    37e2:	0f 91       	pop	r16
    37e4:	08 95       	ret

000037e6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    37e6:	0f 93       	push	r16
    37e8:	1f 93       	push	r17
    37ea:	cf 93       	push	r28
    37ec:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    37ee:	dc 01       	movw	r26, r24
    37f0:	15 96       	adiw	r26, 0x05	; 5
    37f2:	ed 91       	ld	r30, X+
    37f4:	fc 91       	ld	r31, X
    37f6:	16 97       	sbiw	r26, 0x06	; 6
    37f8:	c6 81       	ldd	r28, Z+6	; 0x06
    37fa:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    37fc:	8e 01       	movw	r16, r28
    37fe:	04 5f       	subi	r16, 0xF4	; 244
    3800:	1f 4f       	sbci	r17, 0xFF	; 255
    3802:	c8 01       	movw	r24, r16
    3804:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3808:	80 91 b3 07 	lds	r24, 0x07B3
    380c:	88 23       	and	r24, r24
    380e:	a1 f4       	brne	.+40     	; 0x3838 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3810:	8e 01       	movw	r16, r28
    3812:	0e 5f       	subi	r16, 0xFE	; 254
    3814:	1f 4f       	sbci	r17, 0xFF	; 255
    3816:	c8 01       	movw	r24, r16
    3818:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    381c:	9e 89       	ldd	r25, Y+22	; 0x16
    381e:	80 91 b2 07 	lds	r24, 0x07B2
    3822:	89 17       	cp	r24, r25
    3824:	10 f4       	brcc	.+4      	; 0x382a <xTaskRemoveFromEventList+0x44>
    3826:	90 93 b2 07 	sts	0x07B2, r25
    382a:	89 e0       	ldi	r24, 0x09	; 9
    382c:	98 9f       	mul	r25, r24
    382e:	c0 01       	movw	r24, r0
    3830:	11 24       	eor	r1, r1
    3832:	87 54       	subi	r24, 0x47	; 71
    3834:	98 4f       	sbci	r25, 0xF8	; 248
    3836:	02 c0       	rjmp	.+4      	; 0x383c <xTaskRemoveFromEventList+0x56>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3838:	8e e0       	ldi	r24, 0x0E	; 14
    383a:	98 e0       	ldi	r25, 0x08	; 8
    383c:	b8 01       	movw	r22, r16
    383e:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3842:	e0 91 ac 07 	lds	r30, 0x07AC
    3846:	f0 91 ad 07 	lds	r31, 0x07AD
    384a:	9e 89       	ldd	r25, Y+22	; 0x16
    384c:	86 89       	ldd	r24, Z+22	; 0x16
    384e:	89 17       	cp	r24, r25
    3850:	10 f0       	brcs	.+4      	; 0x3856 <xTaskRemoveFromEventList+0x70>
    3852:	80 e0       	ldi	r24, 0x00	; 0
    3854:	03 c0       	rjmp	.+6      	; 0x385c <xTaskRemoveFromEventList+0x76>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3856:	81 e0       	ldi	r24, 0x01	; 1
    3858:	80 93 ae 07 	sts	0x07AE, r24
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    385c:	df 91       	pop	r29
    385e:	cf 91       	pop	r28
    3860:	1f 91       	pop	r17
    3862:	0f 91       	pop	r16
    3864:	08 95       	ret

00003866 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3866:	cf 92       	push	r12
    3868:	df 92       	push	r13
    386a:	ef 92       	push	r14
    386c:	ff 92       	push	r15
    386e:	0f 93       	push	r16
    3870:	1f 93       	push	r17
    3872:	cf 93       	push	r28
    3874:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3876:	80 91 b3 07 	lds	r24, 0x07B3
    387a:	88 23       	and	r24, r24
    387c:	09 f0       	breq	.+2      	; 0x3880 <xTaskIncrementTick+0x1a>
    387e:	a7 c0       	rjmp	.+334    	; 0x39ce <xTaskIncrementTick+0x168>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3880:	80 91 af 07 	lds	r24, 0x07AF
    3884:	90 91 b0 07 	lds	r25, 0x07B0
    3888:	01 96       	adiw	r24, 0x01	; 1
    388a:	90 93 b0 07 	sts	0x07B0, r25
    388e:	80 93 af 07 	sts	0x07AF, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3892:	e0 90 af 07 	lds	r14, 0x07AF
    3896:	f0 90 b0 07 	lds	r15, 0x07B0

			if( xConstTickCount == ( TickType_t ) 0U )
    389a:	e1 14       	cp	r14, r1
    389c:	f1 04       	cpc	r15, r1
    389e:	79 f5       	brne	.+94     	; 0x38fe <xTaskIncrementTick+0x98>
			{
				taskSWITCH_DELAYED_LISTS();
    38a0:	20 91 0a 08 	lds	r18, 0x080A
    38a4:	30 91 0b 08 	lds	r19, 0x080B
    38a8:	80 91 0c 08 	lds	r24, 0x080C
    38ac:	90 91 0d 08 	lds	r25, 0x080D
    38b0:	90 93 0b 08 	sts	0x080B, r25
    38b4:	80 93 0a 08 	sts	0x080A, r24
    38b8:	30 93 0d 08 	sts	0x080D, r19
    38bc:	20 93 0c 08 	sts	0x080C, r18
    38c0:	80 91 b1 07 	lds	r24, 0x07B1
    38c4:	8f 5f       	subi	r24, 0xFF	; 255
    38c6:	80 93 b1 07 	sts	0x07B1, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    38ca:	e0 91 0a 08 	lds	r30, 0x080A
    38ce:	f0 91 0b 08 	lds	r31, 0x080B
    38d2:	80 81       	ld	r24, Z
    38d4:	88 23       	and	r24, r24
    38d6:	19 f4       	brne	.+6      	; 0x38de <xTaskIncrementTick+0x78>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    38d8:	8f ef       	ldi	r24, 0xFF	; 255
    38da:	9f ef       	ldi	r25, 0xFF	; 255
    38dc:	0c c0       	rjmp	.+24     	; 0x38f6 <xTaskIncrementTick+0x90>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    38de:	e0 91 0a 08 	lds	r30, 0x080A
    38e2:	f0 91 0b 08 	lds	r31, 0x080B
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    38e6:	05 80       	ldd	r0, Z+5	; 0x05
    38e8:	f6 81       	ldd	r31, Z+6	; 0x06
    38ea:	e0 2d       	mov	r30, r0
    38ec:	06 80       	ldd	r0, Z+6	; 0x06
    38ee:	f7 81       	ldd	r31, Z+7	; 0x07
    38f0:	e0 2d       	mov	r30, r0
    38f2:	82 81       	ldd	r24, Z+2	; 0x02
    38f4:	93 81       	ldd	r25, Z+3	; 0x03
    38f6:	90 93 de 01 	sts	0x01DE, r25
    38fa:	80 93 dd 01 	sts	0x01DD, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    38fe:	80 91 dd 01 	lds	r24, 0x01DD
    3902:	90 91 de 01 	lds	r25, 0x01DE
    3906:	e8 16       	cp	r14, r24
    3908:	f9 06       	cpc	r15, r25
    390a:	08 f4       	brcc	.+2      	; 0x390e <xTaskIncrementTick+0xa8>
    390c:	49 c0       	rjmp	.+146    	; 0x39a0 <xTaskIncrementTick+0x13a>
    390e:	dd 24       	eor	r13, r13
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3910:	49 e0       	ldi	r20, 0x09	; 9
    3912:	c4 2e       	mov	r12, r20
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3914:	e0 91 0a 08 	lds	r30, 0x080A
    3918:	f0 91 0b 08 	lds	r31, 0x080B
    391c:	80 81       	ld	r24, Z
    391e:	88 23       	and	r24, r24
    3920:	19 f4       	brne	.+6      	; 0x3928 <xTaskIncrementTick+0xc2>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    3922:	8f ef       	ldi	r24, 0xFF	; 255
    3924:	9f ef       	ldi	r25, 0xFF	; 255
    3926:	0e c0       	rjmp	.+28     	; 0x3944 <xTaskIncrementTick+0xde>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3928:	e0 91 0a 08 	lds	r30, 0x080A
    392c:	f0 91 0b 08 	lds	r31, 0x080B
    3930:	05 80       	ldd	r0, Z+5	; 0x05
    3932:	f6 81       	ldd	r31, Z+6	; 0x06
    3934:	e0 2d       	mov	r30, r0
    3936:	c6 81       	ldd	r28, Z+6	; 0x06
    3938:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    393a:	8a 81       	ldd	r24, Y+2	; 0x02
    393c:	9b 81       	ldd	r25, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    393e:	e8 16       	cp	r14, r24
    3940:	f9 06       	cpc	r15, r25
    3942:	28 f4       	brcc	.+10     	; 0x394e <xTaskIncrementTick+0xe8>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    3944:	90 93 de 01 	sts	0x01DE, r25
    3948:	80 93 dd 01 	sts	0x01DD, r24
    394c:	2a c0       	rjmp	.+84     	; 0x39a2 <xTaskIncrementTick+0x13c>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    394e:	8e 01       	movw	r16, r28
    3950:	0e 5f       	subi	r16, 0xFE	; 254
    3952:	1f 4f       	sbci	r17, 0xFF	; 255
    3954:	c8 01       	movw	r24, r16
    3956:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    395a:	8c 89       	ldd	r24, Y+20	; 0x14
    395c:	9d 89       	ldd	r25, Y+21	; 0x15
    395e:	89 2b       	or	r24, r25
    3960:	21 f0       	breq	.+8      	; 0x396a <xTaskIncrementTick+0x104>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3962:	ce 01       	movw	r24, r28
    3964:	0c 96       	adiw	r24, 0x0c	; 12
    3966:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    396a:	9e 89       	ldd	r25, Y+22	; 0x16
    396c:	80 91 b2 07 	lds	r24, 0x07B2
    3970:	89 17       	cp	r24, r25
    3972:	10 f4       	brcc	.+4      	; 0x3978 <xTaskIncrementTick+0x112>
    3974:	90 93 b2 07 	sts	0x07B2, r25
    3978:	9c 9d       	mul	r25, r12
    397a:	c0 01       	movw	r24, r0
    397c:	11 24       	eor	r1, r1
    397e:	87 54       	subi	r24, 0x47	; 71
    3980:	98 4f       	sbci	r25, 0xF8	; 248
    3982:	b8 01       	movw	r22, r16
    3984:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3988:	e0 91 ac 07 	lds	r30, 0x07AC
    398c:	f0 91 ad 07 	lds	r31, 0x07AD
    3990:	9e 89       	ldd	r25, Y+22	; 0x16
    3992:	86 89       	ldd	r24, Z+22	; 0x16
    3994:	98 17       	cp	r25, r24
    3996:	08 f4       	brcc	.+2      	; 0x399a <xTaskIncrementTick+0x134>
    3998:	bd cf       	rjmp	.-134    	; 0x3914 <xTaskIncrementTick+0xae>
    399a:	dd 24       	eor	r13, r13
    399c:	d3 94       	inc	r13
    399e:	ba cf       	rjmp	.-140    	; 0x3914 <xTaskIncrementTick+0xae>
    39a0:	dd 24       	eor	r13, r13
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    39a2:	e0 91 ac 07 	lds	r30, 0x07AC
    39a6:	f0 91 ad 07 	lds	r31, 0x07AD
    39aa:	86 89       	ldd	r24, Z+22	; 0x16
    39ac:	90 e0       	ldi	r25, 0x00	; 0
    39ae:	fc 01       	movw	r30, r24
    39b0:	33 e0       	ldi	r19, 0x03	; 3
    39b2:	ee 0f       	add	r30, r30
    39b4:	ff 1f       	adc	r31, r31
    39b6:	3a 95       	dec	r19
    39b8:	e1 f7       	brne	.-8      	; 0x39b2 <xTaskIncrementTick+0x14c>
    39ba:	e8 0f       	add	r30, r24
    39bc:	f9 1f       	adc	r31, r25
    39be:	e7 54       	subi	r30, 0x47	; 71
    39c0:	f8 4f       	sbci	r31, 0xF8	; 248
    39c2:	80 81       	ld	r24, Z
    39c4:	82 30       	cpi	r24, 0x02	; 2
    39c6:	48 f0       	brcs	.+18     	; 0x39da <xTaskIncrementTick+0x174>
    39c8:	dd 24       	eor	r13, r13
    39ca:	d3 94       	inc	r13
    39cc:	06 c0       	rjmp	.+12     	; 0x39da <xTaskIncrementTick+0x174>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    39ce:	80 91 b4 07 	lds	r24, 0x07B4
    39d2:	8f 5f       	subi	r24, 0xFF	; 255
    39d4:	80 93 b4 07 	sts	0x07B4, r24
    39d8:	dd 24       	eor	r13, r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    39da:	80 91 ae 07 	lds	r24, 0x07AE
    39de:	88 23       	and	r24, r24
    39e0:	11 f0       	breq	.+4      	; 0x39e6 <xTaskIncrementTick+0x180>
    39e2:	dd 24       	eor	r13, r13
    39e4:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    39e6:	8d 2d       	mov	r24, r13
    39e8:	df 91       	pop	r29
    39ea:	cf 91       	pop	r28
    39ec:	1f 91       	pop	r17
    39ee:	0f 91       	pop	r16
    39f0:	ff 90       	pop	r15
    39f2:	ef 90       	pop	r14
    39f4:	df 90       	pop	r13
    39f6:	cf 90       	pop	r12
    39f8:	08 95       	ret

000039fa <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    39fa:	df 92       	push	r13
    39fc:	ef 92       	push	r14
    39fe:	ff 92       	push	r15
    3a00:	0f 93       	push	r16
    3a02:	1f 93       	push	r17
    3a04:	cf 93       	push	r28
    3a06:	df 93       	push	r29
	BaseType_t xYieldRequired = pdFALSE;
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    3a08:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3a0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a0e:	80 52       	subi	r24, 0x20	; 32
    3a10:	98 40       	sbci	r25, 0x08	; 8
    3a12:	91 f5       	brne	.+100    	; 0x3a78 <xTaskResumeFromISR+0x7e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3a14:	8c 89       	ldd	r24, Y+20	; 0x14
    3a16:	9d 89       	ldd	r25, Y+21	; 0x15
    3a18:	28 e0       	ldi	r18, 0x08	; 8
    3a1a:	8e 30       	cpi	r24, 0x0E	; 14
    3a1c:	92 07       	cpc	r25, r18
    3a1e:	61 f1       	breq	.+88     	; 0x3a78 <xTaskResumeFromISR+0x7e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    3a20:	89 2b       	or	r24, r25
    3a22:	51 f5       	brne	.+84     	; 0x3a78 <xTaskResumeFromISR+0x7e>
    3a24:	33 c0       	rjmp	.+102    	; 0x3a8c <xTaskResumeFromISR+0x92>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3a26:	de 88       	ldd	r13, Y+22	; 0x16
    3a28:	e0 91 ac 07 	lds	r30, 0x07AC
    3a2c:	f0 91 ad 07 	lds	r31, 0x07AD
    3a30:	06 89       	ldd	r16, Z+22	; 0x16
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    3a32:	52 e0       	ldi	r21, 0x02	; 2
    3a34:	e5 2e       	mov	r14, r21
    3a36:	f1 2c       	mov	r15, r1
    3a38:	ec 0e       	add	r14, r28
    3a3a:	fd 1e       	adc	r15, r29
    3a3c:	c7 01       	movw	r24, r14
    3a3e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3a42:	6e 89       	ldd	r22, Y+22	; 0x16
    3a44:	80 91 b2 07 	lds	r24, 0x07B2
    3a48:	86 17       	cp	r24, r22
    3a4a:	10 f4       	brcc	.+4      	; 0x3a50 <xTaskResumeFromISR+0x56>
    3a4c:	60 93 b2 07 	sts	0x07B2, r22
    3a50:	10 e0       	ldi	r17, 0x00	; 0
    3a52:	d0 16       	cp	r13, r16
    3a54:	08 f0       	brcs	.+2      	; 0x3a58 <xTaskResumeFromISR+0x5e>
    3a56:	11 e0       	ldi	r17, 0x01	; 1
    3a58:	89 e0       	ldi	r24, 0x09	; 9
    3a5a:	68 9f       	mul	r22, r24
    3a5c:	c0 01       	movw	r24, r0
    3a5e:	11 24       	eor	r1, r1
    3a60:	87 54       	subi	r24, 0x47	; 71
    3a62:	98 4f       	sbci	r25, 0xF8	; 248
    3a64:	b7 01       	movw	r22, r14
    3a66:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
    3a6a:	07 c0       	rjmp	.+14     	; 0x3a7a <xTaskResumeFromISR+0x80>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3a6c:	2c 96       	adiw	r28, 0x0c	; 12
    3a6e:	8e e0       	ldi	r24, 0x0E	; 14
    3a70:	98 e0       	ldi	r25, 0x08	; 8
    3a72:	be 01       	movw	r22, r28
    3a74:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
    3a78:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    3a7a:	81 2f       	mov	r24, r17
    3a7c:	df 91       	pop	r29
    3a7e:	cf 91       	pop	r28
    3a80:	1f 91       	pop	r17
    3a82:	0f 91       	pop	r16
    3a84:	ff 90       	pop	r15
    3a86:	ef 90       	pop	r14
    3a88:	df 90       	pop	r13
    3a8a:	08 95       	ret
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a8c:	80 91 b3 07 	lds	r24, 0x07B3
    3a90:	88 23       	and	r24, r24
    3a92:	49 f2       	breq	.-110    	; 0x3a26 <xTaskResumeFromISR+0x2c>
    3a94:	eb cf       	rjmp	.-42     	; 0x3a6c <xTaskResumeFromISR+0x72>

00003a96 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    3a96:	cf 93       	push	r28
    3a98:	df 93       	push	r29
    3a9a:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    3a9c:	e0 91 ac 07 	lds	r30, 0x07AC
    3aa0:	f0 91 ad 07 	lds	r31, 0x07AD
    3aa4:	93 83       	std	Z+3, r25	; 0x03
    3aa6:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    3aa8:	80 91 af 07 	lds	r24, 0x07AF
    3aac:	90 91 b0 07 	lds	r25, 0x07B0
    3ab0:	c8 17       	cp	r28, r24
    3ab2:	d9 07       	cpc	r29, r25
    3ab4:	68 f4       	brcc	.+26     	; 0x3ad0 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3ab6:	80 91 0c 08 	lds	r24, 0x080C
    3aba:	90 91 0d 08 	lds	r25, 0x080D
    3abe:	60 91 ac 07 	lds	r22, 0x07AC
    3ac2:	70 91 ad 07 	lds	r23, 0x07AD
    3ac6:	6e 5f       	subi	r22, 0xFE	; 254
    3ac8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aca:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <vListInsert>
    3ace:	17 c0       	rjmp	.+46     	; 0x3afe <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3ad0:	80 91 0a 08 	lds	r24, 0x080A
    3ad4:	90 91 0b 08 	lds	r25, 0x080B
    3ad8:	60 91 ac 07 	lds	r22, 0x07AC
    3adc:	70 91 ad 07 	lds	r23, 0x07AD
    3ae0:	6e 5f       	subi	r22, 0xFE	; 254
    3ae2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ae4:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3ae8:	80 91 dd 01 	lds	r24, 0x01DD
    3aec:	90 91 de 01 	lds	r25, 0x01DE
    3af0:	c8 17       	cp	r28, r24
    3af2:	d9 07       	cpc	r29, r25
    3af4:	20 f4       	brcc	.+8      	; 0x3afe <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3af6:	d0 93 de 01 	sts	0x01DE, r29
    3afa:	c0 93 dd 01 	sts	0x01DD, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    3afe:	df 91       	pop	r29
    3b00:	cf 91       	pop	r28
    3b02:	08 95       	ret

00003b04 <vTaskPlaceOnUnorderedEventList>:
	#endif /* INCLUDE_vTaskSuspend */
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3b04:	cf 93       	push	r28
    3b06:	df 93       	push	r29
    3b08:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3b0a:	e0 91 ac 07 	lds	r30, 0x07AC
    3b0e:	f0 91 ad 07 	lds	r31, 0x07AD
    3b12:	70 68       	ori	r23, 0x80	; 128
    3b14:	75 87       	std	Z+13, r23	; 0x0d
    3b16:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3b18:	60 91 ac 07 	lds	r22, 0x07AC
    3b1c:	70 91 ad 07 	lds	r23, 0x07AD
    3b20:	64 5f       	subi	r22, 0xF4	; 244
    3b22:	7f 4f       	sbci	r23, 0xFF	; 255
    3b24:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3b28:	80 91 ac 07 	lds	r24, 0x07AC
    3b2c:	90 91 ad 07 	lds	r25, 0x07AD
    3b30:	02 96       	adiw	r24, 0x02	; 2
    3b32:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    3b36:	8f ef       	ldi	r24, 0xFF	; 255
    3b38:	cf 3f       	cpi	r28, 0xFF	; 255
    3b3a:	d8 07       	cpc	r29, r24
    3b3c:	59 f4       	brne	.+22     	; 0x3b54 <vTaskPlaceOnUnorderedEventList+0x50>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3b3e:	60 91 ac 07 	lds	r22, 0x07AC
    3b42:	70 91 ad 07 	lds	r23, 0x07AD
    3b46:	6e 5f       	subi	r22, 0xFE	; 254
    3b48:	7f 4f       	sbci	r23, 0xFF	; 255
    3b4a:	80 e2       	ldi	r24, 0x20	; 32
    3b4c:	98 e0       	ldi	r25, 0x08	; 8
    3b4e:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
    3b52:	08 c0       	rjmp	.+16     	; 0x3b64 <vTaskPlaceOnUnorderedEventList+0x60>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    3b54:	80 91 af 07 	lds	r24, 0x07AF
    3b58:	90 91 b0 07 	lds	r25, 0x07B0
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3b5c:	8c 0f       	add	r24, r28
    3b5e:	9d 1f       	adc	r25, r29
    3b60:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3b64:	df 91       	pop	r29
    3b66:	cf 91       	pop	r28
    3b68:	08 95       	ret

00003b6a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3b6a:	cf 93       	push	r28
    3b6c:	df 93       	push	r29
    3b6e:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3b70:	60 91 ac 07 	lds	r22, 0x07AC
    3b74:	70 91 ad 07 	lds	r23, 0x07AD
    3b78:	64 5f       	subi	r22, 0xF4	; 244
    3b7a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b7c:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3b80:	80 91 ac 07 	lds	r24, 0x07AC
    3b84:	90 91 ad 07 	lds	r25, 0x07AD
    3b88:	02 96       	adiw	r24, 0x02	; 2
    3b8a:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    3b8e:	8f ef       	ldi	r24, 0xFF	; 255
    3b90:	cf 3f       	cpi	r28, 0xFF	; 255
    3b92:	d8 07       	cpc	r29, r24
    3b94:	59 f4       	brne	.+22     	; 0x3bac <vTaskPlaceOnEventList+0x42>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3b96:	60 91 ac 07 	lds	r22, 0x07AC
    3b9a:	70 91 ad 07 	lds	r23, 0x07AD
    3b9e:	6e 5f       	subi	r22, 0xFE	; 254
    3ba0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ba2:	80 e2       	ldi	r24, 0x20	; 32
    3ba4:	98 e0       	ldi	r25, 0x08	; 8
    3ba6:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
    3baa:	08 c0       	rjmp	.+16     	; 0x3bbc <vTaskPlaceOnEventList+0x52>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3bac:	80 91 af 07 	lds	r24, 0x07AF
    3bb0:	90 91 b0 07 	lds	r25, 0x07B0
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3bb4:	8c 0f       	add	r24, r28
    3bb6:	9d 1f       	adc	r25, r29
    3bb8:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3bbc:	df 91       	pop	r29
    3bbe:	cf 91       	pop	r28
    3bc0:	08 95       	ret

00003bc2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3bc2:	ef 92       	push	r14
    3bc4:	ff 92       	push	r15
    3bc6:	0f 93       	push	r16
    3bc8:	1f 93       	push	r17
    3bca:	cf 93       	push	r28
    3bcc:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3bce:	0f b6       	in	r0, 0x3f	; 63
    3bd0:	f8 94       	cli
    3bd2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3bd4:	80 91 b3 07 	lds	r24, 0x07B3
    3bd8:	81 50       	subi	r24, 0x01	; 1
    3bda:	80 93 b3 07 	sts	0x07B3, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3bde:	80 91 b3 07 	lds	r24, 0x07B3
    3be2:	88 23       	and	r24, r24
    3be4:	09 f0       	breq	.+2      	; 0x3be8 <xTaskResumeAll+0x26>
    3be6:	55 c0       	rjmp	.+170    	; 0x3c92 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3be8:	80 91 b5 07 	lds	r24, 0x07B5
    3bec:	88 23       	and	r24, r24
    3bee:	59 f5       	brne	.+86     	; 0x3c46 <xTaskResumeAll+0x84>
    3bf0:	50 c0       	rjmp	.+160    	; 0x3c92 <xTaskResumeAll+0xd0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3bf2:	e0 91 13 08 	lds	r30, 0x0813
    3bf6:	f0 91 14 08 	lds	r31, 0x0814
    3bfa:	c6 81       	ldd	r28, Z+6	; 0x06
    3bfc:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3bfe:	ce 01       	movw	r24, r28
    3c00:	0c 96       	adiw	r24, 0x0c	; 12
    3c02:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3c06:	8e 01       	movw	r16, r28
    3c08:	0e 5f       	subi	r16, 0xFE	; 254
    3c0a:	1f 4f       	sbci	r17, 0xFF	; 255
    3c0c:	c8 01       	movw	r24, r16
    3c0e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3c12:	9e 89       	ldd	r25, Y+22	; 0x16
    3c14:	80 91 b2 07 	lds	r24, 0x07B2
    3c18:	89 17       	cp	r24, r25
    3c1a:	10 f4       	brcc	.+4      	; 0x3c20 <xTaskResumeAll+0x5e>
    3c1c:	90 93 b2 07 	sts	0x07B2, r25
    3c20:	9e 9d       	mul	r25, r14
    3c22:	c0 01       	movw	r24, r0
    3c24:	11 24       	eor	r1, r1
    3c26:	87 54       	subi	r24, 0x47	; 71
    3c28:	98 4f       	sbci	r25, 0xF8	; 248
    3c2a:	b8 01       	movw	r22, r16
    3c2c:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3c30:	e0 91 ac 07 	lds	r30, 0x07AC
    3c34:	f0 91 ad 07 	lds	r31, 0x07AD
    3c38:	9e 89       	ldd	r25, Y+22	; 0x16
    3c3a:	86 89       	ldd	r24, Z+22	; 0x16
    3c3c:	98 17       	cp	r25, r24
    3c3e:	38 f0       	brcs	.+14     	; 0x3c4e <xTaskResumeAll+0x8c>
					{
						xYieldPending = pdTRUE;
    3c40:	f0 92 ae 07 	sts	0x07AE, r15
    3c44:	04 c0       	rjmp	.+8      	; 0x3c4e <xTaskResumeAll+0x8c>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
    3c46:	69 e0       	ldi	r22, 0x09	; 9
    3c48:	e6 2e       	mov	r14, r22

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    3c4a:	ff 24       	eor	r15, r15
    3c4c:	f3 94       	inc	r15
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3c4e:	80 91 0e 08 	lds	r24, 0x080E
    3c52:	88 23       	and	r24, r24
    3c54:	71 f6       	brne	.-100    	; 0x3bf2 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    3c56:	80 91 b4 07 	lds	r24, 0x07B4
    3c5a:	88 23       	and	r24, r24
    3c5c:	69 f4       	brne	.+26     	; 0x3c78 <xTaskResumeAll+0xb6>
    3c5e:	11 c0       	rjmp	.+34     	; 0x3c82 <xTaskResumeAll+0xc0>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    3c60:	0e 94 33 1c 	call	0x3866	; 0x3866 <xTaskIncrementTick>
    3c64:	88 23       	and	r24, r24
    3c66:	11 f0       	breq	.+4      	; 0x3c6c <xTaskResumeAll+0xaa>
						{
							xYieldPending = pdTRUE;
    3c68:	10 93 ae 07 	sts	0x07AE, r17
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    3c6c:	80 91 b4 07 	lds	r24, 0x07B4
    3c70:	81 50       	subi	r24, 0x01	; 1
    3c72:	80 93 b4 07 	sts	0x07B4, r24
    3c76:	01 c0       	rjmp	.+2      	; 0x3c7a <xTaskResumeAll+0xb8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    3c78:	11 e0       	ldi	r17, 0x01	; 1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3c7a:	80 91 b4 07 	lds	r24, 0x07B4
    3c7e:	88 23       	and	r24, r24
    3c80:	79 f7       	brne	.-34     	; 0x3c60 <xTaskResumeAll+0x9e>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    3c82:	80 91 ae 07 	lds	r24, 0x07AE
    3c86:	81 30       	cpi	r24, 0x01	; 1
    3c88:	21 f4       	brne	.+8      	; 0x3c92 <xTaskResumeAll+0xd0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3c8a:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    3c8e:	81 e0       	ldi	r24, 0x01	; 1
    3c90:	01 c0       	rjmp	.+2      	; 0x3c94 <xTaskResumeAll+0xd2>
    3c92:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3c94:	0f 90       	pop	r0
    3c96:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    3c98:	df 91       	pop	r29
    3c9a:	cf 91       	pop	r28
    3c9c:	1f 91       	pop	r17
    3c9e:	0f 91       	pop	r16
    3ca0:	ff 90       	pop	r15
    3ca2:	ef 90       	pop	r14
    3ca4:	08 95       	ret

00003ca6 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3ca6:	0f 93       	push	r16
    3ca8:	1f 93       	push	r17
    3caa:	cf 93       	push	r28
    3cac:	df 93       	push	r29
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    3cae:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    3cb0:	00 97       	sbiw	r24, 0x00	; 0
    3cb2:	09 f4       	brne	.+2      	; 0x3cb6 <vTaskResume+0x10>
    3cb4:	3c c0       	rjmp	.+120    	; 0x3d2e <vTaskResume+0x88>
    3cb6:	80 91 ac 07 	lds	r24, 0x07AC
    3cba:	90 91 ad 07 	lds	r25, 0x07AD
    3cbe:	c8 17       	cp	r28, r24
    3cc0:	d9 07       	cpc	r29, r25
    3cc2:	a9 f1       	breq	.+106    	; 0x3d2e <vTaskResume+0x88>
		{
			taskENTER_CRITICAL();
    3cc4:	0f b6       	in	r0, 0x3f	; 63
    3cc6:	f8 94       	cli
    3cc8:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3cca:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ccc:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cce:	80 52       	subi	r24, 0x20	; 32
    3cd0:	98 40       	sbci	r25, 0x08	; 8
    3cd2:	f1 f4       	brne	.+60     	; 0x3d10 <vTaskResume+0x6a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3cd4:	8c 89       	ldd	r24, Y+20	; 0x14
    3cd6:	9d 89       	ldd	r25, Y+21	; 0x15
    3cd8:	28 e0       	ldi	r18, 0x08	; 8
    3cda:	8e 30       	cpi	r24, 0x0E	; 14
    3cdc:	92 07       	cpc	r25, r18
    3cde:	c1 f0       	breq	.+48     	; 0x3d10 <vTaskResume+0x6a>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    3ce0:	89 2b       	or	r24, r25
    3ce2:	b1 f4       	brne	.+44     	; 0x3d10 <vTaskResume+0x6a>
    3ce4:	18 c0       	rjmp	.+48     	; 0x3d16 <vTaskResume+0x70>
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
    3ce6:	90 93 b2 07 	sts	0x07B2, r25
    3cea:	89 e0       	ldi	r24, 0x09	; 9
    3cec:	98 9f       	mul	r25, r24
    3cee:	c0 01       	movw	r24, r0
    3cf0:	11 24       	eor	r1, r1
    3cf2:	87 54       	subi	r24, 0x47	; 71
    3cf4:	98 4f       	sbci	r25, 0xF8	; 248
    3cf6:	b8 01       	movw	r22, r16
    3cf8:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3cfc:	e0 91 ac 07 	lds	r30, 0x07AC
    3d00:	f0 91 ad 07 	lds	r31, 0x07AD
    3d04:	9e 89       	ldd	r25, Y+22	; 0x16
    3d06:	86 89       	ldd	r24, Z+22	; 0x16
    3d08:	98 17       	cp	r25, r24
    3d0a:	10 f0       	brcs	.+4      	; 0x3d10 <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    3d0c:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3d10:	0f 90       	pop	r0
    3d12:	0f be       	out	0x3f, r0	; 63
    3d14:	0c c0       	rjmp	.+24     	; 0x3d2e <vTaskResume+0x88>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    3d16:	8e 01       	movw	r16, r28
    3d18:	0e 5f       	subi	r16, 0xFE	; 254
    3d1a:	1f 4f       	sbci	r17, 0xFF	; 255
    3d1c:	c8 01       	movw	r24, r16
    3d1e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3d22:	9e 89       	ldd	r25, Y+22	; 0x16
    3d24:	80 91 b2 07 	lds	r24, 0x07B2
    3d28:	89 17       	cp	r24, r25
    3d2a:	e8 f2       	brcs	.-70     	; 0x3ce6 <vTaskResume+0x40>
    3d2c:	de cf       	rjmp	.-68     	; 0x3cea <vTaskResume+0x44>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3d2e:	df 91       	pop	r29
    3d30:	cf 91       	pop	r28
    3d32:	1f 91       	pop	r17
    3d34:	0f 91       	pop	r16
    3d36:	08 95       	ret

00003d38 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3d38:	0f 93       	push	r16
    3d3a:	1f 93       	push	r17
    3d3c:	cf 93       	push	r28
    3d3e:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3d40:	0f b6       	in	r0, 0x3f	; 63
    3d42:	f8 94       	cli
    3d44:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3d46:	00 97       	sbiw	r24, 0x00	; 0
    3d48:	29 f4       	brne	.+10     	; 0x3d54 <vTaskSuspend+0x1c>
    3d4a:	c0 91 ac 07 	lds	r28, 0x07AC
    3d4e:	d0 91 ad 07 	lds	r29, 0x07AD
    3d52:	01 c0       	rjmp	.+2      	; 0x3d56 <vTaskSuspend+0x1e>
    3d54:	ec 01       	movw	r28, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3d56:	8e 01       	movw	r16, r28
    3d58:	0e 5f       	subi	r16, 0xFE	; 254
    3d5a:	1f 4f       	sbci	r17, 0xFF	; 255
    3d5c:	c8 01       	movw	r24, r16
    3d5e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3d62:	8c 89       	ldd	r24, Y+20	; 0x14
    3d64:	9d 89       	ldd	r25, Y+21	; 0x15
    3d66:	89 2b       	or	r24, r25
    3d68:	21 f0       	breq	.+8      	; 0x3d72 <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3d6a:	ce 01       	movw	r24, r28
    3d6c:	0c 96       	adiw	r24, 0x0c	; 12
    3d6e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    3d72:	80 e2       	ldi	r24, 0x20	; 32
    3d74:	98 e0       	ldi	r25, 0x08	; 8
    3d76:	b8 01       	movw	r22, r16
    3d78:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    3d7c:	0f 90       	pop	r0
    3d7e:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    3d80:	80 91 ac 07 	lds	r24, 0x07AC
    3d84:	90 91 ad 07 	lds	r25, 0x07AD
    3d88:	c8 17       	cp	r28, r24
    3d8a:	d9 07       	cpc	r29, r25
    3d8c:	a9 f4       	brne	.+42     	; 0x3db8 <vTaskSuspend+0x80>
		{
			if( xSchedulerRunning != pdFALSE )
    3d8e:	80 91 b6 07 	lds	r24, 0x07B6
    3d92:	88 23       	and	r24, r24
    3d94:	19 f0       	breq	.+6      	; 0x3d9c <vTaskSuspend+0x64>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3d96:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    3d9a:	31 c0       	rjmp	.+98     	; 0x3dfe <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    3d9c:	90 91 b5 07 	lds	r25, 0x07B5
    3da0:	80 91 20 08 	lds	r24, 0x0820
    3da4:	89 17       	cp	r24, r25
    3da6:	29 f4       	brne	.+10     	; 0x3db2 <vTaskSuspend+0x7a>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3da8:	10 92 ad 07 	sts	0x07AD, r1
    3dac:	10 92 ac 07 	sts	0x07AC, r1
    3db0:	26 c0       	rjmp	.+76     	; 0x3dfe <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    3db2:	0e 94 12 1b 	call	0x3624	; 0x3624 <vTaskSwitchContext>
    3db6:	23 c0       	rjmp	.+70     	; 0x3dfe <vTaskSuspend+0xc6>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    3db8:	80 91 b6 07 	lds	r24, 0x07B6
    3dbc:	88 23       	and	r24, r24
    3dbe:	f9 f0       	breq	.+62     	; 0x3dfe <vTaskSuspend+0xc6>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    3dc0:	0f b6       	in	r0, 0x3f	; 63
    3dc2:	f8 94       	cli
    3dc4:	0f 92       	push	r0

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3dc6:	e0 91 0a 08 	lds	r30, 0x080A
    3dca:	f0 91 0b 08 	lds	r31, 0x080B
    3dce:	80 81       	ld	r24, Z
    3dd0:	88 23       	and	r24, r24
    3dd2:	19 f4       	brne	.+6      	; 0x3dda <vTaskSuspend+0xa2>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3dd4:	8f ef       	ldi	r24, 0xFF	; 255
    3dd6:	9f ef       	ldi	r25, 0xFF	; 255
    3dd8:	0c c0       	rjmp	.+24     	; 0x3df2 <vTaskSuspend+0xba>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3dda:	e0 91 0a 08 	lds	r30, 0x080A
    3dde:	f0 91 0b 08 	lds	r31, 0x080B
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    3de2:	05 80       	ldd	r0, Z+5	; 0x05
    3de4:	f6 81       	ldd	r31, Z+6	; 0x06
    3de6:	e0 2d       	mov	r30, r0
    3de8:	06 80       	ldd	r0, Z+6	; 0x06
    3dea:	f7 81       	ldd	r31, Z+7	; 0x07
    3dec:	e0 2d       	mov	r30, r0
    3dee:	82 81       	ldd	r24, Z+2	; 0x02
    3df0:	93 81       	ldd	r25, Z+3	; 0x03
    3df2:	90 93 de 01 	sts	0x01DE, r25
    3df6:	80 93 dd 01 	sts	0x01DD, r24
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
				{
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
    3dfa:	0f 90       	pop	r0
    3dfc:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3dfe:	df 91       	pop	r29
    3e00:	cf 91       	pop	r28
    3e02:	1f 91       	pop	r17
    3e04:	0f 91       	pop	r16
    3e06:	08 95       	ret

00003e08 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    3e08:	ef 92       	push	r14
    3e0a:	ff 92       	push	r15
    3e0c:	0f 93       	push	r16
    3e0e:	1f 93       	push	r17
    3e10:	df 93       	push	r29
    3e12:	cf 93       	push	r28
    3e14:	0f 92       	push	r0
    3e16:	cd b7       	in	r28, 0x3d	; 61
    3e18:	de b7       	in	r29, 0x3e	; 62
    3e1a:	67 30       	cpi	r22, 0x07	; 7
    3e1c:	08 f0       	brcs	.+2      	; 0x3e20 <vTaskPrioritySet+0x18>
    3e1e:	66 e0       	ldi	r22, 0x06	; 6
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    3e20:	0f b6       	in	r0, 0x3f	; 63
    3e22:	f8 94       	cli
    3e24:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3e26:	00 97       	sbiw	r24, 0x00	; 0
    3e28:	29 f4       	brne	.+10     	; 0x3e34 <vTaskPrioritySet+0x2c>
    3e2a:	e0 90 ac 07 	lds	r14, 0x07AC
    3e2e:	f0 90 ad 07 	lds	r15, 0x07AD
    3e32:	01 c0       	rjmp	.+2      	; 0x3e36 <vTaskPrioritySet+0x2e>
    3e34:	7c 01       	movw	r14, r24
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    3e36:	d7 01       	movw	r26, r14
    3e38:	56 96       	adiw	r26, 0x16	; 22
    3e3a:	2c 91       	ld	r18, X
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    3e3c:	26 17       	cp	r18, r22
    3e3e:	09 f4       	brne	.+2      	; 0x3e42 <vTaskPrioritySet+0x3a>
    3e40:	5b c0       	rjmp	.+182    	; 0x3ef8 <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    3e42:	26 17       	cp	r18, r22
    3e44:	a0 f4       	brcc	.+40     	; 0x3e6e <vTaskPrioritySet+0x66>
				{
					if( pxTCB != pxCurrentTCB )
    3e46:	80 91 ac 07 	lds	r24, 0x07AC
    3e4a:	90 91 ad 07 	lds	r25, 0x07AD
    3e4e:	e8 16       	cp	r14, r24
    3e50:	f9 06       	cpc	r15, r25
    3e52:	11 f4       	brne	.+4      	; 0x3e58 <vTaskPrioritySet+0x50>
    3e54:	19 82       	std	Y+1, r1	; 0x01
    3e56:	15 c0       	rjmp	.+42     	; 0x3e82 <vTaskPrioritySet+0x7a>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    3e58:	e0 91 ac 07 	lds	r30, 0x07AC
    3e5c:	f0 91 ad 07 	lds	r31, 0x07AD
    3e60:	19 82       	std	Y+1, r1	; 0x01
    3e62:	86 89       	ldd	r24, Z+22	; 0x16
    3e64:	68 17       	cp	r22, r24
    3e66:	68 f0       	brcs	.+26     	; 0x3e82 <vTaskPrioritySet+0x7a>
    3e68:	b1 e0       	ldi	r27, 0x01	; 1
    3e6a:	b9 83       	std	Y+1, r27	; 0x01
    3e6c:	0a c0       	rjmp	.+20     	; 0x3e82 <vTaskPrioritySet+0x7a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    3e6e:	80 91 ac 07 	lds	r24, 0x07AC
    3e72:	90 91 ad 07 	lds	r25, 0x07AD
    3e76:	19 82       	std	Y+1, r1	; 0x01
    3e78:	e8 16       	cp	r14, r24
    3e7a:	f9 06       	cpc	r15, r25
    3e7c:	11 f4       	brne	.+4      	; 0x3e82 <vTaskPrioritySet+0x7a>
    3e7e:	e1 e0       	ldi	r30, 0x01	; 1
    3e80:	e9 83       	std	Y+1, r30	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    3e82:	d7 01       	movw	r26, r14
    3e84:	56 96       	adiw	r26, 0x16	; 22
    3e86:	6c 93       	st	X, r22
    3e88:	56 97       	sbiw	r26, 0x16	; 22
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3e8a:	1c 96       	adiw	r26, 0x0c	; 12
    3e8c:	8d 91       	ld	r24, X+
    3e8e:	9c 91       	ld	r25, X
    3e90:	1d 97       	sbiw	r26, 0x0d	; 13
    3e92:	97 fd       	sbrc	r25, 7
    3e94:	08 c0       	rjmp	.+16     	; 0x3ea6 <vTaskPrioritySet+0x9e>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e96:	87 e0       	ldi	r24, 0x07	; 7
    3e98:	90 e0       	ldi	r25, 0x00	; 0
    3e9a:	86 1b       	sub	r24, r22
    3e9c:	91 09       	sbc	r25, r1
    3e9e:	1d 96       	adiw	r26, 0x0d	; 13
    3ea0:	9c 93       	st	X, r25
    3ea2:	8e 93       	st	-X, r24
    3ea4:	1c 97       	sbiw	r26, 0x0c	; 12

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3ea6:	89 e0       	ldi	r24, 0x09	; 9
    3ea8:	28 9f       	mul	r18, r24
    3eaa:	c0 01       	movw	r24, r0
    3eac:	11 24       	eor	r1, r1
    3eae:	87 54       	subi	r24, 0x47	; 71
    3eb0:	98 4f       	sbci	r25, 0xF8	; 248
    3eb2:	f7 01       	movw	r30, r14
    3eb4:	22 85       	ldd	r18, Z+10	; 0x0a
    3eb6:	33 85       	ldd	r19, Z+11	; 0x0b
    3eb8:	28 17       	cp	r18, r24
    3eba:	39 07       	cpc	r19, r25
    3ebc:	c1 f4       	brne	.+48     	; 0x3eee <vTaskPrioritySet+0xe6>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3ebe:	87 01       	movw	r16, r14
    3ec0:	0e 5f       	subi	r16, 0xFE	; 254
    3ec2:	1f 4f       	sbci	r17, 0xFF	; 255
    3ec4:	c8 01       	movw	r24, r16
    3ec6:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    3eca:	d7 01       	movw	r26, r14
    3ecc:	56 96       	adiw	r26, 0x16	; 22
    3ece:	9c 91       	ld	r25, X
    3ed0:	80 91 b2 07 	lds	r24, 0x07B2
    3ed4:	89 17       	cp	r24, r25
    3ed6:	10 f4       	brcc	.+4      	; 0x3edc <vTaskPrioritySet+0xd4>
    3ed8:	90 93 b2 07 	sts	0x07B2, r25
    3edc:	89 e0       	ldi	r24, 0x09	; 9
    3ede:	98 9f       	mul	r25, r24
    3ee0:	c0 01       	movw	r24, r0
    3ee2:	11 24       	eor	r1, r1
    3ee4:	87 54       	subi	r24, 0x47	; 71
    3ee6:	98 4f       	sbci	r25, 0xF8	; 248
    3ee8:	b8 01       	movw	r22, r16
    3eea:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    3eee:	b9 81       	ldd	r27, Y+1	; 0x01
    3ef0:	b1 30       	cpi	r27, 0x01	; 1
    3ef2:	11 f4       	brne	.+4      	; 0x3ef8 <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    3ef4:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    3ef8:	0f 90       	pop	r0
    3efa:	0f be       	out	0x3f, r0	; 63
	}
    3efc:	0f 90       	pop	r0
    3efe:	cf 91       	pop	r28
    3f00:	df 91       	pop	r29
    3f02:	1f 91       	pop	r17
    3f04:	0f 91       	pop	r16
    3f06:	ff 90       	pop	r15
    3f08:	ef 90       	pop	r14
    3f0a:	08 95       	ret

00003f0c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3f0c:	0f 93       	push	r16
    3f0e:	1f 93       	push	r17
    3f10:	cf 93       	push	r28
    3f12:	df 93       	push	r29
    3f14:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3f16:	00 97       	sbiw	r24, 0x00	; 0
    3f18:	c9 f0       	breq	.+50     	; 0x3f4c <vTaskDelay+0x40>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3f1a:	80 91 b3 07 	lds	r24, 0x07B3
    3f1e:	8f 5f       	subi	r24, 0xFF	; 255
    3f20:	80 93 b3 07 	sts	0x07B3, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3f24:	00 91 af 07 	lds	r16, 0x07AF
    3f28:	10 91 b0 07 	lds	r17, 0x07B0

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3f2c:	80 91 ac 07 	lds	r24, 0x07AC
    3f30:	90 91 ad 07 	lds	r25, 0x07AD
    3f34:	02 96       	adiw	r24, 0x02	; 2
    3f36:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3f3a:	ce 01       	movw	r24, r28
    3f3c:	80 0f       	add	r24, r16
    3f3e:	91 1f       	adc	r25, r17
    3f40:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3f44:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3f48:	88 23       	and	r24, r24
    3f4a:	11 f4       	brne	.+4      	; 0x3f50 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
    3f4c:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3f50:	df 91       	pop	r29
    3f52:	cf 91       	pop	r28
    3f54:	1f 91       	pop	r17
    3f56:	0f 91       	pop	r16
    3f58:	08 95       	ret

00003f5a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    3f5a:	cf 93       	push	r28
    3f5c:	df 93       	push	r29
    3f5e:	fc 01       	movw	r30, r24
    3f60:	eb 01       	movw	r28, r22
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3f62:	80 91 b3 07 	lds	r24, 0x07B3
    3f66:	8f 5f       	subi	r24, 0xFF	; 255
    3f68:	80 93 b3 07 	sts	0x07B3, r24

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3f6c:	20 91 af 07 	lds	r18, 0x07AF
    3f70:	30 91 b0 07 	lds	r19, 0x07B0

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3f74:	80 81       	ld	r24, Z
    3f76:	91 81       	ldd	r25, Z+1	; 0x01
    3f78:	c8 0f       	add	r28, r24
    3f7a:	d9 1f       	adc	r29, r25

			if( xConstTickCount < *pxPreviousWakeTime )
    3f7c:	28 17       	cp	r18, r24
    3f7e:	39 07       	cpc	r19, r25
    3f80:	28 f4       	brcc	.+10     	; 0x3f8c <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3f82:	c8 17       	cp	r28, r24
    3f84:	d9 07       	cpc	r29, r25
    3f86:	28 f0       	brcs	.+10     	; 0x3f92 <vTaskDelayUntil+0x38>
    3f88:	80 e0       	ldi	r24, 0x00	; 0
    3f8a:	08 c0       	rjmp	.+16     	; 0x3f9c <vTaskDelayUntil+0x42>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3f8c:	c8 17       	cp	r28, r24
    3f8e:	d9 07       	cpc	r29, r25
    3f90:	20 f0       	brcs	.+8      	; 0x3f9a <vTaskDelayUntil+0x40>
    3f92:	80 e0       	ldi	r24, 0x00	; 0
    3f94:	2c 17       	cp	r18, r28
    3f96:	3d 07       	cpc	r19, r29
    3f98:	08 f4       	brcc	.+2      	; 0x3f9c <vTaskDelayUntil+0x42>
    3f9a:	81 e0       	ldi	r24, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3f9c:	d1 83       	std	Z+1, r29	; 0x01
    3f9e:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    3fa0:	88 23       	and	r24, r24
    3fa2:	51 f0       	breq	.+20     	; 0x3fb8 <vTaskDelayUntil+0x5e>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3fa4:	80 91 ac 07 	lds	r24, 0x07AC
    3fa8:	90 91 ad 07 	lds	r25, 0x07AD
    3fac:	02 96       	adiw	r24, 0x02	; 2
    3fae:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3fb2:	ce 01       	movw	r24, r28
    3fb4:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3fb8:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3fbc:	88 23       	and	r24, r24
    3fbe:	11 f4       	brne	.+4      	; 0x3fc4 <vTaskDelayUntil+0x6a>
		{
			portYIELD_WITHIN_API();
    3fc0:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3fc4:	df 91       	pop	r29
    3fc6:	cf 91       	pop	r28
    3fc8:	08 95       	ret

00003fca <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3fca:	0f 93       	push	r16
    3fcc:	1f 93       	push	r17
    3fce:	cf 93       	push	r28
    3fd0:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3fd2:	0f b6       	in	r0, 0x3f	; 63
    3fd4:	f8 94       	cli
    3fd6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3fd8:	00 97       	sbiw	r24, 0x00	; 0
    3fda:	29 f4       	brne	.+10     	; 0x3fe6 <vTaskDelete+0x1c>
    3fdc:	c0 91 ac 07 	lds	r28, 0x07AC
    3fe0:	d0 91 ad 07 	lds	r29, 0x07AD
    3fe4:	01 c0       	rjmp	.+2      	; 0x3fe8 <vTaskDelete+0x1e>
    3fe6:	ec 01       	movw	r28, r24

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3fe8:	8e 01       	movw	r16, r28
    3fea:	0e 5f       	subi	r16, 0xFE	; 254
    3fec:	1f 4f       	sbci	r17, 0xFF	; 255
    3fee:	c8 01       	movw	r24, r16
    3ff0:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3ff4:	8c 89       	ldd	r24, Y+20	; 0x14
    3ff6:	9d 89       	ldd	r25, Y+21	; 0x15
    3ff8:	89 2b       	or	r24, r25
    3ffa:	21 f0       	breq	.+8      	; 0x4004 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3ffc:	ce 01       	movw	r24, r28
    3ffe:	0c 96       	adiw	r24, 0x0c	; 12
    4000:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4004:	87 e1       	ldi	r24, 0x17	; 23
    4006:	98 e0       	ldi	r25, 0x08	; 8
    4008:	b8 01       	movw	r22, r16
    400a:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    400e:	80 91 b7 07 	lds	r24, 0x07B7
    4012:	8f 5f       	subi	r24, 0xFF	; 255
    4014:	80 93 b7 07 	sts	0x07B7, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4018:	80 91 b8 07 	lds	r24, 0x07B8
    401c:	8f 5f       	subi	r24, 0xFF	; 255
    401e:	80 93 b8 07 	sts	0x07B8, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4022:	0f 90       	pop	r0
    4024:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4026:	80 91 b6 07 	lds	r24, 0x07B6
    402a:	88 23       	and	r24, r24
    402c:	49 f1       	breq	.+82     	; 0x4080 <vTaskDelete+0xb6>
		{
			if( pxTCB == pxCurrentTCB )
    402e:	80 91 ac 07 	lds	r24, 0x07AC
    4032:	90 91 ad 07 	lds	r25, 0x07AD
    4036:	c8 17       	cp	r28, r24
    4038:	d9 07       	cpc	r29, r25
    403a:	19 f4       	brne	.+6      	; 0x4042 <vTaskDelete+0x78>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    403c:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    4040:	1f c0       	rjmp	.+62     	; 0x4080 <vTaskDelete+0xb6>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    4042:	0f b6       	in	r0, 0x3f	; 63
    4044:	f8 94       	cli
    4046:	0f 92       	push	r0

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4048:	e0 91 0a 08 	lds	r30, 0x080A
    404c:	f0 91 0b 08 	lds	r31, 0x080B
    4050:	80 81       	ld	r24, Z
    4052:	88 23       	and	r24, r24
    4054:	19 f4       	brne	.+6      	; 0x405c <vTaskDelete+0x92>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4056:	8f ef       	ldi	r24, 0xFF	; 255
    4058:	9f ef       	ldi	r25, 0xFF	; 255
    405a:	0c c0       	rjmp	.+24     	; 0x4074 <vTaskDelete+0xaa>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    405c:	e0 91 0a 08 	lds	r30, 0x080A
    4060:	f0 91 0b 08 	lds	r31, 0x080B
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    4064:	05 80       	ldd	r0, Z+5	; 0x05
    4066:	f6 81       	ldd	r31, Z+6	; 0x06
    4068:	e0 2d       	mov	r30, r0
    406a:	06 80       	ldd	r0, Z+6	; 0x06
    406c:	f7 81       	ldd	r31, Z+7	; 0x07
    406e:	e0 2d       	mov	r30, r0
    4070:	82 81       	ldd	r24, Z+2	; 0x02
    4072:	93 81       	ldd	r25, Z+3	; 0x03
    4074:	90 93 de 01 	sts	0x01DE, r25
    4078:	80 93 dd 01 	sts	0x01DD, r24
				the task that has just been deleted. */
				taskENTER_CRITICAL();
				{
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
    407c:	0f 90       	pop	r0
    407e:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    4080:	df 91       	pop	r29
    4082:	cf 91       	pop	r28
    4084:	1f 91       	pop	r17
    4086:	0f 91       	pop	r16
    4088:	08 95       	ret

0000408a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    408a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    408c:	10 92 b6 07 	sts	0x07B6, r1
	vPortEndScheduler();
    4090:	0e 94 39 16 	call	0x2c72	; 0x2c72 <vPortEndScheduler>
}
    4094:	08 95       	ret

00004096 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4096:	0f 93       	push	r16
    4098:	1f 93       	push	r17
    409a:	2c c0       	rjmp	.+88     	; 0x40f4 <prvIdleTask+0x5e>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    409c:	80 91 b3 07 	lds	r24, 0x07B3
    40a0:	8f 5f       	subi	r24, 0xFF	; 255
    40a2:	80 93 b3 07 	sts	0x07B3, r24
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    40a6:	10 91 17 08 	lds	r17, 0x0817
			}
			( void ) xTaskResumeAll();
    40aa:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    40ae:	11 23       	and	r17, r17
    40b0:	09 f1       	breq	.+66     	; 0x40f4 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    40b2:	0f b6       	in	r0, 0x3f	; 63
    40b4:	f8 94       	cli
    40b6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    40b8:	e0 91 1c 08 	lds	r30, 0x081C
    40bc:	f0 91 1d 08 	lds	r31, 0x081D
    40c0:	06 81       	ldd	r16, Z+6	; 0x06
    40c2:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    40c4:	c8 01       	movw	r24, r16
    40c6:	02 96       	adiw	r24, 0x02	; 2
    40c8:	0e 94 92 15 	call	0x2b24	; 0x2b24 <uxListRemove>
					--uxCurrentNumberOfTasks;
    40cc:	80 91 b5 07 	lds	r24, 0x07B5
    40d0:	81 50       	subi	r24, 0x01	; 1
    40d2:	80 93 b5 07 	sts	0x07B5, r24
					--uxTasksDeleted;
    40d6:	80 91 b7 07 	lds	r24, 0x07B7
    40da:	81 50       	subi	r24, 0x01	; 1
    40dc:	80 93 b7 07 	sts	0x07B7, r24
				}
				taskEXIT_CRITICAL();
    40e0:	0f 90       	pop	r0
    40e2:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    40e4:	f8 01       	movw	r30, r16
    40e6:	87 89       	ldd	r24, Z+23	; 0x17
    40e8:	90 8d       	ldd	r25, Z+24	; 0x18
    40ea:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortFree>
		vPortFree( pxTCB );
    40ee:	c8 01       	movw	r24, r16
    40f0:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    40f4:	80 91 b7 07 	lds	r24, 0x07B7
    40f8:	88 23       	and	r24, r24
    40fa:	81 f6       	brne	.-96     	; 0x409c <prvIdleTask+0x6>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    40fc:	80 91 b9 07 	lds	r24, 0x07B9
    4100:	82 30       	cpi	r24, 0x02	; 2
    4102:	c0 f3       	brcs	.-16     	; 0x40f4 <prvIdleTask+0x5e>
			{
				taskYIELD();
    4104:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    4108:	f5 cf       	rjmp	.-22     	; 0x40f4 <prvIdleTask+0x5e>

0000410a <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    410a:	2f 92       	push	r2
    410c:	3f 92       	push	r3
    410e:	4f 92       	push	r4
    4110:	5f 92       	push	r5
    4112:	7f 92       	push	r7
    4114:	8f 92       	push	r8
    4116:	9f 92       	push	r9
    4118:	af 92       	push	r10
    411a:	bf 92       	push	r11
    411c:	cf 92       	push	r12
    411e:	df 92       	push	r13
    4120:	ef 92       	push	r14
    4122:	ff 92       	push	r15
    4124:	0f 93       	push	r16
    4126:	1f 93       	push	r17
    4128:	cf 93       	push	r28
    412a:	df 93       	push	r29
    412c:	1c 01       	movw	r2, r24
    412e:	96 2e       	mov	r9, r22
    4130:	87 2e       	mov	r8, r23
    4132:	5a 01       	movw	r10, r20
    4134:	29 01       	movw	r4, r18
    4136:	70 2e       	mov	r7, r16
    4138:	e6 01       	movw	r28, r12
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    413a:	8d e2       	ldi	r24, 0x2D	; 45
    413c:	90 e0       	ldi	r25, 0x00	; 0
    413e:	0e 94 74 14 	call	0x28e8	; 0x28e8 <pvPortMalloc>
    4142:	6c 01       	movw	r12, r24

	if( pxNewTCB != NULL )
    4144:	00 97       	sbiw	r24, 0x00	; 0
    4146:	79 f0       	breq	.+30     	; 0x4166 <xTaskGenericCreate+0x5c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4148:	20 97       	sbiw	r28, 0x00	; 0
    414a:	21 f4       	brne	.+8      	; 0x4154 <xTaskGenericCreate+0x4a>
    414c:	c5 01       	movw	r24, r10
    414e:	0e 94 74 14 	call	0x28e8	; 0x28e8 <pvPortMalloc>
    4152:	ec 01       	movw	r28, r24
    4154:	f6 01       	movw	r30, r12
    4156:	d0 8f       	std	Z+24, r29	; 0x18
    4158:	c7 8b       	std	Z+23, r28	; 0x17

		if( pxNewTCB->pxStack == NULL )
    415a:	20 97       	sbiw	r28, 0x00	; 0
    415c:	09 f0       	breq	.+2      	; 0x4160 <xTaskGenericCreate+0x56>
    415e:	cc c0       	rjmp	.+408    	; 0x42f8 <xTaskGenericCreate+0x1ee>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4160:	c6 01       	movw	r24, r12
    4162:	0e 94 64 14 	call	0x28c8	; 0x28c8 <vPortFree>
    4166:	8f ef       	ldi	r24, 0xFF	; 255
    4168:	b5 c0       	rjmp	.+362    	; 0x42d4 <xTaskGenericCreate+0x1ca>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    416a:	80 81       	ld	r24, Z
    416c:	59 96       	adiw	r26, 0x19	; 25
    416e:	8c 93       	st	X, r24
    4170:	59 97       	sbiw	r26, 0x19	; 25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    4172:	80 81       	ld	r24, Z
    4174:	88 23       	and	r24, r24
    4176:	29 f0       	breq	.+10     	; 0x4182 <xTaskGenericCreate+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4178:	9f 5f       	subi	r25, 0xFF	; 255
    417a:	31 96       	adiw	r30, 0x01	; 1
    417c:	11 96       	adiw	r26, 0x01	; 1
    417e:	94 31       	cpi	r25, 0x14	; 20
    4180:	a1 f7       	brne	.-24     	; 0x416a <xTaskGenericCreate+0x60>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4182:	f6 01       	movw	r30, r12
    4184:	14 a6       	std	Z+44, r1	; 0x2c
    4186:	07 2d       	mov	r16, r7
    4188:	f6 e0       	ldi	r31, 0x06	; 6
    418a:	f7 15       	cp	r31, r7
    418c:	08 f4       	brcc	.+2      	; 0x4190 <xTaskGenericCreate+0x86>
    418e:	06 e0       	ldi	r16, 0x06	; 6
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    4190:	f6 01       	movw	r30, r12
    4192:	06 8b       	std	Z+22, r16	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4194:	e2 e0       	ldi	r30, 0x02	; 2
    4196:	8e 2e       	mov	r8, r30
    4198:	91 2c       	mov	r9, r1
    419a:	8c 0c       	add	r8, r12
    419c:	9d 1c       	adc	r9, r13
    419e:	c4 01       	movw	r24, r8
    41a0:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    41a4:	c6 01       	movw	r24, r12
    41a6:	0c 96       	adiw	r24, 0x0c	; 12
    41a8:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    41ac:	f6 01       	movw	r30, r12
    41ae:	d1 86       	std	Z+9, r13	; 0x09
    41b0:	c0 86       	std	Z+8, r12	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    41b2:	87 e0       	ldi	r24, 0x07	; 7
    41b4:	90 e0       	ldi	r25, 0x00	; 0
    41b6:	80 1b       	sub	r24, r16
    41b8:	91 09       	sbc	r25, r1
    41ba:	95 87       	std	Z+13, r25	; 0x0d
    41bc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    41be:	d3 8a       	std	Z+19, r13	; 0x13
    41c0:	c2 8a       	std	Z+18, r12	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    41c2:	08 94       	sec
    41c4:	a1 08       	sbc	r10, r1
    41c6:	b1 08       	sbc	r11, r1
    41c8:	ce 01       	movw	r24, r28
    41ca:	8a 0d       	add	r24, r10
    41cc:	9b 1d       	adc	r25, r11
    41ce:	b1 01       	movw	r22, r2
    41d0:	a2 01       	movw	r20, r4
    41d2:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <pxPortInitialiseStack>
    41d6:	f6 01       	movw	r30, r12
    41d8:	91 83       	std	Z+1, r25	; 0x01
    41da:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    41dc:	e1 14       	cp	r14, r1
    41de:	f1 04       	cpc	r15, r1
    41e0:	19 f0       	breq	.+6      	; 0x41e8 <xTaskGenericCreate+0xde>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    41e2:	f7 01       	movw	r30, r14
    41e4:	d1 82       	std	Z+1, r13	; 0x01
    41e6:	c0 82       	st	Z, r12
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    41e8:	0f b6       	in	r0, 0x3f	; 63
    41ea:	f8 94       	cli
    41ec:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    41ee:	80 91 b5 07 	lds	r24, 0x07B5
    41f2:	8f 5f       	subi	r24, 0xFF	; 255
    41f4:	80 93 b5 07 	sts	0x07B5, r24
			if( pxCurrentTCB == NULL )
    41f8:	80 91 ac 07 	lds	r24, 0x07AC
    41fc:	90 91 ad 07 	lds	r25, 0x07AD
    4200:	89 2b       	or	r24, r25
    4202:	99 f5       	brne	.+102    	; 0x426a <xTaskGenericCreate+0x160>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4204:	d0 92 ad 07 	sts	0x07AD, r13
    4208:	c0 92 ac 07 	sts	0x07AC, r12

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    420c:	80 91 b5 07 	lds	r24, 0x07B5
    4210:	81 30       	cpi	r24, 0x01	; 1
    4212:	d1 f5       	brne	.+116    	; 0x4288 <xTaskGenericCreate+0x17e>
    4214:	c9 eb       	ldi	r28, 0xB9	; 185
    4216:	d7 e0       	ldi	r29, 0x07	; 7
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4218:	ce 01       	movw	r24, r28
    421a:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
    421e:	29 96       	adiw	r28, 0x09	; 9

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4220:	f7 e0       	ldi	r31, 0x07	; 7
    4222:	c8 3f       	cpi	r28, 0xF8	; 248
    4224:	df 07       	cpc	r29, r31
    4226:	c1 f7       	brne	.-16     	; 0x4218 <xTaskGenericCreate+0x10e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4228:	78 ef       	ldi	r23, 0xF8	; 248
    422a:	e7 2e       	mov	r14, r23
    422c:	77 e0       	ldi	r23, 0x07	; 7
    422e:	f7 2e       	mov	r15, r23
    4230:	c7 01       	movw	r24, r14
    4232:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4236:	01 e0       	ldi	r16, 0x01	; 1
    4238:	18 e0       	ldi	r17, 0x08	; 8
    423a:	c8 01       	movw	r24, r16
    423c:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4240:	8e e0       	ldi	r24, 0x0E	; 14
    4242:	98 e0       	ldi	r25, 0x08	; 8
    4244:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4248:	87 e1       	ldi	r24, 0x17	; 23
    424a:	98 e0       	ldi	r25, 0x08	; 8
    424c:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4250:	80 e2       	ldi	r24, 0x20	; 32
    4252:	98 e0       	ldi	r25, 0x08	; 8
    4254:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4258:	f0 92 0b 08 	sts	0x080B, r15
    425c:	e0 92 0a 08 	sts	0x080A, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4260:	10 93 0d 08 	sts	0x080D, r17
    4264:	00 93 0c 08 	sts	0x080C, r16
    4268:	0f c0       	rjmp	.+30     	; 0x4288 <xTaskGenericCreate+0x17e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    426a:	80 91 b6 07 	lds	r24, 0x07B6
    426e:	88 23       	and	r24, r24
    4270:	59 f4       	brne	.+22     	; 0x4288 <xTaskGenericCreate+0x17e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4272:	e0 91 ac 07 	lds	r30, 0x07AC
    4276:	f0 91 ad 07 	lds	r31, 0x07AD
    427a:	86 89       	ldd	r24, Z+22	; 0x16
    427c:	78 16       	cp	r7, r24
    427e:	20 f0       	brcs	.+8      	; 0x4288 <xTaskGenericCreate+0x17e>
					{
						pxCurrentTCB = pxNewTCB;
    4280:	d0 92 ad 07 	sts	0x07AD, r13
    4284:	c0 92 ac 07 	sts	0x07AC, r12
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    4288:	80 91 b8 07 	lds	r24, 0x07B8
    428c:	8f 5f       	subi	r24, 0xFF	; 255
    428e:	80 93 b8 07 	sts	0x07B8, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    4292:	f6 01       	movw	r30, r12
    4294:	96 89       	ldd	r25, Z+22	; 0x16
    4296:	80 91 b2 07 	lds	r24, 0x07B2
    429a:	89 17       	cp	r24, r25
    429c:	10 f4       	brcc	.+4      	; 0x42a2 <xTaskGenericCreate+0x198>
    429e:	90 93 b2 07 	sts	0x07B2, r25
    42a2:	89 e0       	ldi	r24, 0x09	; 9
    42a4:	98 9f       	mul	r25, r24
    42a6:	c0 01       	movw	r24, r0
    42a8:	11 24       	eor	r1, r1
    42aa:	87 54       	subi	r24, 0x47	; 71
    42ac:	98 4f       	sbci	r25, 0xF8	; 248
    42ae:	b4 01       	movw	r22, r8
    42b0:	0e 94 41 15 	call	0x2a82	; 0x2a82 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    42b4:	0f 90       	pop	r0
    42b6:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    42b8:	80 91 b6 07 	lds	r24, 0x07B6
    42bc:	88 23       	and	r24, r24
    42be:	49 f0       	breq	.+18     	; 0x42d2 <xTaskGenericCreate+0x1c8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    42c0:	e0 91 ac 07 	lds	r30, 0x07AC
    42c4:	f0 91 ad 07 	lds	r31, 0x07AD
    42c8:	86 89       	ldd	r24, Z+22	; 0x16
    42ca:	87 15       	cp	r24, r7
    42cc:	10 f4       	brcc	.+4      	; 0x42d2 <xTaskGenericCreate+0x1c8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    42ce:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <vPortYield>
    42d2:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    42d4:	df 91       	pop	r29
    42d6:	cf 91       	pop	r28
    42d8:	1f 91       	pop	r17
    42da:	0f 91       	pop	r16
    42dc:	ff 90       	pop	r15
    42de:	ef 90       	pop	r14
    42e0:	df 90       	pop	r13
    42e2:	cf 90       	pop	r12
    42e4:	bf 90       	pop	r11
    42e6:	af 90       	pop	r10
    42e8:	9f 90       	pop	r9
    42ea:	8f 90       	pop	r8
    42ec:	7f 90       	pop	r7
    42ee:	5f 90       	pop	r5
    42f0:	4f 90       	pop	r4
    42f2:	3f 90       	pop	r3
    42f4:	2f 90       	pop	r2
    42f6:	08 95       	ret
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				taskYIELD_IF_USING_PREEMPTION();
    42f8:	89 2d       	mov	r24, r9
    42fa:	98 2d       	mov	r25, r8
    42fc:	9c 01       	movw	r18, r24
    42fe:	f9 01       	movw	r30, r18
    4300:	d6 01       	movw	r26, r12
    4302:	90 e0       	ldi	r25, 0x00	; 0
    4304:	32 cf       	rjmp	.-412    	; 0x416a <xTaskGenericCreate+0x60>

00004306 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4306:	af 92       	push	r10
    4308:	bf 92       	push	r11
    430a:	cf 92       	push	r12
    430c:	df 92       	push	r13
    430e:	ef 92       	push	r14
    4310:	ff 92       	push	r15
    4312:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    4314:	8b e4       	ldi	r24, 0x4B	; 75
    4316:	90 e2       	ldi	r25, 0x20	; 32
    4318:	68 e7       	ldi	r22, 0x78	; 120
    431a:	70 e0       	ldi	r23, 0x00	; 0
    431c:	45 e5       	ldi	r20, 0x55	; 85
    431e:	50 e0       	ldi	r21, 0x00	; 0
    4320:	20 e0       	ldi	r18, 0x00	; 0
    4322:	30 e0       	ldi	r19, 0x00	; 0
    4324:	00 e0       	ldi	r16, 0x00	; 0
    4326:	ee 24       	eor	r14, r14
    4328:	ff 24       	eor	r15, r15
    432a:	cc 24       	eor	r12, r12
    432c:	dd 24       	eor	r13, r13
    432e:	aa 24       	eor	r10, r10
    4330:	bb 24       	eor	r11, r11
    4332:	0e 94 85 20 	call	0x410a	; 0x410a <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4336:	81 30       	cpi	r24, 0x01	; 1
    4338:	49 f4       	brne	.+18     	; 0x434c <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    433a:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    433c:	80 93 b6 07 	sts	0x07B6, r24
		xTickCount = ( TickType_t ) 0U;
    4340:	10 92 b0 07 	sts	0x07B0, r1
    4344:	10 92 af 07 	sts	0x07AF, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4348:	0e 94 04 16 	call	0x2c08	; 0x2c08 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    434c:	0f 91       	pop	r16
    434e:	ff 90       	pop	r15
    4350:	ef 90       	pop	r14
    4352:	df 90       	pop	r13
    4354:	cf 90       	pop	r12
    4356:	bf 90       	pop	r11
    4358:	af 90       	pop	r10
    435a:	08 95       	ret

0000435c <T_Door>:

}

void T_Door(void*p)
{
	usart_puts("Door\r\n");
    435c:	8d e7       	ldi	r24, 0x7D	; 125
    435e:	90 e0       	ldi	r25, 0x00	; 0
    4360:	0e 94 56 22 	call	0x44ac	; 0x44ac <usart_puts>
	DDRB=0;
    4364:	17 ba       	out	0x17, r1	; 23
	while(1)
	{
		if(SwitchStatus(&START)==STD_HIGH)
    4366:	87 ee       	ldi	r24, 0xE7	; 231
    4368:	91 e0       	ldi	r25, 0x01	; 1
    436a:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <SwitchStatus>
    436e:	81 30       	cpi	r24, 0x01	; 1
    4370:	d1 f7       	brne	.-12     	; 0x4366 <T_Door+0xa>
		{
			usart_puts("Door Closed\r\n");
    4372:	84 e8       	ldi	r24, 0x84	; 132
    4374:	90 e0       	ldi	r25, 0x00	; 0
    4376:	0e 94 56 22 	call	0x44ac	; 0x44ac <usart_puts>
			Bits=xEventGroupSetBits(Events,EventDoor);
    437a:	80 91 2d 08 	lds	r24, 0x082D
    437e:	90 91 2e 08 	lds	r25, 0x082E
    4382:	61 e0       	ldi	r22, 0x01	; 1
    4384:	70 e0       	ldi	r23, 0x00	; 0
    4386:	0e 94 02 13 	call	0x2604	; 0x2604 <xEventGroupSetBits>
    438a:	90 93 30 08 	sts	0x0830, r25
    438e:	80 93 2f 08 	sts	0x082F, r24
			usart_puts("Door Closed\r\n");
    4392:	84 e8       	ldi	r24, 0x84	; 132
    4394:	90 e0       	ldi	r25, 0x00	; 0
    4396:	0e 94 56 22 	call	0x44ac	; 0x44ac <usart_puts>
    439a:	e5 cf       	rjmp	.-54     	; 0x4366 <T_Door+0xa>

0000439c <T_KeypadEnterTime>:
	}*/

}

void T_KeypadEnterTime(void*p)
{
    439c:	1f 93       	push	r17
	u8 time;
	usart_puts("KeyPad\r\n");
    439e:	82 e9       	ldi	r24, 0x92	; 146
    43a0:	90 e0       	ldi	r25, 0x00	; 0
    43a2:	0e 94 56 22 	call	0x44ac	; 0x44ac <usart_puts>
	LCD_WriteString("Enter Time");
    43a6:	8b e9       	ldi	r24, 0x9B	; 155
    43a8:	90 e0       	ldi	r25, 0x00	; 0
    43aa:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <LCD_WriteString>
	Gpt_StartTimer(Timer0_,time);
    43ae:	80 e0       	ldi	r24, 0x00	; 0
    43b0:	40 e0       	ldi	r20, 0x00	; 0
    43b2:	50 e0       	ldi	r21, 0x00	; 0
    43b4:	60 e0       	ldi	r22, 0x00	; 0
    43b6:	70 e0       	ldi	r23, 0x00	; 0
    43b8:	0e 94 cf 07 	call	0xf9e	; 0xf9e <Gpt_StartTimer>
	while(1)
	{
		time=GetKeyState ();
    43bc:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <GetKeyState>
    43c0:	18 2f       	mov	r17, r24

		if(time!=KeyNotPressed)
    43c2:	8f 3f       	cpi	r24, 0xFF	; 255
    43c4:	d9 f3       	breq	.-10     	; 0x43bc <T_KeypadEnterTime+0x20>
		{
				LCD_WriteData(time);
    43c6:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <LCD_WriteData>
		}
		if(time=='=')
    43ca:	1d 33       	cpi	r17, 0x3D	; 61
    43cc:	b9 f7       	brne	.-18     	; 0x43bc <T_KeypadEnterTime+0x20>
		{
			LCD_CursorMove(2,0);
    43ce:	82 e0       	ldi	r24, 0x02	; 2
    43d0:	60 e0       	ldi	r22, 0x00	; 0
    43d2:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <LCD_CursorMove>
			LCD_WriteString("Time Entered");
    43d6:	86 ea       	ldi	r24, 0xA6	; 166
    43d8:	90 e0       	ldi	r25, 0x00	; 0
    43da:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <LCD_WriteString>
    43de:	ee cf       	rjmp	.-36     	; 0x43bc <T_KeypadEnterTime+0x20>

000043e0 <system_init>:

	return 0;
}
void system_init(void)
{
	Dio_Init();
    43e0:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <Dio_Init>
	LCD_init();
    43e4:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <LCD_init>
	Gpt_Init(&Timer);
    43e8:	8f ee       	ldi	r24, 0xEF	; 239
    43ea:	91 e0       	ldi	r25, 0x01	; 1
    43ec:	0e 94 2e 09 	call	0x125c	; 0x125c <Gpt_Init>
	usart_init(9600);
    43f0:	80 e8       	ldi	r24, 0x80	; 128
    43f2:	95 e2       	ldi	r25, 0x25	; 37
    43f4:	0e 94 35 22 	call	0x446a	; 0x446a <usart_init>
	usart_puts("Started\r\n");
    43f8:	83 eb       	ldi	r24, 0xB3	; 179
    43fa:	90 e0       	ldi	r25, 0x00	; 0
    43fc:	0e 94 56 22 	call	0x44ac	; 0x44ac <usart_puts>
			{
					LCD_WriteData(staus);
			}
	}*/

}
    4400:	08 95       	ret

00004402 <main>:

#define EventDoor                  1<<0


int main (void)
{
    4402:	af 92       	push	r10
    4404:	bf 92       	push	r11
    4406:	cf 92       	push	r12
    4408:	df 92       	push	r13
    440a:	ef 92       	push	r14
    440c:	ff 92       	push	r15
    440e:	0f 93       	push	r16
	//init priphral
	system_init();          //init program
    4410:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <system_init>

	//Creat Event
	Events=xEventGroupCreate();
    4414:	0e 94 51 14 	call	0x28a2	; 0x28a2 <xEventGroupCreate>
    4418:	90 93 2e 08 	sts	0x082E, r25
    441c:	80 93 2d 08 	sts	0x082D, r24

	//Creat tasks
	xTaskCreate(T_KeypadEnterTime,NULL,100,NULL,1,&KeypadEnterTime);
    4420:	8e ec       	ldi	r24, 0xCE	; 206
    4422:	91 e2       	ldi	r25, 0x21	; 33
    4424:	60 e0       	ldi	r22, 0x00	; 0
    4426:	70 e0       	ldi	r23, 0x00	; 0
    4428:	44 e6       	ldi	r20, 0x64	; 100
    442a:	50 e0       	ldi	r21, 0x00	; 0
    442c:	20 e0       	ldi	r18, 0x00	; 0
    442e:	30 e0       	ldi	r19, 0x00	; 0
    4430:	01 e0       	ldi	r16, 0x01	; 1
    4432:	f9 e2       	ldi	r31, 0x29	; 41
    4434:	ef 2e       	mov	r14, r31
    4436:	f8 e0       	ldi	r31, 0x08	; 8
    4438:	ff 2e       	mov	r15, r31
    443a:	cc 24       	eor	r12, r12
    443c:	dd 24       	eor	r13, r13
    443e:	aa 24       	eor	r10, r10
    4440:	bb 24       	eor	r11, r11
    4442:	0e 94 85 20 	call	0x410a	; 0x410a <xTaskGenericCreate>
	xTaskCreate(T_Door,NULL,100,NULL,2,&DoorTask);
    4446:	8e ea       	ldi	r24, 0xAE	; 174
    4448:	91 e2       	ldi	r25, 0x21	; 33
    444a:	60 e0       	ldi	r22, 0x00	; 0
    444c:	70 e0       	ldi	r23, 0x00	; 0
    444e:	44 e6       	ldi	r20, 0x64	; 100
    4450:	50 e0       	ldi	r21, 0x00	; 0
    4452:	20 e0       	ldi	r18, 0x00	; 0
    4454:	30 e0       	ldi	r19, 0x00	; 0
    4456:	02 e0       	ldi	r16, 0x02	; 2
    4458:	eb e2       	ldi	r30, 0x2B	; 43
    445a:	ee 2e       	mov	r14, r30
    445c:	e8 e0       	ldi	r30, 0x08	; 8
    445e:	fe 2e       	mov	r15, r30
    4460:	0e 94 85 20 	call	0x410a	; 0x410a <xTaskGenericCreate>

	//start RTOS
	vTaskStartScheduler();
    4464:	0e 94 83 21 	call	0x4306	; 0x4306 <vTaskStartScheduler>
    4468:	ff cf       	rjmp	.-2      	; 0x4468 <main+0x66>

0000446a <usart_init>:
#include "usart_driver.h"

void usart_init(unsigned short int baudrate)
{
	//Set baud rate
	unsigned short int UBRRVAL=(FCLK_SYSTEM/(baudrate*16UL))-1;
    446a:	9c 01       	movw	r18, r24
    446c:	40 e0       	ldi	r20, 0x00	; 0
    446e:	50 e0       	ldi	r21, 0x00	; 0
    4470:	84 e0       	ldi	r24, 0x04	; 4
    4472:	22 0f       	add	r18, r18
    4474:	33 1f       	adc	r19, r19
    4476:	44 1f       	adc	r20, r20
    4478:	55 1f       	adc	r21, r21
    447a:	8a 95       	dec	r24
    447c:	d1 f7       	brne	.-12     	; 0x4472 <usart_init+0x8>
    447e:	60 e0       	ldi	r22, 0x00	; 0
    4480:	72 e1       	ldi	r23, 0x12	; 18
    4482:	8a e7       	ldi	r24, 0x7A	; 122
    4484:	90 e0       	ldi	r25, 0x00	; 0
    4486:	0e 94 a6 22 	call	0x454c	; 0x454c <__udivmodsi4>
    448a:	21 50       	subi	r18, 0x01	; 1
    448c:	30 40       	sbci	r19, 0x00	; 0
	UBRRL=UBRRVAL; 			//low byte
    448e:	29 b9       	out	0x09, r18	; 9
	UBRRH=(UBRRVAL>>8); 	//high byte
    4490:	30 bd       	out	0x20, r19	; 32

	//Set data frame format: asynchronous mode,no parity, 1 stop bit, 8 bit size
	UCSRC=(1<<URSEL)|(0<<UMSEL)|(0<<UPM1)|(0<<UPM0)|(0<<USBS)|(0<<UCSZ2)|(1<<UCSZ1)|(1<<UCSZ0); 
    4492:	86 e8       	ldi	r24, 0x86	; 134
    4494:	80 bd       	out	0x20, r24	; 32

	//Enable Transmitter and Receiver
	UCSRB=(1<<RXEN)|(1<<TXEN);
    4496:	88 e1       	ldi	r24, 0x18	; 24
    4498:	8a b9       	out	0x0a, r24	; 10
}
    449a:	08 95       	ret

0000449c <usart_getc>:
unsigned char usart_getc( void )
{
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
    449c:	5f 9b       	sbis	0x0b, 7	; 11
    449e:	fe cf       	rjmp	.-4      	; 0x449c <usart_getc>
	/* Get and return received data from buffer */
	return UDR;
    44a0:	8c b1       	in	r24, 0x0c	; 12
}
    44a2:	08 95       	ret

000044a4 <usart_putc>:
void usart_putc( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
    44a4:	5d 9b       	sbis	0x0b, 5	; 11
    44a6:	fe cf       	rjmp	.-4      	; 0x44a4 <usart_putc>
	/* Put data into buffer, sends the data */
	UDR = data;
    44a8:	8c b9       	out	0x0c, r24	; 12
}
    44aa:	08 95       	ret

000044ac <usart_puts>:
void usart_puts( char* str )
{
    44ac:	fc 01       	movw	r30, r24
    44ae:	04 c0       	rjmp	.+8      	; 0x44b8 <usart_puts+0xc>
	return UDR;
}
void usart_putc( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
    44b0:	5d 9b       	sbis	0x0b, 5	; 11
    44b2:	fe cf       	rjmp	.-4      	; 0x44b0 <usart_puts+0x4>
	/* Put data into buffer, sends the data */
	UDR = data;
    44b4:	8c b9       	out	0x0c, r24	; 12
    44b6:	31 96       	adiw	r30, 0x01	; 1
}
void usart_puts( char* str )
{
	short int i=0;
	while(str[i])
    44b8:	80 81       	ld	r24, Z
    44ba:	88 23       	and	r24, r24
    44bc:	c9 f7       	brne	.-14     	; 0x44b0 <usart_puts+0x4>
	{
		usart_putc(str[i]);
		i++;
	}
}
    44be:	08 95       	ret

000044c0 <__mulsi3>:
    44c0:	62 9f       	mul	r22, r18
    44c2:	d0 01       	movw	r26, r0
    44c4:	73 9f       	mul	r23, r19
    44c6:	f0 01       	movw	r30, r0
    44c8:	82 9f       	mul	r24, r18
    44ca:	e0 0d       	add	r30, r0
    44cc:	f1 1d       	adc	r31, r1
    44ce:	64 9f       	mul	r22, r20
    44d0:	e0 0d       	add	r30, r0
    44d2:	f1 1d       	adc	r31, r1
    44d4:	92 9f       	mul	r25, r18
    44d6:	f0 0d       	add	r31, r0
    44d8:	83 9f       	mul	r24, r19
    44da:	f0 0d       	add	r31, r0
    44dc:	74 9f       	mul	r23, r20
    44de:	f0 0d       	add	r31, r0
    44e0:	65 9f       	mul	r22, r21
    44e2:	f0 0d       	add	r31, r0
    44e4:	99 27       	eor	r25, r25
    44e6:	72 9f       	mul	r23, r18
    44e8:	b0 0d       	add	r27, r0
    44ea:	e1 1d       	adc	r30, r1
    44ec:	f9 1f       	adc	r31, r25
    44ee:	63 9f       	mul	r22, r19
    44f0:	b0 0d       	add	r27, r0
    44f2:	e1 1d       	adc	r30, r1
    44f4:	f9 1f       	adc	r31, r25
    44f6:	bd 01       	movw	r22, r26
    44f8:	cf 01       	movw	r24, r30
    44fa:	11 24       	eor	r1, r1
    44fc:	08 95       	ret

000044fe <__udivmodhi4>:
    44fe:	aa 1b       	sub	r26, r26
    4500:	bb 1b       	sub	r27, r27
    4502:	51 e1       	ldi	r21, 0x11	; 17
    4504:	07 c0       	rjmp	.+14     	; 0x4514 <__udivmodhi4_ep>

00004506 <__udivmodhi4_loop>:
    4506:	aa 1f       	adc	r26, r26
    4508:	bb 1f       	adc	r27, r27
    450a:	a6 17       	cp	r26, r22
    450c:	b7 07       	cpc	r27, r23
    450e:	10 f0       	brcs	.+4      	; 0x4514 <__udivmodhi4_ep>
    4510:	a6 1b       	sub	r26, r22
    4512:	b7 0b       	sbc	r27, r23

00004514 <__udivmodhi4_ep>:
    4514:	88 1f       	adc	r24, r24
    4516:	99 1f       	adc	r25, r25
    4518:	5a 95       	dec	r21
    451a:	a9 f7       	brne	.-22     	; 0x4506 <__udivmodhi4_loop>
    451c:	80 95       	com	r24
    451e:	90 95       	com	r25
    4520:	bc 01       	movw	r22, r24
    4522:	cd 01       	movw	r24, r26
    4524:	08 95       	ret

00004526 <__divmodhi4>:
    4526:	97 fb       	bst	r25, 7
    4528:	09 2e       	mov	r0, r25
    452a:	07 26       	eor	r0, r23
    452c:	0a d0       	rcall	.+20     	; 0x4542 <__divmodhi4_neg1>
    452e:	77 fd       	sbrc	r23, 7
    4530:	04 d0       	rcall	.+8      	; 0x453a <__divmodhi4_neg2>
    4532:	e5 df       	rcall	.-54     	; 0x44fe <__udivmodhi4>
    4534:	06 d0       	rcall	.+12     	; 0x4542 <__divmodhi4_neg1>
    4536:	00 20       	and	r0, r0
    4538:	1a f4       	brpl	.+6      	; 0x4540 <__divmodhi4_exit>

0000453a <__divmodhi4_neg2>:
    453a:	70 95       	com	r23
    453c:	61 95       	neg	r22
    453e:	7f 4f       	sbci	r23, 0xFF	; 255

00004540 <__divmodhi4_exit>:
    4540:	08 95       	ret

00004542 <__divmodhi4_neg1>:
    4542:	f6 f7       	brtc	.-4      	; 0x4540 <__divmodhi4_exit>
    4544:	90 95       	com	r25
    4546:	81 95       	neg	r24
    4548:	9f 4f       	sbci	r25, 0xFF	; 255
    454a:	08 95       	ret

0000454c <__udivmodsi4>:
    454c:	a1 e2       	ldi	r26, 0x21	; 33
    454e:	1a 2e       	mov	r1, r26
    4550:	aa 1b       	sub	r26, r26
    4552:	bb 1b       	sub	r27, r27
    4554:	fd 01       	movw	r30, r26
    4556:	0d c0       	rjmp	.+26     	; 0x4572 <__udivmodsi4_ep>

00004558 <__udivmodsi4_loop>:
    4558:	aa 1f       	adc	r26, r26
    455a:	bb 1f       	adc	r27, r27
    455c:	ee 1f       	adc	r30, r30
    455e:	ff 1f       	adc	r31, r31
    4560:	a2 17       	cp	r26, r18
    4562:	b3 07       	cpc	r27, r19
    4564:	e4 07       	cpc	r30, r20
    4566:	f5 07       	cpc	r31, r21
    4568:	20 f0       	brcs	.+8      	; 0x4572 <__udivmodsi4_ep>
    456a:	a2 1b       	sub	r26, r18
    456c:	b3 0b       	sbc	r27, r19
    456e:	e4 0b       	sbc	r30, r20
    4570:	f5 0b       	sbc	r31, r21

00004572 <__udivmodsi4_ep>:
    4572:	66 1f       	adc	r22, r22
    4574:	77 1f       	adc	r23, r23
    4576:	88 1f       	adc	r24, r24
    4578:	99 1f       	adc	r25, r25
    457a:	1a 94       	dec	r1
    457c:	69 f7       	brne	.-38     	; 0x4558 <__udivmodsi4_loop>
    457e:	60 95       	com	r22
    4580:	70 95       	com	r23
    4582:	80 95       	com	r24
    4584:	90 95       	com	r25
    4586:	9b 01       	movw	r18, r22
    4588:	ac 01       	movw	r20, r24
    458a:	bd 01       	movw	r22, r26
    458c:	cf 01       	movw	r24, r30
    458e:	08 95       	ret

00004590 <__divmodsi4>:
    4590:	97 fb       	bst	r25, 7
    4592:	09 2e       	mov	r0, r25
    4594:	05 26       	eor	r0, r21
    4596:	0e d0       	rcall	.+28     	; 0x45b4 <__divmodsi4_neg1>
    4598:	57 fd       	sbrc	r21, 7
    459a:	04 d0       	rcall	.+8      	; 0x45a4 <__divmodsi4_neg2>
    459c:	d7 df       	rcall	.-82     	; 0x454c <__udivmodsi4>
    459e:	0a d0       	rcall	.+20     	; 0x45b4 <__divmodsi4_neg1>
    45a0:	00 1c       	adc	r0, r0
    45a2:	38 f4       	brcc	.+14     	; 0x45b2 <__divmodsi4_exit>

000045a4 <__divmodsi4_neg2>:
    45a4:	50 95       	com	r21
    45a6:	40 95       	com	r20
    45a8:	30 95       	com	r19
    45aa:	21 95       	neg	r18
    45ac:	3f 4f       	sbci	r19, 0xFF	; 255
    45ae:	4f 4f       	sbci	r20, 0xFF	; 255
    45b0:	5f 4f       	sbci	r21, 0xFF	; 255

000045b2 <__divmodsi4_exit>:
    45b2:	08 95       	ret

000045b4 <__divmodsi4_neg1>:
    45b4:	f6 f7       	brtc	.-4      	; 0x45b2 <__divmodsi4_exit>
    45b6:	90 95       	com	r25
    45b8:	80 95       	com	r24
    45ba:	70 95       	com	r23
    45bc:	61 95       	neg	r22
    45be:	7f 4f       	sbci	r23, 0xFF	; 255
    45c0:	8f 4f       	sbci	r24, 0xFF	; 255
    45c2:	9f 4f       	sbci	r25, 0xFF	; 255
    45c4:	08 95       	ret

000045c6 <__prologue_saves__>:
    45c6:	2f 92       	push	r2
    45c8:	3f 92       	push	r3
    45ca:	4f 92       	push	r4
    45cc:	5f 92       	push	r5
    45ce:	6f 92       	push	r6
    45d0:	7f 92       	push	r7
    45d2:	8f 92       	push	r8
    45d4:	9f 92       	push	r9
    45d6:	af 92       	push	r10
    45d8:	bf 92       	push	r11
    45da:	cf 92       	push	r12
    45dc:	df 92       	push	r13
    45de:	ef 92       	push	r14
    45e0:	ff 92       	push	r15
    45e2:	0f 93       	push	r16
    45e4:	1f 93       	push	r17
    45e6:	cf 93       	push	r28
    45e8:	df 93       	push	r29
    45ea:	cd b7       	in	r28, 0x3d	; 61
    45ec:	de b7       	in	r29, 0x3e	; 62
    45ee:	ca 1b       	sub	r28, r26
    45f0:	db 0b       	sbc	r29, r27
    45f2:	0f b6       	in	r0, 0x3f	; 63
    45f4:	f8 94       	cli
    45f6:	de bf       	out	0x3e, r29	; 62
    45f8:	0f be       	out	0x3f, r0	; 63
    45fa:	cd bf       	out	0x3d, r28	; 61
    45fc:	09 94       	ijmp

000045fe <__epilogue_restores__>:
    45fe:	2a 88       	ldd	r2, Y+18	; 0x12
    4600:	39 88       	ldd	r3, Y+17	; 0x11
    4602:	48 88       	ldd	r4, Y+16	; 0x10
    4604:	5f 84       	ldd	r5, Y+15	; 0x0f
    4606:	6e 84       	ldd	r6, Y+14	; 0x0e
    4608:	7d 84       	ldd	r7, Y+13	; 0x0d
    460a:	8c 84       	ldd	r8, Y+12	; 0x0c
    460c:	9b 84       	ldd	r9, Y+11	; 0x0b
    460e:	aa 84       	ldd	r10, Y+10	; 0x0a
    4610:	b9 84       	ldd	r11, Y+9	; 0x09
    4612:	c8 84       	ldd	r12, Y+8	; 0x08
    4614:	df 80       	ldd	r13, Y+7	; 0x07
    4616:	ee 80       	ldd	r14, Y+6	; 0x06
    4618:	fd 80       	ldd	r15, Y+5	; 0x05
    461a:	0c 81       	ldd	r16, Y+4	; 0x04
    461c:	1b 81       	ldd	r17, Y+3	; 0x03
    461e:	aa 81       	ldd	r26, Y+2	; 0x02
    4620:	b9 81       	ldd	r27, Y+1	; 0x01
    4622:	ce 0f       	add	r28, r30
    4624:	d1 1d       	adc	r29, r1
    4626:	0f b6       	in	r0, 0x3f	; 63
    4628:	f8 94       	cli
    462a:	de bf       	out	0x3e, r29	; 62
    462c:	0f be       	out	0x3f, r0	; 63
    462e:	cd bf       	out	0x3d, r28	; 61
    4630:	ed 01       	movw	r28, r26
    4632:	08 95       	ret

00004634 <memcpy>:
    4634:	fb 01       	movw	r30, r22
    4636:	dc 01       	movw	r26, r24
    4638:	02 c0       	rjmp	.+4      	; 0x463e <memcpy+0xa>
    463a:	01 90       	ld	r0, Z+
    463c:	0d 92       	st	X+, r0
    463e:	41 50       	subi	r20, 0x01	; 1
    4640:	50 40       	sbci	r21, 0x00	; 0
    4642:	d8 f7       	brcc	.-10     	; 0x463a <memcpy+0x6>
    4644:	08 95       	ret

00004646 <_exit>:
    4646:	f8 94       	cli

00004648 <__stop_program>:
    4648:	ff cf       	rjmp	.-2      	; 0x4648 <__stop_program>
